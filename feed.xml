<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://hwangrolee.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://hwangrolee.github.io/" rel="alternate" type="text/html" hreflang="ko"/><updated>2025-08-30T05:34:59+00:00</updated><id>https://hwangrolee.github.io/feed.xml</id><title type="html">이황로의 포트폴리오</title><subtitle>풀스택 개발자로서 시스템 최적화와 성능 개선에 보람을 느낍니다. 안정적이고 확장 가능한 서비스를 만듭니다.</subtitle><entry><title type="html">CQRS 패턴, 읽기와 쓰기 분리로 애플리케이션 성능 극대화하기</title><link href="https://hwangrolee.github.io/blog/CQRS-%ED%8C%A8%ED%84%B4-%EC%9D%BD%EA%B8%B0%EC%99%80-%EC%93%B0%EA%B8%B0-%EB%B6%84%EB%A6%AC%EB%A1%9C-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%B1%EB%8A%A5-%EA%B7%B9%EB%8C%80%ED%99%94%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="CQRS 패턴, 읽기와 쓰기 분리로 애플리케이션 성능 극대화하기"/><published>2025-08-08T01:00:00+00:00</published><updated>2025-08-08T01:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/CQRS-%ED%8C%A8%ED%84%B4-%EC%9D%BD%EA%B8%B0%EC%99%80-%EC%93%B0%EA%B8%B0-%EB%B6%84%EB%A6%AC%EB%A1%9C-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%B1%EB%8A%A5-%EA%B7%B9%EB%8C%80%ED%99%94%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/CQRS-%ED%8C%A8%ED%84%B4-%EC%9D%BD%EA%B8%B0%EC%99%80-%EC%93%B0%EA%B8%B0-%EB%B6%84%EB%A6%AC%EB%A1%9C-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%B1%EB%8A%A5-%EA%B7%B9%EB%8C%80%ED%99%94%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="cqrs란-무엇인가요-현장-경험으로-설명드립니다">CQRS란 무엇인가요? 현장 경험으로 설명드립니다</h2> <p>개발을 하다 보면 가장 자주 마주치는 고민이 하나 있습니다. “왜 우리 시스템은 사용자가 늘어날수록 점점 느려질까요?”</p> <p>CQRS(Command and Query Responsibility Segregation)는 이런 고민에 대한 명쾌한 답 중 하나입니다. 복잡하게 들리지만, 핵심은 매우 단순합니다. 데이터를 “변경하는 일”과 “읽는 일”을 완전히 분리해서 각각 최적화하자는 것입니다.</p> <p>마치 음식점에서 주방(요리 만들기)과 홀(서빙하기)을 분리하는 것과 같습니다. 각자의 역할에 집중할 수 있어 전체적인 효율이 크게 향상됩니다.</p> <h2 id="기존-방식의-근본적인-문제점">기존 방식의 근본적인 문제점</h2> <p>대부분의 개발팀이 처음에는 하나의 서비스로 모든 작업을 처리합니다. 이는 초기에는 매우 합리적인 선택입니다. 코드가 간단하고, 이해하기 쉽고, 빠르게 개발할 수 있기 때문입니다.</p> <p>하지만 현실에서는 예상치 못한 일이 벌어집니다. 실제 서비스를 운영해보면 읽기와 쓰기의 비율이 극도로 불균형합니다. 쇼핑몰의 경우 상품을 보는 사람은 천 명인데, 실제 구매하는 사람은 열 명 정도입니다. 뉴스 사이트라면 더 극단적입니다. 기사를 읽는 사람은 수만 명인데, 기사를 작성하는 기자는 몇 명에 불과합니다.</p> <h3 id="데이터베이스의-딜레마">데이터베이스의 딜레마</h3> <p>데이터베이스 관리자라면 누구나 경험하는 딜레마가 있습니다. 조회를 빠르게 하려면 인덱스를 많이 만들어야 하는데, 인덱스가 많을수록 데이터를 추가하거나 수정할 때 더 오래 걸립니다.</p> <p>이는 마치 도서관에서 책을 빨리 찾기 위해 분류 체계를 복잡하게 만들수록, 새 책을 정리하는 데 더 많은 시간이 걸리는 것과 같습니다.</p> <h3 id="복잡성의-악순환">복잡성의 악순환</h3> <p>시간이 지나면서 하나의 서비스 안에 점점 더 많은 기능이 들어갑니다. 주문을 생성하는 로직, 주문을 수정하는 로직, 주문 목록을 보여주는 로직, 매출 통계를 계산하는 로직까지… 모든 것이 한 곳에 섞여있게 됩니다.</p> <p>결국 새로운 기능을 추가하거나 기존 기능을 수정할 때마다 “혹시 다른 기능에 영향을 주지 않을까?”라는 걱정을 하게 됩니다. 이는 개발 속도를 크게 저하시키는 주요 원인이 됩니다.</p> <h2 id="cqrs가-문제를-해결하는-방법">CQRS가 문제를 해결하는 방법</h2> <h3 id="1-각자의-역할에-집중">1. 각자의 역할에 집중</h3> <p>CQRS에서는 명령(Command) 영역과 조회(Query) 영역이 각자의 전문 분야에만 집중합니다.</p> <p><strong>명령 영역의 특징:</strong></p> <ul> <li>비즈니스 규칙 검증에 집중</li> <li>데이터 일관성 보장이 최우선</li> <li>복잡한 계산과 로직 처리</li> <li>처리 결과는 단순함 (성공/실패 여부)</li> </ul> <p><strong>조회 영역의 특징:</strong></p> <ul> <li>오직 데이터를 빠르게 가져오는 것에만 집중</li> <li>복잡한 비즈니스 로직 없음</li> <li>사용자 화면에 맞는 형태로 데이터 가공</li> <li>다양한 형태의 리포트와 통계 제공</li> </ul> <h3 id="2-데이터-구조의-최적화">2. 데이터 구조의 최적화</h3> <p>가장 놀라운 변화는 데이터 저장 방식입니다.</p> <p><strong>쓰기용 데이터베이스:</strong> 정교한 비즈니스 규칙을 지키기 위해 정규화된 구조를 유지합니다. 데이터의 정확성과 일관성이 가장 중요하므로, 필요한 제약조건과 관계를 모두 설정합니다.</p> <p><strong>읽기용 데이터베이스:</strong> 사용자가 보는 화면에 최적화된 구조로 설계합니다. 고객 이름, 상품명, 총 금액 등 화면에서 필요한 모든 정보를 미리 계산해서 하나의 테이블에 저장해둡니다. 마치 미리 만들어둔 요약본을 읽는 것처럼 빠릅니다.</p> <h3 id="3-성능-개선의-실제-효과">3. 성능 개선의 실제 효과</h3> <p><strong>조회 성능 혁신:</strong> 복잡한 JOIN 쿼리가 사라지면서 응답 시간이 극적으로 개선됩니다. 실제 프로젝트에서 500ms 걸리던 주문 상세 조회가 50ms로 단축되는 것을 여러 번 경험했습니다. 이는 단순히 10배 빠른 것이 아니라, 사용자 경험 자체를 바꾸는 수준의 개선입니다.</p> <p><strong>쓰기 성능 안정화:</strong> 읽기를 위한 복잡한 인덱스에서 해방되면서, 데이터 생성과 수정 작업이 안정적이고 예측 가능해집니다. 트래픽이 급증하는 상황에서도 핵심 비즈니스 로직은 영향받지 않고 정상 동작합니다.</p> <p><strong>확장성의 혁명:</strong> 읽기 서버와 쓰기 서버를 독립적으로 관리할 수 있다는 것은 엄청난 장점입니다. 블랙프라이데이처럼 조회 트래픽이 급증하는 상황에서는 읽기 서버만 추가로 띄우면 됩니다. 반대로 대량의 데이터 처리가 필요한 배치 작업 시에는 쓰기 서버의 성능만 강화하면 됩니다.</p> <h2 id="실무에서-검증된-폴더-구조">실무에서 검증된 폴더 구조</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/main/java/com/example/ecommerce/
├── controller/
│   ├── OrderCommandController.java    # 쓰기 API
│   └── OrderQueryController.java      # 읽기 API
├── service/
│   ├── command/
│   │   └── OrderCommandService.java
│   └── query/
│       └── OrderQueryService.java
├── repository/
│   ├── command/
│   │   └── OrderRepository.java
│   └── query/
│       └── OrderQueryRepository.java
├── dto/
│   ├── command/
│   │   └── CreateOrderRequest.java
│   └── query/
│       └── OrderSummaryDto.java
└── event/
    └── OrderCreatedEvent.java
</code></pre></div></div> <h2 id="핵심-구현-포인트">핵심 구현 포인트</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 명령 서비스: 비즈니스 로직에 집중</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCommandService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createOrder</span><span class="o">(</span><span class="nc">CreateOrderRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 1. 비즈니스 규칙 검증</span>
        <span class="c1">// 2. 데이터 저장</span>
        <span class="c1">// 3. 이벤트 발행 (조회 모델 동기화용)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 조회 서비스: 빠른 데이터 제공에 집중</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderQueryService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">OrderSummaryDto</span> <span class="nf">getOrderSummary</span><span class="o">(</span><span class="nc">Long</span> <span class="n">orderId</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// JOIN 없는 단순 조회로 최고 성능 달성</span>
        <span class="k">return</span> <span class="n">orderQueryRepository</span><span class="o">.</span><span class="na">findSummaryById</span><span class="o">(</span><span class="n">orderId</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="언제-cqrs를-도입해야-할까요">언제 CQRS를 도입해야 할까요?</h2> <p>실무에서의 경험을 바탕으로 말씀드리면, CQRS는 다음과 같은 상황에서 빛을 발합니다:</p> <p><strong>즉시 적용을 고려해야 하는 경우:</strong> 읽기 작업이 쓰기 작업보다 10배 이상 많은 시스템, 복잡한 리포팅과 대시보드가 필요한 시스템, 사용자 수가 급격히 증가하고 있는 시스템입니다.</p> <p><strong>신중하게 판단해야 하는 경우:</strong> 팀 규모가 5명 이하로 작거나, 시스템이 아직 단순한 CRUD 수준이거나, 읽기와 쓰기 비율이 비슷한 시스템에서는 섣불리 도입하지 않는 것이 좋습니다.</p> <h2 id="마무리-선택이-아닌-필수가-되는-순간">마무리: 선택이 아닌 필수가 되는 순간</h2> <p>CQRS는 복잡성을 추가하는 패턴입니다. 하지만 적절한 시점에 도입하면, 그 복잡성을 상쇄하고도 남을 만큼 큰 가치를 제공합니다.</p> <p>시스템이 성장하면서 성능 문제와 복잡성 문제에 직면하고 있다면, CQRS는 선택이 아닌 필수가 될 수 있습니다. 다만, 팀의 역량과 시스템의 특성을 신중히 고려하여 도입 시점을 결정하시기 바랍니다.</p> <p>기술은 문제를 해결하는 도구입니다. CQRS라는 도구가 여러분의 문제 해결에 적합한지 충분히 검토해보시고, 필요하다면 과감하게 도전해보시기 바랍니다.</p>]]></content><author><name></name></author><category term="개발방법론"/><category term="개발방법론"/><summary type="html"><![CDATA[CQRS 패턴으로 애플리케이션 성능을 10배 향상시키는 방법을 알아보세요. 읽기와 쓰기 분리로 데이터베이스 병목현상을 해결하고, Spring Boot에서 바로 적용할 수 있는 실무 폴더 구조와 구현 방법을 상세히 설명합니다.]]></summary></entry><entry><title type="html">현재 상태만 저장하지 말고 모든 변화를 기록하라, 이벤트소싱으로 데이터 히스토리 완벽 관리하기</title><link href="https://hwangrolee.github.io/blog/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%86%8C%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC-%EC%99%84%EB%B2%BD-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="현재 상태만 저장하지 말고 모든 변화를 기록하라, 이벤트소싱으로 데이터 히스토리 완벽 관리하기"/><published>2025-08-08T00:00:00+00:00</published><updated>2025-08-08T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%86%8C%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC-%EC%99%84%EB%B2%BD-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%86%8C%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC-%EC%99%84%EB%B2%BD-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/"><![CDATA[<blockquote> <p>“데이터베이스에 현재 상태만 저장하는 게 당연하다고 생각했다면, 이 글을 끝까지 읽어보세요.”</p> </blockquote> <h2 id="들어가며-왜-이벤트소싱을-알아야-할까요">들어가며: 왜 이벤트소싱을 알아야 할까요?</h2> <p>주니어 개발자 시절, 저는 항상 이런 의문이 있었습니다.</p> <ul> <li> <p><em>“계좌 잔액이 10만 원인 건 알겠는데, 이 돈이 언제 어떻게 들어왔는지는 왜 따로 관리해야 하지?”</em></p> </li> <li> <p><em>“사용자 프로필이 변경됐을 때, 이전 상태는 왜 날려버리는 거지?”</em></p> </li> </ul> <p>바로 이런 의문에서 시작되는 것이 <strong>이벤트소싱(Event Sourcing)</strong>입니다.</p> <hr/> <h2 id="1-이벤트소싱이란--동영상-vs-스냅샷의-차이">1. 이벤트소싱이란? — 동영상 vs 스냅샷의 차이</h2> <h3 id="전통적인-방식-스냅샷-저장"><strong>전통적인 방식: 스냅샷 저장</strong></h3> <p>대부분의 시스템은 데이터의 <strong>현재 상태</strong>만 저장합니다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 일반적인 계좌 테이블</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">accounts</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">BIGINT</span><span class="p">,</span>
    <span class="n">balance</span> <span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>  <span class="c1">-- 현재 잔액만 저장</span>
<span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">accounts</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100000</span><span class="p">);</span>
<span class="c1">-- 10만 원이 있다는 것만 알 수 있음</span>
</code></pre></div></div> <p>이는 마치 <strong>현재 모습의 사진 한 장</strong>만 저장하는 것과 같습니다.</p> <h3 id="이벤트소싱-방식-모든-변화-기록"><strong>이벤트소싱 방식: 모든 변화 기록</strong></h3> <p>이벤트소싱은 <strong>지금까지 일어난 모든 사건(이벤트)</strong>을 순서대로 저장합니다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 이벤트소싱 방식</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">account_events</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">BIGINT</span><span class="p">,</span>
    <span class="n">account_id</span> <span class="nb">BIGINT</span><span class="p">,</span>
    <span class="n">event_type</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
    <span class="n">amount</span> <span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
    <span class="nb">timestamp</span> <span class="nb">TIMESTAMP</span><span class="p">,</span>
    <span class="n">event_data</span> <span class="n">JSON</span>
<span class="p">);</span>

<span class="c1">-- 실제 저장되는 이벤트들</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">account_events</span> <span class="k">VALUES</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">'AccountCreated'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">'2025-08-01 09:00:00'</span><span class="p">,</span> <span class="s1">'{"initial_balance": 0}'</span><span class="p">),</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">'MoneyDeposited'</span><span class="p">,</span> <span class="mi">50000</span><span class="p">,</span> <span class="s1">'2025-08-01 10:30:00'</span><span class="p">,</span> <span class="s1">'{"source": "salary"}'</span><span class="p">),</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">'MoneyDeposited'</span><span class="p">,</span> <span class="mi">30000</span><span class="p">,</span> <span class="s1">'2025-08-05 14:20:00'</span><span class="p">,</span> <span class="s1">'{"source": "bonus"}'</span><span class="p">),</span>
<span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">'MoneyDeposited'</span><span class="p">,</span> <span class="mi">20000</span><span class="p">,</span> <span class="s1">'2025-08-07 16:45:00'</span><span class="p">,</span> <span class="s1">'{"source": "refund"}'</span><span class="p">);</span>
</code></pre></div></div> <p>현재 잔액을 알고 싶다면? <strong>이벤트들을 순서대로 재생</strong>하면 됩니다.</p> <ul> <li>0 + 50,000 + 30,000 + 20,000 = <strong>100,000원</strong></li> </ul> <p>이는 <strong>처음부터 지금까지의 모든 동영상</strong>을 저장하는 것과 같습니다.</p> <hr/> <h2 id="2-왜-필요한가요--실무에서-마주치는-문제들">2. 왜 필요한가요? — 실무에서 마주치는 문제들</h2> <h3 id="시나리오-1-고객-문의-상황"><strong>시나리오 1: 고객 문의 상황</strong></h3> <blockquote> <p><em>“어? 제 계좌에서 3만 원이 사라졌어요. 언제 어떻게 빠진 건가요?”</em></p> </blockquote> <p><strong>전통적인 방식의 한계:</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">balance</span> <span class="k">FROM</span> <span class="n">accounts</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="c1">-- 결과: 70000</span>
<span class="c1">-- 3만 원이 줄어든 건 맞는데... 언제? 왜?</span>
</code></pre></div></div> <p><strong>이벤트소싱의 답:</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">account_events</span> <span class="k">WHERE</span> <span class="n">account_id</span> <span class="o">=</span> <span class="mi">100</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="nb">timestamp</span><span class="p">;</span>
<span class="c1">-- 2025-08-10 15:30:00: MoneyWithdrawn, -30000, {"reason": "ATM_withdrawal", "location": "강남역"}</span>
<span class="c1">-- 명확한 추적 가능!</span>
</code></pre></div></div> <h3 id="시나리오-2-버그-발생-시-복구"><strong>시나리오 2: 버그 발생 시 복구</strong></h3> <p>시스템 버그로 인해 2025년 8월 8일부터 잘못된 계산이 적용되었다면?</p> <p><strong>전통적인 방식:</strong></p> <ul> <li>현재 상태만 있으므로 <strong>복구 불가능</strong></li> <li>백업에서 복원해야 함 (데이터 손실 발생)</li> </ul> <p><strong>이벤트소싱 방식:</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 8월 7일까지의 이벤트만 재생하여 올바른 상태로 복구</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Event</span><span class="o">&gt;</span> <span class="n">eventsUntilAugust7</span> <span class="o">=</span> <span class="n">getEventsUntil</span><span class="o">(</span><span class="s">"2025-08-07"</span><span class="o">);</span>
<span class="nc">AccountState</span> <span class="n">correctState</span> <span class="o">=</span> <span class="n">replayEvents</span><span class="o">(</span><span class="n">eventsUntilAugust7</span><span class="o">);</span>
</code></pre></div></div> <hr/> <h2 id="3-핵심-개념-정리">3. 핵심 개념 정리</h2> <h3 id="이벤트event"><strong>이벤트(Event)</strong></h3> <blockquote> <p><em>시스템에서 발생한 의미있는 사건</em></p> </blockquote> <ul> <li><strong>과거형으로 표현</strong>: <code class="language-plaintext highlighter-rouge">UserRegistered</code>, <code class="language-plaintext highlighter-rouge">OrderPlaced</code>, <code class="language-plaintext highlighter-rouge">PaymentCompleted</code></li> <li><strong>불변(Immutable)</strong>: 한 번 발생한 이벤트는 수정되지 않음</li> <li><strong>시간순 정렬</strong>: 발생 순서가 매우 중요</li> </ul> <h3 id="이벤트-재생event-replay"><strong>이벤트 재생(Event Replay)</strong></h3> <blockquote> <p><em>저장된 이벤트들을 순서대로 실행하여 현재 상태를 복원하는 과정</em></p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AccountAggregate</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">accountId</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">BigDecimal</span> <span class="n">balance</span> <span class="o">=</span> <span class="nc">BigDecimal</span><span class="o">.</span><span class="na">ZERO</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="nc">MoneyDepositedEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">balance</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">balance</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAmount</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="nc">MoneyWithdrawnEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">balance</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">balance</span><span class="o">.</span><span class="na">subtract</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAmount</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="이벤트-스토어event-store"><strong>이벤트 스토어(Event Store)</strong></h3> <blockquote> <p><em>이벤트들을 저장하는 특수한 데이터베이스</em></p> </blockquote> <ul> <li>일반 RDBMS, NoSQL, 또는 전용 Event Store 사용</li> <li><strong>Append-only</strong>: 새로운 이벤트만 추가, 기존 이벤트는 수정/삭제 금지</li> </ul> <hr/> <h2 id="4-장점--왜-복잡해-보이는데-쓸까요">4. 장점 — 왜 복잡해 보이는데 쓸까요?</h2> <h3 id="완벽한-감사-추적audit-trail"><strong>완벽한 감사 추적(Audit Trail)</strong></h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 특정 기간의 모든 거래 내역 조회</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Event</span><span class="o">&gt;</span> <span class="n">transactions</span> <span class="o">=</span> <span class="n">eventStore</span><span class="o">.</span><span class="na">getEvents</span><span class="o">(</span>
    <span class="n">accountId</span><span class="o">,</span>
    <span class="nc">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2025</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span>
    <span class="nc">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2025</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">31</span><span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div> <p><strong>활용 사례:</strong></p> <ul> <li>금융 시스템의 규제 준수</li> <li>게임에서 치팅 방지</li> <li>의료 시스템의 환자 기록 추적</li> </ul> <h3 id="타임머신-기능--과거-상태-재현"><strong>타임머신 기능 — 과거 상태 재현</strong></h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 2025년 8월 5일 시점의 계좌 상태 확인</span>
<span class="nc">AccountState</span> <span class="n">pastState</span> <span class="o">=</span> <span class="n">replayEventsUntil</span><span class="o">(</span><span class="n">accountId</span><span class="o">,</span> <span class="s">"2025-08-05"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"8월 5일 잔액: "</span> <span class="o">+</span> <span class="n">pastState</span><span class="o">.</span><span class="na">getBalance</span><span class="o">());</span>
</code></pre></div></div> <p><strong>실무 활용:</strong></p> <ul> <li>A/B 테스트 결과 분석</li> <li>과거 시점 기준 리포트 생성</li> <li>버그 재현 및 디버깅</li> </ul> <h3 id="자연스러운-이벤트-발행"><strong>자연스러운 이벤트 발행</strong></h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@EventHandler</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">MoneyDepositedEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 다른 서비스에 즉시 알림</span>
    <span class="n">emailService</span><span class="o">.</span><span class="na">sendDepositNotification</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAccountId</span><span class="o">(),</span> <span class="n">event</span><span class="o">.</span><span class="na">getAmount</span><span class="o">());</span>
    <span class="n">loyaltyService</span><span class="o">.</span><span class="na">addPoints</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAccountId</span><span class="o">(),</span> <span class="n">calculatePoints</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAmount</span><span class="o">()));</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>마이크로서비스 환경</strong>에서 서비스 간 데이터 동기화가 자연스럽게 해결됩니다.</p> <hr/> <h2 id="5-단점과-해결책--현실적인-고민들">5. 단점과 해결책 — 현실적인 고민들</h2> <h3 id="데이터-저장소-사용량-증가"><strong>데이터 저장소 사용량 증가</strong></h3> <p><strong>문제:</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 1년간 거래가 많은 계좌의 이벤트</span>
<span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">account_events</span> <span class="k">WHERE</span> <span class="n">account_id</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="c1">-- 결과: 50,000개 이벤트</span>
</code></pre></div></div> <p><strong>해결책: 스냅샷(Snapshot) 기법</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1000개 이벤트마다 스냅샷 생성</span>
<span class="k">if</span> <span class="o">(</span><span class="n">eventCount</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Snapshot</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Snapshot</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">,</span> <span class="n">currentState</span><span class="o">,</span> <span class="n">eventCount</span><span class="o">);</span>
    <span class="n">snapshotStore</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">snapshot</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 상태 복원 시 최신 스냅샷부터 시작</span>
<span class="nc">Snapshot</span> <span class="n">latestSnapshot</span> <span class="o">=</span> <span class="n">snapshotStore</span><span class="o">.</span><span class="na">getLatest</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">);</span>
<span class="nc">AccountState</span> <span class="n">state</span> <span class="o">=</span> <span class="n">latestSnapshot</span><span class="o">.</span><span class="na">getState</span><span class="o">();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Event</span><span class="o">&gt;</span> <span class="n">eventsAfterSnapshot</span> <span class="o">=</span> <span class="n">eventStore</span><span class="o">.</span><span class="na">getEventsAfter</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">,</span> <span class="n">latestSnapshot</span><span class="o">.</span><span class="na">getVersion</span><span class="o">());</span>
<span class="k">return</span> <span class="nf">replayEvents</span><span class="o">(</span><span class="n">state</span><span class="o">,</span> <span class="n">eventsAfterSnapshot</span><span class="o">);</span>
</code></pre></div></div> <h3 id="이벤트-재생-성능-이슈"><strong>이벤트 재생 성능 이슈</strong></h3> <p><strong>문제:</strong> 이벤트가 많아지면 상태 복원이 느려짐</p> <p><strong>해결책:</strong></p> <ol> <li><strong>CQRS 패턴 적용</strong> — 읽기 전용 뷰 모델 분리</li> <li><strong>캐싱</strong> — 자주 조회되는 상태는 메모리에 캐싱</li> <li><strong>이벤트 압축</strong> — 중요하지 않은 중간 이벤트 제거</li> </ol> <h3 id="개발-복잡도-증가"><strong>개발 복잡도 증가</strong></h3> <p><strong>전통적 CRUD:</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateBalance</span><span class="o">(</span><span class="nc">String</span> <span class="n">accountId</span><span class="o">,</span> <span class="nc">BigDecimal</span> <span class="n">newBalance</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">accountRepository</span><span class="o">.</span><span class="na">updateBalance</span><span class="o">(</span><span class="n">accountId</span><span class="o">,</span> <span class="n">newBalance</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>이벤트소싱:</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">deposit</span><span class="o">(</span><span class="nc">String</span> <span class="n">accountId</span><span class="o">,</span> <span class="nc">BigDecimal</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Account</span> <span class="n">account</span> <span class="o">=</span> <span class="n">loadAccount</span><span class="o">(</span><span class="n">accountId</span><span class="o">);</span>
    <span class="nc">MoneyDepositedEvent</span> <span class="n">event</span> <span class="o">=</span> <span class="n">account</span><span class="o">.</span><span class="na">deposit</span><span class="o">(</span><span class="n">amount</span><span class="o">);</span>
    <span class="n">eventStore</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">accountId</span><span class="o">,</span> <span class="n">event</span><span class="o">);</span>
    <span class="n">account</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>해결책:</strong> 프레임워크 활용 (Axon Framework, EventStore 등)</p> <hr/> <h2 id="6-실전-적용-언제-사용하면-좋을까요">6. 실전 적용: 언제 사용하면 좋을까요?</h2> <h3 id="강력-추천-사례"><strong>강력 추천 사례</strong></h3> <h4 id="금융결제-시스템">금융/결제 시스템</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PaymentAggregate</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">PaymentInitiatedEvent</span> <span class="nf">initiatePayment</span><span class="o">(</span><span class="nc">PaymentCommand</span> <span class="n">cmd</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 결제 시작 이벤트</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">PaymentCompletedEvent</span> <span class="nf">completePayment</span><span class="o">(</span><span class="nc">String</span> <span class="n">paymentId</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 결제 완료 이벤트</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">PaymentFailedEvent</span> <span class="nf">failPayment</span><span class="o">(</span><span class="nc">String</span> <span class="n">paymentId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">reason</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 결제 실패 이벤트</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>이유:</strong> 금융 감독 기관의 <strong>추적 가능성</strong> 요구사항을 자연스럽게 만족</p> <h4 id="전자상거래-주문-시스템">전자상거래 주문 시스템</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 주문 생명주기 추적</span>
<span class="nc">OrderCreatedEvent</span> <span class="o">-&gt;</span> <span class="nc">OrderPaidEvent</span> <span class="o">-&gt;</span> <span class="nc">OrderShippedEvent</span> <span class="o">-&gt;</span> <span class="nc">OrderDeliveredEvent</span>
</code></pre></div></div> <p><strong>이유:</strong> 고객 문의 대응과 <strong>배송 추적</strong>이 필수</p> <h4 id="게임-서비스">게임 서비스</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 플레이어 행동 기록</span>
<span class="nc">PlayerJoinedEvent</span> <span class="o">-&gt;</span> <span class="nc">ItemPurchasedEvent</span> <span class="o">-&gt;</span> <span class="nc">LevelUpEvent</span> <span class="o">-&gt;</span> <span class="nc">GameCompletedEvent</span>
</code></pre></div></div> <p><strong>이유:</strong> <strong>치팅 방지</strong>와 <strong>게임 밸런싱</strong> 분석에 활용</p> <h3 id="신중하게-고려해야-할-사례"><strong>신중하게 고려해야 할 사례</strong></h3> <h4 id="단순한-crud-애플리케이션">단순한 CRUD 애플리케이션</h4> <ul> <li>사용자 프로필 관리</li> <li>상품 카탈로그 관리</li> <li>정적 컨텐츠 관리</li> </ul> <p><strong>이유:</strong> 이력 추적의 <strong>비즈니스 가치</strong>가 낮고 <strong>복잡도</strong>만 증가</p> <h4 id="실시간-성능이-중요한-시스템">실시간 성능이 중요한 시스템</h4> <ul> <li>고빈도 거래 시스템 (HFT)</li> <li>실시간 게임 서버</li> <li>IoT 센서 데이터 처리</li> </ul> <p><strong>이유:</strong> 이벤트 재생으로 인한 <strong>지연시간</strong> 문제</p> <hr/> <h2 id="7-실제-구현-예시--spring-boot--jpa">7. 실제 구현 예시 — Spring Boot + JPA</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventEntity</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">aggregateId</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">eventType</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">eventData</span><span class="o">;</span>  <span class="c1">// JSON 형태로 저장</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">occurredAt</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">version</span><span class="o">;</span>  <span class="c1">// 낙관적 락을 위한 버전</span>
<span class="o">}</span>

<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventStore</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EventRepository</span> <span class="n">eventRepository</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">ObjectMapper</span> <span class="n">objectMapper</span><span class="o">;</span>

    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">append</span><span class="o">(</span><span class="nc">String</span> <span class="n">aggregateId</span><span class="o">,</span> <span class="nc">DomainEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">EventEntity</span> <span class="n">entity</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EventEntity</span><span class="o">();</span>
        <span class="n">entity</span><span class="o">.</span><span class="na">setAggregateId</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">);</span>
        <span class="n">entity</span><span class="o">.</span><span class="na">setEventType</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">());</span>
        <span class="n">entity</span><span class="o">.</span><span class="na">setEventData</span><span class="o">(</span><span class="n">objectMapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">event</span><span class="o">));</span>
        <span class="n">entity</span><span class="o">.</span><span class="na">setOccurredAt</span><span class="o">(</span><span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>

        <span class="n">eventRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">entity</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">DomainEvent</span><span class="o">&gt;</span> <span class="nf">getEvents</span><span class="o">(</span><span class="nc">String</span> <span class="n">aggregateId</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">EventEntity</span><span class="o">&gt;</span> <span class="n">entities</span> <span class="o">=</span> <span class="n">eventRepository</span>
            <span class="o">.</span><span class="na">findByAggregateIdOrderByOccurredAt</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">entities</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">deserialize</span><span class="o">)</span>
            <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toList</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="8-마무리-이벤트소싱을-시작하기-전에">8. 마무리: 이벤트소싱을 시작하기 전에</h2> <h3 id="스스로에게-물어보세요"><strong>스스로에게 물어보세요</strong></h3> <ol> <li><strong>“우리 시스템에서 데이터 변경 이력이 중요한가?”</strong> <ul> <li>중요하다면 → 이벤트소싱 고려</li> <li>중요하지 않다면 → 전통적 방식으로 충분</li> </ul> </li> <li><strong>“감사 추적이나 규제 준수가 필요한가?”</strong> <ul> <li>필요하다면 → 이벤트소싱 강력 추천</li> <li>필요없다면 → 다른 아키텍처 패턴 고려</li> </ul> </li> <li><strong>“팀이 복잡도 증가를 감당할 수 있는가?”</strong> <ul> <li>가능하다면 → 점진적 도입</li> <li>어렵다면 → 충분한 학습 후 적용</li> </ul> </li> </ol> <h3 id="시작하기-좋은-방법"><strong>시작하기 좋은 방법</strong></h3> <ol> <li><strong>작은 도메인부터</strong>: 전체 시스템이 아닌 <strong>한 개 도메인</strong>에만 적용</li> <li><strong>프레임워크 활용</strong>: Axon Framework, EventStore 등으로 <strong>러닝커브 단축</strong></li> <li><strong>하이브리드 접근</strong>: 핵심 도메인만 이벤트소싱, 나머지는 전통적 방식</li> </ol> <hr/> <h2 id="한-줄-요약">한 줄 요약</h2> <p><strong>이벤트소싱은 “모든 변화를 기록하여 완벽한 추적성을 제공하는” 아키텍처 패턴입니다.</strong></p> <p>단순한 현재 상태 저장이 아닌 <strong>변화의 역사</strong>를 보존함으로써, 더 강력한 <strong>감사 추적</strong>, <strong>디버깅</strong>, <strong>복구 능력</strong>을 제공합니다.</p> <p>복잡해 보이지만, 비즈니스에 진짜 가치를 제공하는 영역에서는 그 복잡함을 상쇄하고도 남을 만큼 강력한 도구입니다.</p> <p><strong><em>이벤트소싱이 모든 문제의 해답은 아닙니다. 하지만 언제 써야 하고 언제 쓰지 말아야 하는지를 아는 것만으로도 더 나은 아키텍처 결정을 내릴 수 있을 것입니다.</em></strong></p>]]></content><author><name></name></author><category term="개발방법론"/><category term="개발방법론"/><summary type="html"><![CDATA[이벤트소싱 완벽 가이드, 현재 상태만 저장하는 방식의 한계를 벗어나 모든 데이터 변화를 기록하는 아키텍처 패턴. 실무 예제와 Spring Boot 구현 코드로 배우는 Event Sourcing 입문서]]></summary></entry><entry><title type="html">Java 문자열 포맷팅 비교 String.format() vs MessageFormat 성능과 사용법 정리</title><link href="https://hwangrolee.github.io/blog/Java-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%8F%AC%EB%A7%B7%ED%8C%85-%EB%B9%84%EA%B5%90/" rel="alternate" type="text/html" title="Java 문자열 포맷팅 비교 String.format() vs MessageFormat 성능과 사용법 정리"/><published>2025-08-07T00:00:00+00:00</published><updated>2025-08-07T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/Java-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%8F%AC%EB%A7%B7%ED%8C%85-%EB%B9%84%EA%B5%90</id><content type="html" xml:base="https://hwangrolee.github.io/blog/Java-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%8F%AC%EB%A7%B7%ED%8C%85-%EB%B9%84%EA%B5%90/"><![CDATA[<h3 id="1-stringformat-vs-messageformat-소개">1. String.format() vs MessageFormat 소개</h3> <p>Java에서 문자열을 동적으로 조합할 때 가장 많이 사용되는 방법 중 하나가 바로 String.format()입니다. 하지만 국제화(i18n)나 다국어 메시지를 처리할 때는 MessageFormat이라는 또 다른 강력한 도구도 있습니다. 이 두 방식은 비슷해 보이지만, 실제로는 목적과 기능 면에서 상당한 차이를 가지고 있습니다.</p> <h3 id="2-stringformat--간결하고-빠른-문자열포매팅">2. String.format() – 간결하고 빠른 문자열 포매팅</h3> <p>String.format()은 C언어의 printf() 스타일 포맷을 기반으로 하며, 가독성이 좋고 직관적인 방식으로 문자열을 구성할 수 있습니다. 간단한 변수 삽입, 숫자 포맷, 정렬 등이 필요한 경우에 매우 유용합니다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"홍길동"</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">30</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"이름: %s, 나이: %d"</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
<span class="c1">// 출력: 이름: 홍길동, 나이: 30</span>
</code></pre></div></div> <ul> <li>%s, %d, %f 같은 포맷 문자를 사용</li> <li>위치 기반이 아닌 순차적 변수 삽입</li> <li>단순한 텍스트 처리에 적합</li> <li>성능이 좋고 코드가 짧음</li> </ul> <h3 id="3-messageformat--다국어-처리에-강한-국제화-포맷도구">3. MessageFormat – 다국어 처리에 강한 국제화 포맷 도구</h3> <p>반면 MessageFormat은 Java의 국제화(i18n) 지원을 위해 설계된 포맷팅 도구입니다 ResourceBundle과 함께 자주 사용되며, 로케일(Locale)에 따라 날짜, 숫자, 통화 등의 포맷을 자동으로 조정할 수 있습니다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.text.MessageFormat</span><span class="o">;</span>

<span class="nc">String</span> <span class="n">pattern</span> <span class="o">=</span> <span class="s">"이름: {0}, 나이: {1}"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">MessageFormat</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">pattern</span><span class="o">,</span> <span class="s">"홍길동"</span><span class="o">,</span> <span class="mi">30</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
<span class="c1">// 출력: 이름: 홍길동, 나이: 30</span>
</code></pre></div></div> <ul> <li>{0}, {1} 형태의 인덱스 기반 변수 삽입</li> <li>내부적으로 로케일 지원, 날짜/숫자 자동 포맷 가능</li> <li>다국어 메시지 파일과의 궁합이 뛰어남</li> <li>복잡한 메시지 구성이 필요한 경우에 적합</li> </ul> <h3 id="4-언제-어떤-걸-써야할까">4. 언제 어떤 걸 써야 할까?</h3> <ul> <li>빠르고 간단한 문자열 치환만 필요할 때는 String.format()이 훨씬 효율적입니다.</li> <li>로케일에 따라 메시지 포맷이 달라지거나, 메시지를 ResourceBundle로 관리하는 경우에는 MessageFormat이 필수입니다.</li> </ul> <h3 id="5-성능-비교-stringformat-vs-messageformat">5. 성능 비교: String.format() vs MessageFormat</h3> <p>문자열 포맷팅 방식은 실제 애플리케이션에서 반복적으로 호출되는 경우가 많기 때문에, 성능 차이는 무시할 수 없습니다. 이번 섹션에서는 String.format()과 MessageFormat의 실제 성능 차이와 메모리 사용량을 간단히 비교해 보겠습니다.</p> <h4 id="6간단한-벤치마크결과">6.간단한 벤치마크 결과</h4> <table> <thead> <tr> <th>항목</th> <th>String.format()</th> <th>MessageFormat.format()</th> </tr> </thead> <tbody> <tr> <td>평균 실행 시간</td> <td>약 4~6 마이크로초(μs)</td> <td>약 10~15 마이크로초(μs)</td> </tr> <tr> <td>메모리 사용량</td> <td>낮음</td> <td>상대적으로 높음</td> </tr> <tr> <td>GC 발생</td> <td>거의 없음</td> <td>간헐적으로 발생 가능</td> </tr> <tr> <td>특징</td> <td>포맷 분석이 단순하고 빠름</td> <td>포맷 문자열을 파싱하는 과정이 복잡하여 오버헤드 발생</td> </tr> <tr> <td> </td> <td> </td> <td> </td> </tr> </tbody> </table> <ul> <li>단순한 문자열 처리라면 String.format()이 속도와 메모리 면에서 유리합니다.</li> <li>다국어 처리, 로케일 기반 포맷팅이 필요한 경우는 MessageFormat이 적합합니다.</li> <li>두 방식은 성능 차이가 2배 이상 발생할 수 있으므로, 용도에 맞는 선택이 중요합니다.</li> </ul>]]></content><author><name></name></author><category term="자바"/><category term="자바"/><summary type="html"><![CDATA[Java String.format()과 MessageFormat 성능 비교와 사용법 완벽 가이드. 언제 어떤 방식을 선택해야 하는지 벤치마크 결과와 실제 예제로 알아보세요. 국제화 처리부터 최적화까지.]]></summary></entry><entry><title type="html">Java 8 이후 바뀐 자바 문법 총정리 — Java 17까지 꼭 알아야 할 핵심 변화</title><link href="https://hwangrolee.github.io/blog/Java17%EA%B9%8C%EC%A7%80-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%ED%95%B5%EC%8B%AC-%EB%B3%80%ED%99%94/" rel="alternate" type="text/html" title="Java 8 이후 바뀐 자바 문법 총정리 — Java 17까지 꼭 알아야 할 핵심 변화"/><published>2025-08-06T00:00:00+00:00</published><updated>2025-08-06T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/Java17%EA%B9%8C%EC%A7%80-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%ED%95%B5%EC%8B%AC-%EB%B3%80%ED%99%94</id><content type="html" xml:base="https://hwangrolee.github.io/blog/Java17%EA%B9%8C%EC%A7%80-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%ED%95%B5%EC%8B%AC-%EB%B3%80%ED%99%94/"><![CDATA[<p>Java 8은 오랜 기간 동안 자바 개발의 중심이었습니다.</p> <p>람다, 스트림, Optional 등 지금도 널리 쓰이는 기능들이 도입되면서 자바 개발자들에게 새로운 방식의 프로그래밍을 소개했던 버전입니다.</p> <p>하지만 그로부터 벌써 10년이 흘렀고, 자바는 지금도 꾸준히 진화하고 있습니다. 많은 개발자들이 Java 8에 머물러 있는 동안, 자바는 코드 작성 방식, API 설계 방식, 클래스 설계 방식에서 많은 변화를 겪었습니다.</p> <h3 id="java-17이-중요한이유">Java 17이 중요한 이유</h3> <p>가장 큰 이유는 Spring Boot 3.x부터 Java 17 이상을 필수로 요구하기 때문입니다.</p> <p>이제 새로운 프로젝트나 주요 프레임워크를 최신으로 사용하려면 Java 17은 선택이 아니라 기본 전제가 되었습니다.</p> <p>또한 Java 17은 장기 지원(LTS) 버전입니다.</p> <p>Java 11 이후 6년 만에 등장한 LTS 버전으로, 기업 환경에서도 안정적으로 채택되고 있으며 다양한 프레임워크들이 Java 17을 기준으로 개발되고 있습니다.</p> <h3 id="바뀐-건-단순히-버전-숫자만이아닙니다">바뀐 건 단순히 버전 숫자만이 아닙니다</h3> <p><strong><em>Java 9부터 17까지는 단순한 기능 추가나 마이너 개선이 아니라, 자바라는 언어의 방향성과 스타일 자체에 변화가 있었습니다.</em></strong> 기존의 장황한 코딩 방식은 더 이상 필수가 아니며, 이제는 간결하고 읽기 쉬운 코드, 명확한 타입 추론, 안전한 클래스 설계 방식이 주류가 되었습니다.</p> <p>또한 자바는 최근 몇 년간의 변화 속도도 매우 빨라졌습니다. 예전에는 몇 년마다 새 버전이 나왔지만, 이제는 매년 새로운 기능과 개선 사항이 정기적으로 포함되며, 이러한 변화는 자바를 과거의 언어가 아닌 현대적인 언어로 다시 만들어가고 있습니다.</p> <p><strong><em>Java 17을 기준으로 개발 환경이 재편되고 있습니다.</em></strong> 현재 대부분의 주요 프레임워크와 라이브러리는 Java 17을 기준으로 작동하거나, 그 이상을 요구하고 있습니다. 예를 들어 Spring Boot 3, Hibernate 6 등의 프레임워크는 Java 17 이상에서 개발 및 테스트되고 있으며, 이전 버전의 자바에서는 호환되지 않거나 일부 기능을 쓸 수 없는 경우도 많습니다.</p> <p>또한 클라우드 네이티브 개발 환경, 빌드 시스템, 테스트 프레임워크 등도 Java 17에 맞춰 업데이트되고 있습니다. 자바 개발자로서의 경쟁력을 유지하고 싶다면 Java 17은 더 이상 선택이 아닌 필수입니다.</p> <h3 id="java-8-개발자라면-지금이적기입니다">Java 8 개발자라면 지금이 적기입니다.</h3> <p>Java 17로의 전환은 생각보다 어렵지 않습니다. 특히 Java 8까지 익숙한 개발자라면, 지금부터 주요 문법과 특징 몇 가지만 익히면 금방 적응할 수 있습니다.</p> <ul> <li>새로운 프로젝트를 Java 17 기반으로 시작하려는 분들,</li> <li>Spring Boot 3로 마이그레이션을 고민 중인 분들,</li> <li>Lombok 없이 깔끔한 코드를 작성하고 싶은 분들이라면,</li> </ul> <p>이제는 Java 17을 학습할 시점입니다.</p> <h3 id="var-키워드--지역-변수-타입-추론-java-10도입">var 키워드 – 지역 변수 타입 추론 (Java 10 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <pre><code class="language-javaa">var scores = new HashMap&lt;String, List&lt;Integer&gt;&gt;();
</code></pre> <p><strong>어떤 점이 좋아졌나?</strong></p> <p>코드가 훨씬 간결해집니다. 특히 제네릭 타입이 길어질수록 우측 타입만으로 충분히 추론 가능할 때, 가독성이 올라갑니다.</p> <p>타입은 컴파일 타임에 고정되므로 동적 타입처럼 오해할 필요가 없습니다.</p> <p><strong>주의할 점</strong></p> <p>타입을 명확히 드러내는 것이 중요한 경우, var 대신 명시적 타입 사용이 오히려 낫습니다.</p> <h3 id="record--불변-데이터-클래스를-한-줄로-java-16도입">record – 불변 데이터 클래스를 한 줄로 (Java 16 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

    <span class="o">}</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>불변 객체 패턴을 아주 간결하게 작성할 수 있습니다.</li> <li>생성자, getter, equals, hashCode, toString을 자동 생성합니다.</li> <li>Lombok 없이도 DTO를 쉽게 만들 수 있습니다.</li> <li>데이터 중심 클래스를 명확히 표현할 수 있습니다.</li> </ul> <h3 id="text-block--멀티라인-문자열-java-15도입">Text Block – 멀티라인 문자열 (Java 15 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">json</span> <span class="o">=</span> <span class="s">"{\n"</span> <span class="o">+</span>
    <span class="s">" \"name\": \"John\",\n"</span> <span class="o">+</span>
    <span class="s">" \"age\": 30\n"</span> <span class="o">+</span>
    <span class="s">"}"</span><span class="o">;</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">json</span> <span class="o">=</span> <span class="sh">"""
    {
    "name": "John",
    "age": 30
    }
    """</span><span class="o">;</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>멀티라인 문자열을 이스케이프 없이 그대로 표현할 수 있습니다.</li> <li>SQL, JSON, XML, HTML 같은 문자열을 쓸 때 가독성이 대폭 향상됩니다.</li> <li>들여쓰기나 줄바꿈 처리도 유연하게 지원됩니다.</li> </ul> <h3 id="switch-표현식--조건문을-더-간결하고-안전하게-java-14도입">switch 표현식 – 조건문을 더 간결하고 안전하게 (Java 14 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">result</span><span class="o">;</span>
<span class="k">switch</span> <span class="o">(</span><span class="n">day</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nl">MONDAY:</span>
    <span class="k">case</span> <span class="nl">TUESDAY:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">"Weekday"</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="k">case</span> <span class="nl">SATURDAY:</span>
    <span class="k">case</span> <span class="nl">SUNDAY:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">"Weekend"</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">"Unknown"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="k">switch</span> <span class="o">(</span><span class="n">day</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="no">MONDAY</span><span class="o">,</span> <span class="no">TUESDAY</span> <span class="o">-&gt;</span> <span class="s">"Weekday"</span><span class="o">;</span>
    <span class="k">case</span> <span class="no">SATURDAY</span><span class="o">,</span> <span class="no">SUNDAY</span> <span class="o">-&gt;</span> <span class="s">"Weekend"</span><span class="o">;</span>
    <span class="k">default</span> <span class="o">-&gt;</span> <span class="s">"Unknown"</span><span class="o">;</span>
<span class="o">};</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>값을 반환할 수 있는 switch 표현식이 도입되어, 변수를 미리 선언할 필요가 없습니다. <ul> <li>문법으로 break 누락으로 인한 실수 방지.</li> </ul> </li> <li>yield를 활용하면 복잡한 로직도 표현 가능.</li> <li>함수형 스타일에 더 가까워졌습니다.</li> </ul> <h3 id="pattern-matching-for-instanceof--타입-검사와-캐스팅을-동시에-java-16도입">Pattern Matching for instanceof – 타입 검사와 캐스팅을 동시에 (Java 16 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">User</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="o">(</span><span class="nc">User</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>중복 코드 제거: 타입 체크 후 명시적 캐스팅을 반복할 필요가 없습니다.</li> <li>가독성 향상: 조건문에서 타입 이름을 한 번만 쓰면 됩니다.</li> <li>향후 도입될 switch 패턴 매칭과도 연계됩니다.</li> </ul> <h2 id="sealed-class--상속을-명시적으로-제한-java-17-정식도입">sealed class – 상속을 명시적으로 제한 (Java 17 정식 도입)</h2> <p><strong>Java 8 방식</strong></p> <ul> <li>상속 제한을 하려면 final로 막거나, 문서로 설명해야 했습니다.</li> </ul> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">sealed</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="n">permits</span> <span class="nc">Dog</span><span class="o">,</span> <span class="nc">Cat</span> <span class="o">{}</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{}</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{}</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>허용된 하위 클래스만 상속할 수 있도록 제한합니다.</li> <li>클래스 계층 구조가 예측 가능하고 안전해집니다.</li> <li>도메인 모델링 시, 허용된 상태나 유형만 정의 가능.</li> <li>자바 컴파일러가 하위 클래스를 정확히 알기 때문에 패턴 매칭에도 최적화됩니다.</li> </ul> <h3 id="기타-유용한변화들">기타 유용한 변화들</h3> <ul> <li>String에 새로운 메서드들 추가</li> <li>isBlank(): 공백 문자열 여부 확인</li> <li>repeat(int): 문자열 반복</li> <li>lines(): 줄 단위로 스트림 처리</li> <li>HttpClient: java.net.http.HttpClient가 정식 API로 도입됨 (Java 11)</li> <li>jshell: 자바 REPL 지원 (Java 9) – 빠른 테스트 가능</li> </ul> <h3 id="마무리-요약">마무리 요약</h3> <p>Java 17로 넘어오면서 자바는 더 이상 “장황한 코드”를 쓰는 언어가 아닙니다. 코드는 짧아졌고, 타입은 안전해졌으며, 불변성을 쉽게 유지할 수 있고, 조건문도 더 선언적으로 바뀌었습니다.</p> <p>기존 Java 8 방식에 익숙한 개발자라면, 다음과 같은 점에서 만족하실 수 있습니다:</p> <ul> <li>DTO 작성이 1줄로 끝난다 (record)</li> <li>조건문이 훨씬 직관적이다 (switch, pattern matching)</li> <li>JSON이나 SQL 문자열을 쓸 때 코드가 지저분하지 않다 (text block)</li> <li>상속과 타입 검사도 명확해졌다 (sealed, instanceof 개선)</li> </ul> <p>지금 Java 17을 익혀두신다면 앞으로 자바 개발에서 훨씬 높은 생산성과 안정성을 얻을 수 있습니다.</p>]]></content><author><name></name></author><category term="자바"/><category term="자바"/><summary type="html"><![CDATA[Java 8에서 Java 17로 업그레이드해야 하는 이유와 핵심 신기능들을 실무 예제와 함께 알아보세요]]></summary></entry><entry><title type="html">왜 개발자들은 OAuth와 OpenID Connect를 헷갈릴까?</title><link href="https://hwangrolee.github.io/blog/%EC%99%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%80-OAuth%EC%99%80-OpenID-Connect%EB%A5%BC-%ED%97%B7%EA%B0%88%EB%A6%B4%EA%B9%8C/" rel="alternate" type="text/html" title="왜 개발자들은 OAuth와 OpenID Connect를 헷갈릴까?"/><published>2025-08-05T00:00:00+00:00</published><updated>2025-08-05T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/%EC%99%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%80-OAuth%EC%99%80-OpenID-Connect%EB%A5%BC-%ED%97%B7%EA%B0%88%EB%A6%B4%EA%B9%8C</id><content type="html" xml:base="https://hwangrolee.github.io/blog/%EC%99%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%80-OAuth%EC%99%80-OpenID-Connect%EB%A5%BC-%ED%97%B7%EA%B0%88%EB%A6%B4%EA%B9%8C/"><![CDATA[<blockquote> <p>“구글 로그인은 OAuth 2.0으로 만들었어요.”</p> <p>“카카오 로그인은 OAuth API 써서 붙였어요.”</p> </blockquote> <p>많은 개발자들이 ‘소셜 로그인 = OAuth 2.0’ 이라고 이야기합니다. 하지만 사실 소셜 로그인은 OAuth가 아니라 OpenID Connect(OIDC) 덕분에 가능한 기능입니다.</p> <p>이 글에서는 개발자들이 OAuth와 OIDC를 혼용하는 이유와 왜 구글/카카오 로그인은 OIDC라고 말해야 하는지를 정리해봅니다.</p> <h2 id="oauth-20과-openid-connectoidc는-뭐가-다를까">OAuth 2.0과 OpenID Connect(OIDC)는 뭐가 다를까?</h2> <h3 id="oauth-20">OAuth 2.0</h3> <ul> <li>목적: 권한 위임(Authorization)</li> <li>예: “내 구글 드라이브 파일에 접근할 수 있는 권한을 앱에 줄게”</li> </ul> <h2 id="openid-connect-oidc">OpenID Connect (OIDC)</h2> <ul> <li>목적: 인증(Authentication)</li> <li>OAuth 2.0 기반 프로토콜 + ID Token 개념 추가</li> <li>예: “이 사용자가 ‘홍길동’인지 확인하고 로그인 처리해줘”</li> <li>정리하면 OAuth는 ‘무엇을 할 수 있는지’, OIDC는 ‘누구인지’ 를 해결하는 프로토콜입니다.</li> </ul> <h2 id="개발자들이-혼용하는-대표-케이스">개발자들이 혼용하는 대표 케이스</h2> <blockquote> <p>“구글 로그인은 OAuth 2.0을 사용했다.”</p> </blockquote> <p>왜 혼동될까? 구글 개발자 문서에 ‘Google OAuth 2.0’이라고 적혀 있어서. 실제 구현도 OAuth Authorization Code Flow를 사용하기 때문.</p> <h3 id="정확한-설명">정확한 설명</h3> <ul> <li>구글 API 호출 -&gt; OAuth</li> <li>구글 로그인 -&gt; OpenID Connect</li> <li>구글 로그인을 구현했다면 “OIDC를 사용했다”고 말하는 게 정확합니다.</li> <li>“OAuth로 로그인 기능을 만들었다.”</li> </ul> <h3 id="oauth-flow를-사용하니까-로그인도-oauth로-가능하다고-착각">OAuth Flow를 사용하니까 로그인도 OAuth로 가능하다고 착각.</h3> <ul> <li>OAuth는 권한 위임만 담당합니다.</li> <li>로그인 기능을 가능하게 해주는 건 OIDC에서 발급하는 ID Token 덕분입니다.</li> <li>OAuth만 쓰면 사용자 ‘신원’은 확인할 수 없습니다.</li> <li>“ID Token도 Access Token 중 하나다.”</li> </ul> <h3 id="왜-혼동될까-둘-다-토큰이니까-같은-개념이라고-생각">왜 혼동될까? 둘 다 ‘토큰’이니까 같은 개념이라고 생각.</h3> <ul> <li>JWT 구조도 비슷해서 더 헷갈립니다.</li> <li>Access Token -&gt; API 자원 접근 용도</li> <li>ID Token -&gt; 로그인 인증 용도 (이메일, 이름, 사용자 ID 포함)</li> </ul> <h3 id="그렇다면-구글카카오-로그인은-oauth일까-oidc일까">그렇다면, 구글/카카오 로그인은 OAuth일까 OIDC일까?</h3> <ul> <li>정확히 말하면 -&gt; OIDC를 활용한 것입니다.</li> <li>OAuth 2.0 -&gt; 권한 위임 (예: 내 구글 드라이브 파일 접근 허용)</li> <li>OpenID Connect(OIDC) -&gt; OAuth 2.0 기반 + “사용자 인증(로그인)” 기능 추가</li> </ul> <p>구글 로그인 / 카카오 로그인은 “로그인(= 인증)”이 목적이라 OIDC를 사용했다고 해야 정확합니다.</p> <h3 id="면접이나-블로그에서-이렇게-설명할-수-있습니다">면접이나 블로그에서 이렇게 설명할 수 있습니다</h3> <p>구글, 카카오 로그인 기능을 내 서비스에 붙일 때 OAuth 2.0 Flow(Authorization Code)를 사용하긴 했지만, 실제로 로그인 기능을 가능하게 한 건 OpenID Connect(OIDC)입니다.</p> <p>OAuth만 쓰면 단순 권한 위임만 가능하지만, OIDC는 ID Token을 통해 사용자 정보를 확인할 수 있기 때문에 로그인 구현이 가능합니다.</p> <h2 id="결론-이렇게-기억하면-안-헷갈림">결론: 이렇게 기억하면 안 헷갈림</h2> <ul> <li>OAuth 2.0 -&gt; 권한 위임 (내 API를 대신 호출하게 권한 줌)</li> <li>OIDC -&gt; OAuth 2.0 + 로그인 기능 (이 사용자가 누구인지 알려줌)</li> </ul> <h2 id="마무리">마무리</h2> <p>다음에 누군가 “구글 로그인은 OAuth로 만들었어?” 라고 물으면</p> <blockquote> <p>“정확히는 OAuth 위에 인증 기능을 추가한 OpenID Connect로 구현했어”</p> </blockquote> <p>라고 말해보세요. OAuth는 ‘무엇을 할 수 있나’, OIDC는 ‘누구인가’. 이 한 줄만 기억하면 더 이상 헷갈리지 않을 겁니다.</p>]]></content><author><name></name></author><category term="인증/인가"/><category term="OAuth,"/><category term="OIDC,"/><category term="OpenID"/><category term="Connect,"/><category term="소셜로그인,"/><category term="Authentication,"/><category term="Authorization"/><summary type="html"><![CDATA[개발자들이 흔히 혼동하는 OAuth 2.0과 OpenID Connect(OIDC)의 차이점을 명확히 설명합니다. 소셜 로그인이 OAuth가 아닌 OIDC인 이유, 인증(Authentication)과 권한 위임(Authorization)의 핵심 개념을 알아보고 정확한 기술 용어를 사용하세요.]]></summary></entry><entry><title type="html">DB 락(Database Lock) 완벽 이해하기 - 개발자라면 꼭 알아야 할 개념</title><link href="https://hwangrolee.github.io/blog/DB-%EB%9D%BD(Database-Lock)-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%EA%B0%9C%EB%85%90/" rel="alternate" type="text/html" title="DB 락(Database Lock) 완벽 이해하기 - 개발자라면 꼭 알아야 할 개념"/><published>2025-08-02T00:00:00+00:00</published><updated>2025-08-02T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/DB-%EB%9D%BD(Database-Lock)-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%EA%B0%9C%EB%85%90</id><content type="html" xml:base="https://hwangrolee.github.io/blog/DB-%EB%9D%BD(Database-Lock)-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%EA%B0%9C%EB%85%90/"><![CDATA[<blockquote> <p>“은행 계좌에서 돈을 빼는데, 둘이 동시에 빼면 어떻게 될까?”</p> </blockquote> <p>개발을 하다 보면 동시에 같은 데이터를 읽고, 수정하고, 삭제하는 상황을 피할 수 없습니다.  예를 들어, A와 B가 같은 은행 계좌에서 돈을 동시에 인출하려 한다고 해봅시다.</p> <ul> <li>A가 5만 원을 빼려는 순간 잔액: 10만 원</li> <li>B도 같은 순간 5만 원을 빼려는 요청을 보냄</li> <li>A와 B 모두 잔액 10만 원을 보고 인출 → 최종 잔액이 0원이 아닌 5만 원이 되어버림!</li> </ul> <p>데이터 무결성(Data Integrity) 이 깨집니다.</p> <p>이 문제를 해결하는 핵심 개념이 바로 DB 락(Database Lock) 입니다.</p> <h2 id="db-락이란">DB 락이란?</h2> <blockquote> <p>“여러 명이 동시에 같은 데이터를 건드릴 때, 꼬이지 않도록 잠시 잠가두는 안전장치”</p> </blockquote> <p>데이터베이스는 다중 사용자가 접근하는 시스템이기 때문에, 한 사용자가 데이터를 읽거나 수정하는 동안 다른 사용자의 작업을 잠시 막는 방법이 필요합니다.</p> <p><strong>그게 바로 락(Lock) 이죠.</strong></p> <p>왜 락이 필요할까? (은행 계좌 예시)</p> <ul> <li>A: “내 계좌에서 5만 원 인출할게”</li> <li>B: “나도 5만 원 인출할래”</li> </ul> <p>DB가 락을 걸지 않으면, A와 B가 동시에 잔액을 조회(10만 원) → 각자 5만 원 빼서 저장 → 최종 잔액이 5만 원이 남아버리는 문제가 생깁니다.</p> <p>하지만 DB가 ‘잠깐! A 먼저 끝낼 때까지 기다려!’ 하고 락을 건다면? ➡ A의 작업이 끝나고 나서야 B가 처리되므로 정확한 결과(잔액 0원) 가 유지됩니다.</p> <hr/> <h2 id="db-락의-두-가지철학">DB 락의 두 가지 철학</h2> <p>DB 락에는 두 가지 방식이 있습니다.</p> <p><strong>1. 낙관적 락 (Optimistic Lock)</strong></p> <p>“동시에 접근해도 괜찮겠지? 근데 마지막에 확인은 해볼게.”</p> <ul> <li>데이터를 읽을 때 락을 걸지 않음</li> <li>대신 버전(version) 필드를 두고, 커밋(저장)할 때 변경 여부 확인</li> <li>누군가 먼저 수정했다면 에러(충돌) 발생 → 다시 시도해야 함</li> </ul> <p><strong>예시</strong></p> <ul> <li>게시글 좋아요 수 같은 기능 → 여러 명이 동시에 눌러도 조금 늦게 업데이트되면 괜찮음</li> </ul> <p><strong>비유</strong></p> <ul> <li>“책을 빌릴 때 자물쇠 안 걸고 그냥 빌려줌. 나중에 반납할 때 ‘책이 다른 사람에 의해 수정됐나?’ 확인 후 충돌 시 다시 처리”</li> </ul> <p><strong>장점</strong>: 락을 거의 안 걸기 때문에 성능이 좋음</p> <p><strong>단점</strong>: 저장할 때 충돌 나면 재시도 로직 필요</p> <p><strong>2. 비관적 락 (Pessimistic Lock)</strong></p> <p>“혹시 모르니 내가 끝날 때까지 아무도 건들지 마!”</p> <ul> <li>데이터를 읽는 순간부터 DB가 잠금 걸기</li> <li>다른 트랜잭션은 읽기/쓰기 모두 대기 상태 (잠금 해제될 때까지 기다림)</li> <li>SQL에서는 <code class="language-plaintext highlighter-rouge">SELECT FOR UPDATE</code> 로 구현</li> </ul> <p><strong>예시</strong></p> <ul> <li>은행 계좌, 항공권 좌석, 콘서트 티켓 → 절대 꼬이면 안 되는 데이터</li> </ul> <p><strong>비유</strong></p> <ul> <li>“내가 책 빌리면 사서가 ‘이 책은 지금 대출 중이니 건들지 마세요’라고 딱지 붙임”</li> </ul> <p>장점: 충돌이 거의 없음 (안전성 최고)</p> <p>단점: 락이 오래 걸리면 다른 사용자가 기다려야 함 → 성능 저하 가능</p> <hr/> <h2 id="db-락의-동작방식">DB 락의 동작 방식</h2> <p>DB 락은 트랜잭션(Transaction) 단위로 동작합니다.</p> <ol> <li>트랜잭션 시작</li> <li>데이터를 읽으면서 락을 걸기 (비관적 락의 경우)</li> <li>수정 후 커밋</li> <li>커밋이 완료되면 락 해제</li> </ol> <p>그래서 락을 쓸 때는 트랜잭션을 짧게 유지하는 게 중요합니다.</p> <hr/> <h2 id="언제-어떤-락을-써야할까">언제 어떤 락을 써야 할까?</h2> <p><strong>낙관적 락 (Optimistic Lock)</strong></p> <ul> <li>동시성이 많지만 충돌 가능성은 적을 때</li> <li>예: 게시글 좋아요 수, 상품 조회수, 포인트 적립</li> </ul> <p><strong>비관적 락 (Pessimistic Lock)</strong></p> <ul> <li>꼬이면 절대 안 되는 핵심 로직</li> <li>예: 은행 계좌 잔액 변경, 티켓 좌석 예매, 창고 재고 처리</li> </ul> <hr/> <h2 id="spring에서-db-락-쓰는법">Spring에서 DB 락 쓰는 법</h2> <p>Spring Data JPA에서는 @Lock 어노테이션으로 쉽게 DB 락을 사용할 수 있습니다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AccountRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Account</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nd">@Lock</span><span class="o">(</span><span class="nc">LockModeType</span><span class="o">.</span><span class="na">PESSIMISTIC_WRITE</span><span class="o">)</span> <span class="c1">// 비관적 락</span>
    <span class="nd">@Query</span><span class="o">(</span><span class="s">"SELECT a FROM Account a WHERE a.id = :id"</span><span class="o">)</span>
    <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Account</span><span class="o">&gt;</span> <span class="nf">findByIdForUpdate</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="마무리">마무리</h2> <p>DB 락은 동시성 문제를 해결하는 가장 기본적인 도구입니다.</p> <ul> <li>낙관적 락(Optimistic) -&gt; “충돌 안 나겠지? 근데 저장할 때 체크는 할게”</li> <li>비관적 락(Pessimistic) -&gt; “내가 끝날 때까지 아무도 건들지 마!”</li> </ul> <p>그리고 락을 쓸 땐 트랜잭션 길이를 최대한 짧게 유지하는 게 핵심!</p> <p>락을 오래 잡아두면 다른 작업이 모두 기다리기 때문에 시스템 전체 성능이 떨어질 수 있습니다.</p>]]></content><author><name></name></author><category term="Database"/><category term="MySQL,"/><category term="SQL,"/><category term="Lock,"/><category term="동시성,"/><category term="트랜잭션"/><summary type="html"><![CDATA[개발자 필수 개념 DB 락(Database Lock) 완벽 가이드. 동시성 문제 해결을 위한 낙관적 락과 비관적 락의 차이, 사용 사례, Spring Data JPA 적용법까지 쉽게 설명합니다. 데이터 무결성을 지키는 핵심 원리를 지금 확인하세요.]]></summary></entry><entry><title type="html">비관적 락(Pessimistic Lock), 진짜 뭔지 아세요? - 개발자가 궁금해할 질문 7가지로 정리</title><link href="https://hwangrolee.github.io/blog/%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BD(Pessimistic-Lock)-%EC%A7%84%EC%A7%9C-%EB%AD%94%EC%A7%80-%EC%95%84%EC%84%B8%EC%9A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EA%B6%81%EA%B8%88%ED%95%B4%ED%95%A0-%EC%A7%88%EB%AC%B8-7%EA%B0%80%EC%A7%80%EB%A1%9C-%EC%A0%95%EB%A6%AC/" rel="alternate" type="text/html" title="비관적 락(Pessimistic Lock), 진짜 뭔지 아세요? - 개발자가 궁금해할 질문 7가지로 정리"/><published>2025-08-02T00:00:00+00:00</published><updated>2025-08-02T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BD(Pessimistic-Lock)-%EC%A7%84%EC%A7%9C-%EB%AD%94%EC%A7%80-%EC%95%84%EC%84%B8%EC%9A%94?%E2%80%8A-%E2%80%8A%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EA%B6%81%EA%B8%88%ED%95%B4%ED%95%A0-%EC%A7%88%EB%AC%B8-7%EA%B0%80%EC%A7%80%EB%A1%9C-%EC%A0%95%EB%A6%AC</id><content type="html" xml:base="https://hwangrolee.github.io/blog/%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BD(Pessimistic-Lock)-%EC%A7%84%EC%A7%9C-%EB%AD%94%EC%A7%80-%EC%95%84%EC%84%B8%EC%9A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EA%B6%81%EA%B8%88%ED%95%B4%ED%95%A0-%EC%A7%88%EB%AC%B8-7%EA%B0%80%EC%A7%80%EB%A1%9C-%EC%A0%95%EB%A6%AC/"><![CDATA[<h3 id="비관적-락에-대한-7가지궁금증">비관적 락에 대한 7가지 궁금증</h3> <p><strong>Q1. 비관적 락은 왜 ‘비관적’이라고 부르나요?</strong></p> <ul> <li>“언젠가 누군가 같은 데이터를 건드릴 거라고 ‘비관적으로’ 생각하기 때문”</li> <li>읽거나 수정하기 전에 바로 락을 걸어버림</li> <li>즉, 동시에 접근하면 안 된다고 미리 가정하는 방식</li> </ul> <p><strong>Q2. 비관적 락을 걸면 DB는 어떻게 동작하나요?</strong></p> <ul> <li>Spring Data JPA → @Lock(LockModeType.PESSIMISTIC_WRITE)</li> <li>DB → SELECT … FOR UPDATE 쿼리 실행</li> <li>DB는 조회된 row(행)에 락을 걸어, 트랜잭션이 끝날 때까지 대기 상태로 만듦</li> <li>MySQL(InnoDB) / Oracle / PostgreSQL 등 대부분 DB에서 동일 개념 적용</li> </ul> <p><strong>Q3. 비관적 락은 “row-level lock”인가요, “table-level lock”인가요?</strong></p> <ul> <li>기본은 row-level lock (행 단위 잠금)</li> <li>WHERE id = ? 처럼 명확히 특정 행을 조회하면 해당 행만 잠김</li> <li>하지만 조건이 모호하거나 인덱스가 없으면 DB는 더 넓은 범위를 잠글 수 있음</li> <li>MySQL → Gap Lock / Next-Key Lock 발생 (범위 락)</li> <li>Oracle → Row-level 락이지만 쿼리에 따라 table-level 락으로 확대 가능성 있음</li> <li>실무에서는 PK(기본키) 조회로 비관적 락을 거는 게 안전하다!</li> </ul> <p><strong>Q4. 비관적 락을 걸면 언제까지 락이 유지되나요?</strong></p> <ul> <li>트랜잭션이 끝날 때까지 유지</li> <li>커밋(COMMIT) 또는 롤백(ROLLBACK) 시 해제됨</li> <li>트랜잭션을 길게 잡으면 락도 오래 유지 → 다른 요청들 대기 → 성능 병목</li> </ul> <p><strong>Q5. 비관적 락을 쓰면 성능은 얼마나 떨어지나요?</strong></p> <ul> <li>DB가 동시에 처리할 수 있는 요청을 줄여버림 → 동시성(Concurrency)↓</li> <li>트랜잭션이 길거나락 걸리는 데이터가 많을수록</li> <li>다른 요청이 줄줄이 대기 (Deadlock 가능성도↑)</li> <li>“락을 꼭 필요한 최소 구간에서만” 사용해야 함</li> </ul> <p><strong>Q6. 그럼 멀티 서버 환경에서는 어떻게 되나요?</strong></p> <ul> <li>비관적 락은 DB 차원에서 락을 거는 것이라 서버가 여러 대여도 안전</li> <li>서버 A에서 SELECT FOR UPDATE로 row 잠그면, 서버 B도 DB에서 대기</li> <li>JVM 단위 synchronized 같은 건 멀티 서버에선 소용없지만, DB 락은 글로벌</li> </ul> <p><strong>Q7. 비관적 락을 꼭 써야 하는 상황은?</strong></p> <ul> <li>꼬이면 절대 안 되는 비즈니스 로직</li> <li>은행 계좌 잔액 차감</li> <li>좌석 예약 / 티켓 예매</li> <li>재고 감소 처리</li> <li>충돌 가능성이 높을 때 (낙관적 락은 충돌 났을 때 재시도가 필요하니까)</li> <li>단, 트래픽이 매우 많고 대기 시간이 길어질 수 있다면 Redis 분산 락이나 메시지 큐로 아키텍처 확장 고려</li> </ul> <h3 id="마무리-conclusion">마무리 (Conclusion)</h3> <p><strong>비관적 락 핵심 요약</strong></p> <ul> <li>“읽기 전에 잠금 → 트랜잭션 끝날 때까지 유지”</li> <li>“조회한 행(row)만 잠그지만, 조건이 모호하면 더 넓게 잠글 수도 있음”</li> <li>“멀티 서버 환경에서도 안전”</li> </ul> <p><strong>실무 팁</strong></p> <ul> <li>PK 기반 조회로 락을 거는 습관</li> <li>트랜잭션 길이는 최소화</li> <li>대규모 트래픽 → Redis 분산 락 or MQ 검토</li> </ul>]]></content><author><name></name></author><category term="Database"/><category term="MySQL,"/><category term="SQL,"/><category term="Lock,"/><category term="동시성,"/><category term="트랜잭션"/><summary type="html"><![CDATA[비관적 락(Pessimistic Lock)이란 무엇일까요? 'SELECT FOR UPDATE'의 동작 원리부터 성능 저하 문제, 멀티 서버 환경에서의 동작 방식, 실무 사용 팁까지 개발자가 꼭 알아야 할 7가지 핵심 질문으로 동시성 제어의 모든 것을 완벽하게 정리합니다.]]></summary></entry><entry><title type="html">MySQL 실시간 쿼리 확인하기</title><link href="https://hwangrolee.github.io/blog/MySQL-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%BF%BC%EB%A6%AC-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="MySQL 실시간 쿼리 확인하기"/><published>2025-03-08T00:00:00+00:00</published><updated>2025-03-08T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/MySQL-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%BF%BC%EB%A6%AC-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/MySQL-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%BF%BC%EB%A6%AC-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/"><![CDATA[<h1 id="mysql에서-락-문제-해결-및-관리-방법">MySQL에서 락 문제 해결 및 관리 방법</h1> <p>많은 서비스에서 MySQL을 메인 데이터베이스로 사용하여 서비스를 개발하고 있습니다. MySQL은 RDBMS로서 <strong>Transaction</strong> 단위로 쿼리를 실행하게 되며, <strong>ACID</strong> 특성에 의해 데이터의 신뢰성을 보장합니다. 하지만, 트랜잭션에 의해 락이 발생하고, 락에 의해 쿼리 지연이 발생하면서 서비스 장애를 초래할 수 있습니다. 이번 글에서는 MySQL에서 발생할 수 있는 락 문제를 어떻게 해결할 수 있는지에 대해 살펴보겠습니다.</p> <h2 id="락-발생-원인">락 발생 원인</h2> <h3 id="1-트랜잭션에-의한-락">1. 트랜잭션에 의한 락</h3> <p>MySQL에서 트랜잭션은 <strong>ACID</strong> 특성(Atomicity, Consistency, Isolation, Durability)을 보장하기 위해 실행됩니다. 하지만, 트랜잭션이 실행되는 동안 <strong>락</strong>이 발생하게 되어 다른 트랜잭션이 대기 상태로 들어갑니다. 이로 인해 쿼리 지연이 발생하고, 서비스 장애를 초래할 수 있습니다.</p> <h3 id="2-ddl-명령어에-의한-락">2. DDL 명령어에 의한 락</h3> <p><strong>DDL(Data Definition Language)</strong> 명령어(예: <code class="language-plaintext highlighter-rouge">ALTER</code>, <code class="language-plaintext highlighter-rouge">DROP</code>, <code class="language-plaintext highlighter-rouge">CREATE</code>)는 테이블이나 데이터베이스 구조를 변경합니다. 이러한 명령어는 해당 테이블에 <strong>테이블 락</strong>을 걸어 다른 트랜잭션이 해당 테이블을 수정하는 것을 차단하게 됩니다. 이로 인해 서비스 지연이 발생할 수 있으므로 DDL 실행 시 특별한 주의가 필요합니다.</p> <h2 id="락-문제-해결-방법">락 문제 해결 방법</h2> <h3 id="1-현재-실행-중인-쿼리-모니터링">1. 현재 실행 중인 쿼리 모니터링</h3> <p>쿼리 락이나 DDL 명령어 실행에 의해 락이 발생하면, 해당 락을 유발하는 쿼리를 찾아서 중단시켜야 합니다. 이를 위해 <code class="language-plaintext highlighter-rouge">information_schema.INNODB_TRX</code>를 사용하여 현재 실행 중인 트랜잭션을 모니터링할 수 있습니다. 다음 쿼리를 통해 현재 실행 중인 트랜잭션과 관련된 정보를 확인할 수 있습니다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_id</span><span class="p">,</span>
       <span class="n">aa</span><span class="p">.</span><span class="n">trx_mysql_thread_id</span><span class="p">,</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_state</span><span class="p">,</span>
       <span class="n">bb</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="k">user</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="k">host</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="n">db</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="n">command</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="nb">time</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="k">state</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="n">info</span><span class="p">,</span>
       <span class="n">aa</span><span class="p">.</span><span class="n">trx_started</span><span class="p">,</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_requested_lock_id</span><span class="p">,</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_wait_started</span><span class="p">,</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_weight</span>
<span class="k">FROM</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">INNODB_TRX</span> <span class="n">aa</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">PROCESSLIST</span> <span class="n">bb</span>
    <span class="k">ON</span> <span class="p">(</span><span class="n">bb</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_mysql_thread_id</span><span class="p">)</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_state</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="nb">time</span> <span class="k">DESC</span><span class="p">;</span>
</code></pre></div></div> <p>위 쿼리를 통해 현재 실행 중인 트랜잭션과 관련된 정보를 확인할 수 있습니다. 만약 락을 유발하는 쿼리를 발견하면, KILL 명령어를 통해 해당 쿼리를 중단시킬 수 있습니다.</p> <h3 id="2-락을-유발하는-쿼리-중단">2. 락을 유발하는 쿼리 중단</h3> <p>락을 유발하는 쿼리를 찾아 중지시켜야 합니다. 위에서 제공된 쿼리로 확인한 후, 락을 발생시키는 트랜잭션을 KILL 명령어로 종료합니다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">KILL</span> <span class="p">[</span><span class="n">trx_mysql_thread_id</span><span class="p">];</span>
</code></pre></div></div> <p>이 명령어를 통해 해당 트랜잭션을 강제로 종료시킬 수 있습니다. 이 과정은 락이 발생하여 서비스에 영향을 미치고 있을 때 빠르게 대응할 수 있도록 도와줍니다.</p> <h2 id="락-예방을-위한-best-practices">락 예방을 위한 Best Practices</h2> <h3 id="1-ddl-및-dml-명령어-실행-전-사이드-이펙트-고려">1. DDL 및 DML 명령어 실행 전 사이드 이펙트 고려</h3> <p>DDL 및 DML 명령어를 실행하기 전에 해당 명령어가 락을 발생시킬 수 있는지 여부를 충분히 고려해야 합니다. 이를 통해 락 발생 가능성을 미리 예측하고, 서비스에 미치는 영향을 최소화할 수 있습니다.</p> <h3 id="2-ddl-및-dml-명령어-실행-후-락-모니터링">2. DDL 및 DML 명령어 실행 후 락 모니터링</h3> <p>DDL 및 DML 명령어 실행 후에는 information_schema.INNODB_TRX를 사용하여 현재 실행 중인 쿼리를 모니터링해야 합니다. 쿼리가 밀리는 현상이 발생하면 즉시 락을 유발한 쿼리를 중단하여 서비스 장애를 예방할 수 있습니다.</p> <h3 id="3-트랜잭션-최적화">3. 트랜잭션 최적화</h3> <p>트랜잭션을 가능한 한 작은 범위로 만들어 락의 지속 시간을 줄여야 합니다. 불필요한 쿼리를 실행하지 않도록 하여 락이 필요한 시간을 최소화하고, 트랜잭션 격리 수준을 적절히 설정해 락 경합을 줄일 수 있습니다.</p> <h3 id="4-락-모니터링-도구-사용">4. 락 모니터링 도구 사용</h3> <p>MySQL의 성능 스키마나 MySQL Enterprise Monitor와 같은 도구를 활용하여 실시간으로 락 문제를 모니터링할 수 있습니다. 문제 발생 시 자동으로 알림을 받아 대응할 수 있습니다.</p> <h2 id="결론">결론</h2> <p>MySQL에서 락을 관리하는 것은 서비스의 성능과 안정성에 중요한 영향을 미칩니다. 트랜잭션을 최적화하고, DDL 명령어 실행 시 주의를 기울이며, 락 모니터링을 통해 실시간으로 문제를 해결할 수 있어야 합니다. 이러한 관리 방법을 통해 서비스 장애를 예방하고, 데이터베이스의 성능을 최적화할 수 있습니다.</p>]]></content><author><name></name></author><category term="MySQL,"/><category term="Database"/><category term="MySQL,"/><category term="데이터베이스,"/><category term="Database,"/><category term="쿼리,"/><category term="SQL"/><summary type="html"><![CDATA[MySQL에서 발생하는 락 문제를 해결하는 방법과 락을 유발하는 쿼리를 찾아 종료하는 절차를 설명합니다. 트랜잭션, DDL, DML 명령어의 락 사이드 이펙트를 고려하여 서비스 장애를 예방하고, 락을 관리하는 방법을 소개합니다.]]></summary></entry><entry><title type="html">백엔드 개발자가 리액트 네이티브로 달력 앱을 배포해보았습니다.</title><link href="https://hwangrolee.github.io/blog/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C%EB%A1%9C-%EB%8B%AC%EB%A0%A5-%EC%95%B1%EC%9D%84-%EB%B0%B0%ED%8F%AC%ED%95%B4%EB%B3%B4%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/" rel="alternate" type="text/html" title="백엔드 개발자가 리액트 네이티브로 달력 앱을 배포해보았습니다."/><published>2025-03-08T00:00:00+00:00</published><updated>2025-03-08T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80%20%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C%EB%A1%9C-%EB%8B%AC%EB%A0%A5-%EC%95%B1%EC%9D%84-%EB%B0%B0%ED%8F%AC%ED%95%B4%EB%B3%B4%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4</id><content type="html" xml:base="https://hwangrolee.github.io/blog/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C%EB%A1%9C-%EB%8B%AC%EB%A0%A5-%EC%95%B1%EC%9D%84-%EB%B0%B0%ED%8F%AC%ED%95%B4%EB%B3%B4%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/"><![CDATA[<p>저는 2016년부터 꾸준히 백엔드 개발을 해왔습니다. 백엔드 개발하면서 백오피스개발도 해왔기에 기본적인 프론트엔드 개발 기술은 알고 있는 상태였습니다. 웹 프론트엔드 기술 중 바닐라, 리액트, Nextjs, Angularjs 를 활용해서 웹 프론트엔드를 개발해왔지만 앱을 만들어 본적은 없었어요.</p> <p>퇴근 회사를 퇴사하면서 이번에 앱을 만들어 보고자 크로스 플랫폼에 대해서 공부했습니다.</p> <h3 id="리액트-네이티브-vs-플러터">리액트 네이티브 vs 플러터</h3> <p>빠르고 간단하게 앱을 만들고 싶었기에 당연하게 크로스 플랫폼 기반으로 앱을 만들기로 정했습니다. 그리고 리액트 네이티브와 플러터를 비교해보았고 저는 <em>리액트 네이티브</em> 를 선택했습니다.</p> <p>제가 리액트 네이티브를 선택한 이유는…</p> <p><strong>1. 자바스크립트(타입스크립트)로 개발이 가능합니다.</strong></p> <p>자바스크립트로 개발을 할 수 있다는 것은 굉장히 큰 메리트였습니다. 웹 프론트엔드 개발 경험이 있어서 자바스크립트에 대해서는 크게 불편함이 없었기에 언어에 대한 허들이 낮았기에 쉽게 접근 할 수 있을 거라 생각 했습니다. 그리고 플러터를 개발하기 위해 Dart(다트) 언어를 공부해도 되지만 제가 다시 앱을 만들지 않는 이상 Dart 언어를 사용할 일은 없을 거라 아마 다시 까먹게 될 언어라고 생각했습니다.</p> <p><strong>2. 프레임워크 생태계가 리액트 네이티브가 더 커요.</strong></p> <p>리액트 네이티브는 리액트 기반이기 때문에 플러터보다 먼저 오픈소스 생태계가 활성화 되어 있었기 때문에 구글링으로 빠르게 이슈를 해결할 수 있을 거라 생각했습니다. 앱 개발에 있어서 이슈 해결을 위한 프레임워크 생태계는 생각보다 많이 중요하기 때문입니다.</p> <p><strong>3. 플러터의 장점이 저에게 있어선 큰 장점이 아니었어요.</strong></p> <p>플러터가 리액트 네이티브보다 성능면에서 좋다고 합니다. 제가 플러터를 경험해보지 않았고 직접 경험해보지 않았지만 확실히 성능 측면에서는 차이가 있다고 해서 조금 고민을 했습니다. 하지만 제가 만들 달력 앱은 간단한 앱이기 때문에 애니메이션, 렌더링, 데이터 처리 등등 성능 측면에서 큰 문제가 되지 않을 거라 생각했습니다. 만약 성능 측면에서 많이 고려해야하는 앱을 만들 예정이었다면 플러터를 고려하지 않았을까 생각됩니다.</p> <p>위 3가지의 이유로 리액트 네이티브를 선택하였고 개발을 시작했죠.</p> <h3 id="라이브러리-선택의-갈림길">라이브러리 선택의 갈림길</h3> <p>개발은 생각보다 순조로웠고 어렵다는 생각이 들지 않았습니다.</p> <p><strong>1. 상태 관리 라이브러리는 무엇을 맞을까? (Redux vs Recoil)</strong></p> <p>과거 리액트 시장에서는 상태 관리 라이브러리는 당연히 Redux 였습니다. 하지만 몇 년전 recoil 이라는 새로운 라이브러리를 리액트에서 만들었고 많이 사용되고 있죠. Redux 는 과거부터 사용해왔기에 당연히 생태계와 안정성은 많은 사람들에게 인정받아왔고 지금이 많이 활용되고 있습니다. 하지만 저는 Recoil 을 사용하기로 했습니다. 이유는 상태 관리가 그렇게 복잡하지 않을 뿐더러 복잡하더라도 Redux 보다는 리액트에서 직접 만든 Recoil 이 저에게 있어서 좀 더 신뢰도가 높기 때문입니다. 사용성도 편한 것 같고..</p> <p><strong>2. 스타일링 라이브러리는 무엇이 좋을까?(Styled Component VS Style Sheet)</strong></p> <p>처음 개발 시작 할 때에는 Style Sheet 를 사용했어요. 테마 기능을 넣으려고 보니 Style Sheet 로는 한계점이 보였고 과감하게 Styled Component 로 옮겼습니다. 테마 관리에 있어서는 Styled Component 가 훨씬 편하기 때문입니다.</p> <p>프레임워크 생태계가 방대하다는 것은 다양한 라이브러리가 존재하고 개발자 취향에 따라 원하는 라이브러리를 선택할 수 있다는 점이지만 때로는 선택을 하는데 너무 많은 시간을 소비해야하는 단점이 있는 것 같네요.</p> <h3 id="피그마로-앱-아이콘-앱-소개-이미지를-만들어-보았어요">피그마로 앱 아이콘, 앱 소개 이미지를 만들어 보았어요.</h3> <p>달력앱을 만드는 것은 어렵지 않았어요. 오히려 기본 기능을 개발 후 배포하는 것이 더 어렵고 힘든 작업이었습니다. 혼자서 하려니 생각할 것이 너무나 많았습니다.</p> <p>디자이너가 만든 피그마를 확인해서 개발한 적은 있지만 직접 피그마로 디자인해보는 건 처음 이었어요. 다행히 피그마에는 앱 아이콘, 앱 소개 이미지를 위한 다양한 템플릿이 있었고 이것 저것 사용해보다가 초보인 제가 사용하기 쉬운 템플릿으로 앱 아이콘과 앱 소개 이미지를 제작했습니다.</p> <ul> <li><a href="https://www.figma.com/design/6VPVTMzVb65jwiyOQhIKLC/App-Icon-Toolkit---iOS%2FmacOS%2FAndroid-(Community)?m=auto&amp;t=8rs8r8NsRwi6oqMx-6">앱 아이콘 템플릿</a></li> <li><a href="https://www.figma.com/design/P9dmo9eVszzV8Ej0HXXsNI/App-Store-Screenshot-Template-(Community)?m=auto&amp;t=MNR6nfA6x2cdmcr5-6">앱 이미지 템플릿</a></li> </ul> <h3 id="앱-노출-극대화를-위한-키워드-리서치-앱-소개글-작성하기">앱 노출 극대화를 위한 키워드 리서치, 앱 소개글 작성하기</h3> <p>흔히 ASO 라고 해서 앱 스토어에서 앱 노출 극대화를 위해 키워드 리서치를 합니다. 키워드 리서치할 때 많이 사용하는 툴은 드래곤 메트릭스와 같은 툴을 많이 사용하지만 저는 ChatGPT 를 사용했어요 귀찮…</p> <h3 id="결론">결론</h3> <p>백엔드 개발자인 제가 앱을 배포해본다는 것은 좋은 경험이었고 저와 같이 일하는 다른 팀원분들의 고충도 이해하게 되었습니다.</p>]]></content><author><name></name></author><category term="React"/><category term="Native"/><category term="리액트네이티브,달력앱"/><summary type="html"><![CDATA[백엔드 개발자가 리액트 네이티브를 활용해 첫 앱을 배포한 경험을 공유합니다. 리액트 네이티브 vs 플러터 비교, 상태 관리, 스타일링, ASO 키워드 리서치까지!]]></summary></entry><entry><title type="html">MySQL 트랜잭션 격리수준 Isolation level 알아보기</title><link href="https://hwangrolee.github.io/blog/MySQL-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80-Isolation-level-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/" rel="alternate" type="text/html" title="MySQL 트랜잭션 격리수준 Isolation level 알아보기"/><published>2024-12-15T00:00:00+00:00</published><updated>2024-12-15T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/MySQL-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80-Isolation-level-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/MySQL-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80-Isolation-level-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/"><![CDATA[<p>트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 다른 트랜잭션에서 변경이 일어났을 때 해당 데이터를 또 다른 트랜잭션에서 조회가 가능하게 할지를 허용할지 말지를 결정하는 것이다. 격리 수준에는 총 4개가 있다.</p> <ul> <li>READ UNCOMMITTED</li> <li>READ COMMITTED</li> <li>REPEATABLE READ</li> <li>SERIALIZABLE 위 4개 중 첫번째인 READ UNCOMMITTED는 격리수준이 가장 낮고 SERIALIZABLE 은 격리 수준이 가장 높다.</li> </ul> <h2 id="1-read-uncommitted">1. READ UNCOMMITTED</h2> <p>트랜잭션 격리수준 중 가장 낮은 단계로 성능이 가장 좋지만 다른 트랜잭션에서 커밋되지 않은 데이터를 읽어 올 수 있기 때문에 잘 못 사용할 경우 데이터 정합성에 큰 이슈가 발생 할 수 있다.</p> <p>Transaction_A 에서 INSERT, UPDATE, DELETE 쿼리를 실행 후 아직 커밋하지 않았지만 Transaction_B 에서 SELECT 쿼리를 실행시키게 되면 INSERT, UPDATE, DELETE 쿼리 결과가 보이게 된다. 이 때 Transaction_A 는 COMMIT 하지 않고 ROLLBACK 을 하게 되면 Transaction_B 는 실제 데이터베이스에 없는 데이터를 읽게 된 것이며 이를 더티리드(Dirty read) 라고 한다.</p> <p>트랜잭션에서 INSERT, UPDATE, DELETE 쿼리를 실행할 경우 커밋하기 전에는 Undo 영역에 변경 전 데이터를 저장하고 레코드의 값을 변경한다. 이 때 Rollback 을 하게 되면 Undo 영역에 있던 데이터를 레코드로 복원하게 된다.</p> <p>READ_UNCOMMITTED 는 레코드에 저장된 값을 가저오기 때문에 롤백이 된 데이터를 읽어 올 수 있다.</p> <p>READ UNCOMMITTED 는 정합성 이슈가 발생하지 않는 SELECT 쿼리에서만 사용할 것을 권장하며 READ UNCOMMITTED로 읽은 데이터로 INSERT, UPDATE, DELETE 에 사용하지 않도록 주의해야 한다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- [SESSION_1]</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">SET</span> <span class="k">SESSION</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">UNCOMMITTED</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- name = 'one' 인 데이터가 출력됨.</span>

<span class="c1">-- [SESSION_2]</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="k">user</span> <span class="k">SET</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'two'</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'one'</span><span class="p">;</span>
<span class="c1">-- name = 'one' 을 'two' 로 업데이트함. 아직 커밋하지 않았음.</span>
<span class="c1">-- [SESSION_1]</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- name = 'two' 인 데이터 출력됨.</span>
<span class="c1">-- [SESSION_2]</span>
<span class="k">ROLLBACK</span><span class="p">;</span>
<span class="c1">-- 트랜잭션을 롤백</span>
<span class="c1">-- [SESSION_1]</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- 롤백전에는 name = 'two' 인 데이터가 출력되었지만 롤백 후에는 이전 데이터인 'one'인 데이터가 출력됨</span>
</code></pre></div></div> <p>위 내용을 직접 테스트해 보았을 때 name = ‘two’ 는 트랜잭션 내부에서 업데이트문만 실행했을 뿐 COMMIT 하지 않았지만 다른 세션에서 실행한 트랜잭션에서 읽을 수 있다. name = ‘two’가 제대로 커밋 된다면 다행이지만 롤백이 된다면 잘못된 데이터를 불러온 것이 된다.</p> <blockquote class="block-tip"> <h5 id="tip">TIP</h5> <p>READ UNCOMMITTED 는 자주 호출되지만 INSERT, UPDATE, DELETE 쿼리에는 영향이 가지 않는 곳에서 사용해야만 한다.</p> </blockquote> <h2 id="2-read-committed">2. READ COMMITTED</h2> <p>MSSQL, Oracle 의 기본 트랜잭션 격리수준으로 커밋 된 데이터를 읽을 수 있는 격리수준이다. 커밋 된 데이터만 읽기 때문에 READ UNCOMMITTED 처럼 더티리드(Dirty read)가 발생하지 않기 때문에 대부분의 데이터를 신뢰할 수 있다.</p> <p>READ COMMITTED 격리수준이라고 해서 모든 상황에서 데이터를 신뢰 할 수 있는 것은 아니다. 바로 Unrepeatable read 로 인해 다른 트랜잭션 간에 커밋 타이밍에 따라 데이터 정합성이 어긋 날 수 있기 때문이다. 그래서 READ COMMITTED 는 대부분의 데이터를 신뢰할 수 있다 라고 표현했다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- [SESSION_1]</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">SET</span> <span class="k">SESSION</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">COMMITTED</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- name = 'one' 인 데이터가 출력됨.</span>
<span class="c1">-- [SESSION_2]</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="k">user</span> <span class="k">SET</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'two'</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'one'</span><span class="p">;</span>
<span class="c1">-- name = 'one' 을 'two' 로 업데이트함. 아직 커밋하지 않았음.</span>
<span class="c1">-- [SESSION_1]</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- SESSION_2가 커밋되지 않았기 때문에 name = 'one' 인 데이터 출력됨.</span>
<span class="c1">-- [SESSION_2]</span>
<span class="k">COMMIT</span><span class="p">;</span>
<span class="c1">-- 커밋했기 때문에 디비에 데이터 반영됨.</span>
<span class="c1">-- [SESSION_1]</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- SESSION_2가 커밋되면서 name = 'two' 인 데이터가 출력된.</span>
<span class="n">name</span><span class="o">=</span><span class="s1">'one'</span>
</code></pre></div></div> <p>위 상황과 같이 SESSION_1 은 트랜잭션이 시작 했을 때 데이터를 확인해보면 name=’one’ 인 상태인데 SESSION_2 에서 트랜잭션 시작 후 업데이트 후 커밋까지 한 후 SESSION_1 에서 다시 조회를 하면 name = ‘two’ 로 바뀌어 있습니다. 이 처럼 같은 트랜잭션 내에게 같은 데이터를 조회했을 때 다른 데이터가 출력된다면 이 또한 데이터 정합성에 문제가 발생할 수 있다.</p> <p>일반적인 상황에서는 크게 문제되지 않지만 같은 트랜잭션 내에서 같은 SELECT 쿼리 여러번 호출하는 경우에는 이슈가 발생할 수 있다. 되도록이면 같은 트랜잭션 내에서 같은 SELECT 쿼리를 호출하는 케이스를 줄이도록 한다면 위와 같이 Unrepeatable read 현상을 줄일 수 있다.</p> <h2 id="3-repeatable-read">3. REPEATABLE READ</h2> <p>READ COMMITTED 와 같이 커밋 된 데이터를 읽지만 Unrepeatable read 현상이 발생하지 않는 격리 수준이다. MySQL 의 InnoDB 엔진에서 사용하는 기본격리수준이다.</p> <p>REPEATABLE READ는 Unrepeatable read 가 발생하지 않도록 트랜잭션이 시작하는 시점의 스냅샷을 기준으로 데이터를 조회한다. 다른 트랜잭션에 데이터가 업데이트되었더라도 현재 트랜잭션에서는 스냅샷 기준으로 데이터를 가저오기 때문에 Unrepeatable read 현상이 발생하지 않는다.</p> <p>트랜잭션을 시작하게 되면 트랜잭션에는 번호를 가지게 되고 언두 영역의 백업된 모든 레코드에는 백업한 트랜잭션 번호가 포함되어 있다. 그리고 언두 영역의 백업된 데이터는 InnoDB 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제한다.</p> <p>REPEATABLE READ 는 PHANTOM READ(=PHANTOM ROW) 라는 이슈가 발생한다. PHANTOM READ는 첫번째 SELECT 문에서 보이지 않았던 데이터가 두번째 SELECT 쿼리에서는 보이는 현상이다.</p> <p>InnoDB 에서의 독특한 매커니즘으로 인해 PHANTOM READ 현상은 발생하지 않는다. 직접 MySQL 로 테스트를 해보았을 때 발생하지 않았다.</p> <p>INSERT 쿼리 실행 후 커밋하지 않은 상태에서 다른 트랜잭션에서 SELECT ~ FOR UPDATE 를 실행 시 INSERT 를 실행 한 트랜잭션에 의해 SELECT ~ FOR UPDATE 쿼리는 락이 걸리게 되어 PHANTOM READ 가 발생하지 않는다.</p> <h2 id="4-serializable">4. SERIALIZABLE</h2> <p>가장 엄격한 격리수준으로 동시 작업 성능이 가장 떨어지는 격리 수준이다. SELECT 쿼리는 기본적으로 SHARED LOCk 을 기본적으로 획득하게되어 SELECT 중 INSERT, UPDATE, DELETE 가 불가능하다.</p> <h2 id="5-결론">5. 결론</h2> <p>기본적으로 <em>READ COMMITTED 혹은 REPEATABLE READ 를 사용할 것을 권장</em>한다.</p> <p>되도록이면 1개의 트랜잭션에서 같은 SELECT 쿼리를 실행하지 않도록 주의한다. READ COMMITTED의 경우 1개의 트랜잭션에서 같은 SELECT 문을 실행시 Unrepeatable read 현상이 발생할 여지가 있다. REPEATABLE READ 의 경우 PHANTOM READ가 발생할 수 있다. (InnoDB 외 다른 엔진에서 PHANTOM READ 발생)</p> <p>SERIALIZABLE 은 사용하지 않는 것이 정신 건강에 좋다. 실시간성을 보장받지 않고 데이터가 정확하지 않아도 되는 기능의 경우 READ UNCOMMITTED 를 사용하면 성능을 높일 수 있다.</p> <h2 id="6-참고">6. 참고</h2> <ul> <li>https://zzang9ha.tistory.com/381</li> <li>Real Mysql 8.0</li> </ul>]]></content><author><name></name></author><category term="MySQL"/><category term="mysql,"/><category term="트랜잭션,"/><category term="IsolationLevel,"/><category term="격리수준,"/><category term="Transaction"/><summary type="html"><![CDATA[MySQL 트랜잭션 격리수준 Isolation level 알아보기]]></summary></entry></feed>