<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://hwangrolee.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://hwangrolee.github.io/" rel="alternate" type="text/html" hreflang="ko"/><updated>2025-09-08T15:03:45+00:00</updated><id>https://hwangrolee.github.io/feed.xml</id><title type="html">이황로의 포트폴리오</title><subtitle>풀스택 개발자로서 시스템 최적화와 성능 개선에 보람을 느낍니다. 안정적이고 확장 가능한 서비스를 만듭니다.</subtitle><entry><title type="html">AI 시대, 경쟁력 있는 사람이 되는 법, 효과적인 프롬프트 작성 가이드</title><link href="https://hwangrolee.github.io/blog/AI-%EC%8B%9C%EB%8C%80,-%EA%B2%BD%EC%9F%81%EB%A0%A5-%EC%9E%88%EB%8A%94-%EC%82%AC%EB%9E%8C%EC%9D%B4-%EB%90%98%EB%8A%94-%EB%B2%95-%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B8-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8-%EC%9E%91%EC%84%B1-%EA%B0%80%EC%9D%B4%EB%93%9C/" rel="alternate" type="text/html" title="AI 시대, 경쟁력 있는 사람이 되는 법, 효과적인 프롬프트 작성 가이드"/><published>2025-08-25T00:00:00+00:00</published><updated>2025-08-25T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/AI-%EC%8B%9C%EB%8C%80,%20%EA%B2%BD%EC%9F%81%EB%A0%A5-%EC%9E%88%EB%8A%94-%EC%82%AC%EB%9E%8C%EC%9D%B4-%EB%90%98%EB%8A%94-%EB%B2%95-%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B8-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8-%EC%9E%91%EC%84%B1-%EA%B0%80%EC%9D%B4%EB%93%9C</id><content type="html" xml:base="https://hwangrolee.github.io/blog/AI-%EC%8B%9C%EB%8C%80,-%EA%B2%BD%EC%9F%81%EB%A0%A5-%EC%9E%88%EB%8A%94-%EC%82%AC%EB%9E%8C%EC%9D%B4-%EB%90%98%EB%8A%94-%EB%B2%95-%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B8-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8-%EC%9E%91%EC%84%B1-%EA%B0%80%EC%9D%B4%EB%93%9C/"><![CDATA[<p>AI 기술이 급부상하면서 다양한 분야에서 AI를 활용하기 위한 노력이 이어지고 있습니다.</p> <p>IT 회사들은 AI를 활용한 업무 자동화 에이전트나 콘텐츠 생성 자동화 도구를 개발하고 있고, n8n, make.com과 같은 워크플로우 자동화 툴의 사용 사례가 매일 새롭게 등장하고 있습니다.</p> <hr/> <h2 id="왜-ai에-집중하는-걸까요">왜 AI에 집중하는 걸까요?</h2> <p>사람들이 AI에 집중하는 이유는 간단합니다. 지금은 부족할지 모르지만 언젠가는 내 삶을 완전히 바꿀 도구가 바로 AI라고 생각하기 때문입니다. 그리고 이 기술을 지금 당장 잘 활용한다면 경쟁 우위를 확보할 수 있다고 판단하고 있습니다.</p> <p>과거 스마트폰 열풍 시절을 생각해보세요. 카카오톡, 라인 등 다양한 메신저가 경쟁했지만 결국 카카오톡만 살아남아 국민 메신저가 되었습니다. 초기 시장에서 사람들이 원하는 서비스를 잘 만들어 고객을 확보하면, 나중에 더 좋은 서비스가 나와도 사람들은 쉽게 옮기지 않습니다. 이미 익숙해졌고, 충분히 만족하고 있기 때문이죠.</p> <p>이를 알고 있는 기업들은 AI 분야에서 시장을 선점하기 위해 다양한 시도를 하고 있습니다.</p> <hr/> <h2 id="우리는-무엇을-해야-할까요">우리는 무엇을 해야 할까요?</h2> <p>그렇다면 기업이 아닌 우리 개인은 무엇을 해야 할까요?</p> <p><strong>AI를 잘 쓰는 사람이 되는 것입니다.</strong> 그러면 어떤 AI 서비스가 나와도 빠르게 적응하고 업무에 활용할 수 있습니다.</p> <p>AI를 잘 활용하기 위해서는 두 가지가 중요합니다:</p> <ul> <li>내 업무를 어떻게 자동화할 것인가?</li> <li>AI에게 어떻게 효과적으로 질문할 것인가?</li> </ul> <p>이 글에서는 두 번째 부분, 즉 AI에게 효과적으로 질문하는 방법에 대해 정리해보겠습니다.</p> <blockquote> <p>AI에게 하는 질문을 <strong>프롬프트(Prompt)</strong>라고 부르며, 이를 전문적으로 다루는 사람을 <strong>프롬프트 엔지니어</strong>라고 합니다.</p> </blockquote> <hr/> <h2 id="효과적인-프롬프트-사용법">효과적인 프롬프트 사용법</h2> <h3 id="1-목적을-명확히-정리하세요">1. 목적을 명확히 정리하세요</h3> <p>프롬프트를 잘 사용하려면 먼저 머릿속에 질문하고자 하는 내용을 명확하게 정리해야 합니다. 명확한 목적이 있어야 좋은 질문을 만들 수 있습니다.</p> <h3 id="2-프롬프트-작성을-ai에게-맡기세요">2. 프롬프트 작성을 AI에게 맡기세요</h3> <p>직접 프롬프트를 작성하는 것보다 AI에게 맡기는 것이 더 효과적입니다.</p> <p>친구에게 말하듯 편하게 풀어서 설명하고, 마지막에 “내가 작성한 내용을 정리해서 프롬프트로 작성해주세요”라고 요청하세요.</p> <p><strong>예시:</strong></p> <blockquote> <p>“친구에게 말하듯 아티클을 작성하고 싶어요. 이모티콘도 넣으면 좋을 것 같아요.”</p> </blockquote> <blockquote> <p>“SEO를 고려한 네이버 블로그를 작성하고 싶어요.”</p> </blockquote> <p>Claude, ChatGPT, Gemini 같은 AI 서비스들은 각각 권장하는 프롬프트 방식이 다릅니다. 이 가이드를 직접 따라 작성하기에는 시간이 많이 걸리므로, AI에게 맡기는 것이 효율적입니다.</p> <h3 id="3-ai가-작성한-프롬프트를-보완하세요">3. AI가 작성한 프롬프트를 보완하세요</h3> <p>AI도 완벽하지 않습니다. 생성된 프롬프트를 검토하고 필요에 따라 수정하세요.</p> <p><strong>보완 예시:</strong></p> <blockquote> <p>“이모티콘은 사용하지 마세요”</p> </blockquote> <blockquote> <p>“전문가 대상으로 글을 작성해주세요”</p> </blockquote> <blockquote> <p>“존댓말을 사용해주세요”</p> </blockquote> <h3 id="4-명확한-목적을-가진-프롬프트를-만드세요">4. 명확한 목적을 가진 프롬프트를 만드세요</h3> <p>여러 목적이 섞인 프롬프트는 효율이 떨어집니다.</p> <ul> <li><strong>비효율적인 예:</strong> “아티클 제목 생성하고, 부제목도 나열하고, 요약도 해주세요”</li> <li><strong>효율적인 방법:</strong> 제목, 부제목, 본문을 각각 따로 요청하기</li> </ul> <p>관련성이 높은 작업(블로그 글 작성 + SEO 최적화)은 함께 요청해도 좋습니다.</p> <h3 id="5-결과를-꼼꼼히-검토하세요">5. 결과를 꼼꼼히 검토하세요</h3> <p>완벽한 프롬프트라도 결과가 만족스럽지 않을 수 있습니다. 결과를 읽어보고 아쉬운 부분을 프롬프트에 추가해서 다시 요청하세요.</p> <h3 id="6-프롬프트를-저장하고-재활용하세요">6. 프롬프트를 저장하고 재활용하세요</h3> <p>한 번 만든 좋은 프롬프트는 자산입니다. 주제가 바뀌어도 기본 구조는 비슷하므로 프롬프트 히스토리를 관리해서 재사용하는 것을 추천합니다.</p> <hr/> <h2 id="결론">결론</h2> <p>AI 시대에 경쟁력을 확보하는 핵심 전략:</p> <ul> <li><strong>프롬프트 작성은 AI에게 맡기세요</strong> – 더 효율적이고 정확합니다.</li> <li><strong>하나의 명확한 목적을 가진 프롬프트를 만드세요</strong> – 복잡한 작업은 나누어 요청하세요.</li> <li><strong>프롬프트를 저장하고 재사용하세요</strong> – 좋은 프롬프트는 계속 활용할 수 있습니다.</li> <li><strong>결과를 꼼꼼히 확인하세요</strong> – AI도 완벽하지 않으니 검토가 필요합니다.</li> </ul> <p>AI를 잘 활용하는 능력을 기르면, 앞으로 어떤 AI 서비스가 나와도 빠르게 적응하고 활용할 수 있을 것입니다.</p>]]></content><author><name></name></author><category term="ai"/><category term="ai,"/><category term="프롬프트"/><summary type="html"><![CDATA[AI 시대에 경쟁력을 높이는 프롬프트 작성법을 찾고 있나요? 이 글은 ChatGPT, Gemini 등 AI에게 효과적으로 질문하는 5가지 핵심 비법을 공유합니다. AI에게 프롬프트 작성을 맡기는 방법부터 재활용까지, 누구나 쉽게 따라 할 수 있는 가이드를 확인하세요.]]></summary></entry><entry><title type="html">AI 글쓰기 품질을 높이는 프롬프트 엔지니어링 8단계 (실전 템플릿 포함)</title><link href="https://hwangrolee.github.io/blog/5%EB%B6%84-%EB%A7%8C%EC%97%90-%EC%9D%BD%EB%8A%94-AI-%EA%B8%80%EC%93%B0%EA%B8%B0-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-AI-%EA%B8%80%EC%93%B0%EA%B8%B0-%EC%9A%94%EC%B2%AD-%EB%B0%A9%EB%B2%95%EA%B3%BC-%ED%95%B5%EC%8B%AC-%EC%9A%94%EC%86%8C/" rel="alternate" type="text/html" title="AI 글쓰기 품질을 높이는 프롬프트 엔지니어링 8단계 (실전 템플릿 포함)"/><published>2025-08-25T00:00:00+00:00</published><updated>2025-08-25T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/5%EB%B6%84-%EB%A7%8C%EC%97%90-%EC%9D%BD%EB%8A%94-AI-%EA%B8%80%EC%93%B0%EA%B8%B0-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-AI-%EA%B8%80%EC%93%B0%EA%B8%B0-%EC%9A%94%EC%B2%AD-%EB%B0%A9%EB%B2%95%EA%B3%BC-%ED%95%B5%EC%8B%AC-%EC%9A%94%EC%86%8C</id><content type="html" xml:base="https://hwangrolee.github.io/blog/5%EB%B6%84-%EB%A7%8C%EC%97%90-%EC%9D%BD%EB%8A%94-AI-%EA%B8%80%EC%93%B0%EA%B8%B0-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-AI-%EA%B8%80%EC%93%B0%EA%B8%B0-%EC%9A%94%EC%B2%AD-%EB%B0%A9%EB%B2%95%EA%B3%BC-%ED%95%B5%EC%8B%AC-%EC%9A%94%EC%86%8C/"><![CDATA[<p>AI에게 글을 써달라고 요청했는데, 결과가 영 딴판이라 당황한 적 있으신가요? “AI가 내 마음을 좀 더 잘 알아줬으면…” 하고 생각했다면, 오늘 이 글이 바로 그 해답이 될 겁니다.</p> <p>핵심은 간단합니다. AI를 <strong>‘알아서 다 해주는 만능 해결사’</strong>가 아니라, <strong>‘의욕은 넘치지만 구체적인 지시가 필요한 똑똑한 신입사원’</strong>으로 대하는 것입니다.</p> <p>이 신입사원에게 그냥 “보고서 하나 써와”라고 던져주는 게 아니라, “누가, 왜 읽을 거고, 어떤 스타일로 써야 하는지”를 알려주는 것. 이것이 바로 프롬프트 엔지니어링의 시작입니다. 오늘은 AI에게 일을 잘 시키는 8가지 핵심 지시 항목과, <strong>‘왜 그렇게 해야 하는지’</strong> 그 이유까지 속 시원하게 알려드릴게요.</p> <hr/> <h3 id="ai-글쓰기-품질을-높이는-8가지-핵심-요소"><strong>AI 글쓰기 품질을 높이는 8가지 핵심 요소</strong></h3> <h4 id="1-ai에게-역할을-부여하세요-persona"><strong>1. AI에게 역할을 부여하세요 (Persona)</strong></h4> <p>AI에게 특정 역할이나 직업, 성격을 부여하는 지시입니다. “당신은 10년 차 IT 개발자입니다”처럼 구체적인 가면을 씌워주는 거죠.</p> <blockquote> <p><strong>왜 이게 필요한가요?</strong></p> <p><strong>AI에게 일관된 목소리와 관점을 만들어주기 때문입니다.</strong> 페르소나 없이는 AI가 어떤 톤으로 말해야 할지 몰라 기계적이고 평범한 답변을 내놓기 쉽습니다. 역할을 부여하면, AI는 그 역할에 맞는 전문성과 말투를 스스로 장착하여 훨씬 자연스럽고 신뢰도 높은 글을 씁니다.</p> </blockquote> <h4 id="2-이-글의-최종-목표를-알려주세요-goal"><strong>2. 이 글의 최종 목표를 알려주세요 (Goal)</strong></h4> <p>이 글을 통해 궁극적으로 무엇을 이루고 싶은지, 글의 존재 이유를 명확하게 설명하는 단계입니다. “이 글의 목표는 독자가 제품을 구매하게 만드는 거야”처럼 말이죠.</p> <blockquote> <p><strong>왜 이게 필요한가요?</strong></p> <p><strong>글의 방향성이 흔들리지 않도록 중심을 잡아주기 때문입니다.</strong> 목표를 알면 AI는 단순히 정보를 나열하는 것을 넘어, 그 목표 달성에 가장 효과적인 단어와 문장 구조를 선택합니다. 설득이 목표라면 설득적인 어조로, 정보 전달이 목표라면 객관적인 어조로 글의 전체적인 흐름을 조절합니다.</p> </blockquote> <h4 id="3-누가-읽을-글인지-알려주세요-audience"><strong>3. 누가 읽을 글인지 알려주세요 (Audience)</strong></h4> <p>이 글을 읽게 될 사람이 누구인지, 그들의 배경지식은 어느 정도인지 구체적으로 알려주는 것입니다. “이 글은 코딩을 처음 배우는 대학생이 읽을 거야”처럼요.</p> <blockquote> <p><strong>왜 이게 필요한가요?</strong></p> <p><strong>독자의 눈높이에 맞춰 언어와 깊이를 조절하기 위해서입니다.</strong> 같은 주제라도 전문가에게 설명하는 방식과 어린이에게 설명하는 방식은 완전히 다릅니다. 독자 정보를 주면 AI가 어려운 전문 용어를 피하거나, 적절한 비유를 사용하는 등 맞춤형 콘텐츠를 생성할 수 있습니다.</p> </blockquote> <h4 id="4-원하는-분위기와-스타일을-지정해주세요-tone--manner"><strong>4. 원하는 분위기와 스타일을 지정해주세요 (Tone &amp; Manner)</strong></h4> <p>글의 전체적인 분위기, 문체, 형식 등을 구체적으로 지시하는 것입니다. “친구처럼 친근한 말투로, 장점은 꼭 목록으로 정리해줘” 같은 요구사항이죠.</p> <blockquote> <p><strong>왜 이게 필요한가요?</strong></p> <p><strong>브랜드나 개인의 고유한 스타일을 글에 반영하기 위해서입니다.</strong> 딱딱한 보고서 스타일, 유머러스한 SNS 스타일 등 원하는 결과물의 ‘느낌’을 AI가 구현하도록 만드는 가장 직접적인 방법입니다. 일관된 톤앤매너는 독자에게 신뢰감을 줍니다.</p> </blockquote> <h4 id="5-원하는-글의-길이를-정해주세요-length"><strong>5. 원하는 글의 길이를 정해주세요 (Length)</strong></h4> <p>블로그 포스팅, 트위터, 이메일 등 글이 사용될 플랫폼에 맞춰 원하는 분량을 명확히 알려주는 단계입니다. “약 800자 내외로”처럼 구체적인 숫자가 좋습니다.</p> <blockquote> <p><strong>왜 이게 필요한가요?</strong></p> <p><strong>각 매체의 특성에 맞는 최적화된 콘텐츠를 얻기 위해서입니다.</strong> AI는 지시가 없으면 내용에 따라 글을 너무 길거나 짧게 생성할 수 있습니다. 길이를 명확히 지정하면, AI는 주어진 분량 안에서 핵심 내용을 효과적으로 요약하거나 상세하게 풀어내는 능력을 발휘합니다.</p> </blockquote> <h4 id="6-이-단어는-꼭-넣어달라고-하세요-keyword"><strong>6. 이 단어는 꼭 넣어달라고 하세요 (Keyword)</strong></h4> <p>블로그 글이라면 검색엔진 최적화(SEO)를 위해 특정 키워드를 포함하도록 요청하는 것입니다. “본문에 ‘AI 글쓰기’를 자연스럽게 3번 넣어줘” 처럼요.</p> <blockquote> <p><strong>왜 이게 필요한가요?</strong></p> <p><strong>검색 노출 가능성을 높이고 주제의 초점을 명확하게 하기 위함입니다.</strong> 키워드를 지정하면 AI는 해당 키워드를 중심으로 글의 내용을 구성하게 되어 주제에서 벗어날 확률이 줄어듭니다. 이는 SEO뿐만 아니라 글의 전문성을 높이는 데도 도움이 됩니다.</p> </blockquote> <h4 id="7-참고할-자료가-있다면-알려주세요-references"><strong>7. 참고할 자료가 있다면 알려주세요 (References)</strong></h4> <p>최신 뉴스 기사나 특정 보고서, 웹사이트 링크 등 글을 작성할 때 기반이 되어야 할 정보가 있다면 제공하는 것입니다.</p> <blockquote> <p><strong>왜 이게 필요한가요?</strong></p> <p><strong>글의 정확성과 최신성을 확보하기 위해서입니다.</strong> AI의 학습 데이터는 특정 시점까지의 정보일 수 있습니다. 최신 정보나 신뢰할 수 있는 데이터를 직접 제공하면, AI가 잘못된 정보를 생성(할루시네이션)하는 것을 방지하고 훨씬 사실에 기반한 글을 작성할 수 있습니다.</p> </blockquote> <h4 id="8-이것만은-피해서-써달라고-하세요-constraints"><strong>8. 이것만은 피해서 써달라고 하세요 (Constraints)</strong></h4> <p>글에 절대 포함되지 말아야 할 내용이나 표현, 스타일 등을 명시적으로 금지하는 지시입니다. “경쟁사 언급은 하지 마세요” 와 같은 조건이죠.</p> <blockquote> <p><strong>왜 이게 필요한가요?</strong></p> <p><strong>원치 않는 결과물을 사전에 차단하여 수정 작업을 줄이기 위함입니다.</strong> 제약 조건을 명시하지 않으면 AI는 자유롭게 내용을 생성하다가 브랜드 가이드라인에 어긋나거나 법적으로 민감한 내용을 포함할 수 있습니다. 이는 글의 품질을 유지하고 리스크를 관리하는 중요한 안전장치입니다.</p> </blockquote> <hr/> <h3 id="만능-프롬프트-템플릿-이대로-복사해서-쓰세요"><strong>만능 프롬프트 템플릿 (이대로 복사해서 쓰세요!)</strong></h3> <p>아래 템플릿을 복사해서, <code class="language-plaintext highlighter-rouge">[ ]</code> 안의 내용만 여러분의 상황에 맞게 바꿔보세요. 놀랍도록 향상된 결과물을 경험하게 될 겁니다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 역할 부여 (Persona)
당신은 [10년 차 베테랑 마케터이자, 신입사원도 쉽게 이해하도록 설명해주는 친절한 사수]입니다.

# 최종 목표 (Goal)
[신제품 출시 관련 블로그 포스팅]에 대한 글을 작성해주세요. 이 글의 목표는 [우리 제품에 대해 전혀 모르는 20대 고객들이 이 글을 읽고 제품에 대한 호기심을 느끼게 만드는 것]입니다.

# 대상 독자 (Audience)
- 대상: [마케팅에 관심 있는 대학생, 사회초년생]
- 특징: [트렌드에 민감하지만, 전문 용어는 잘 모름]

# 톤앤매너 (Tone &amp; Manner)
- 말투: [친구처럼 친근하고 유머러스한 대화체]
- 형식: [핵심 특징 3가지는 꼭 글머리 기호 목록으로 정리]

# 글 길이 (Length)
- [공백 제외 800자 내외]

# 필수 키워드 (Keyword)
- ['신제품', 'MZ세대 마케팅', '인싸템']

# 제약 조건 (Constraints)
- [타사 제품을 비방하는 내용은 절대 금지]
- [너무 어려운 마케팅 용어는 사용하지 말 것]

위의 모든 조건을 충실히 반영하여, 독자들이 끝까지 흥미롭게 읽을 수 있는 블로그 글을 작성해주세요.
</code></pre></div></div>]]></content><author><name></name></author><category term="ai"/><category term="ai,"/><category term="프롬프트"/><summary type="html"><![CDATA[AI가 써준 글, 결과가 실망스러우신가요? 페르소나, 목표, 독자 설정 등 AI 글쓰기 품질을 극적으로 높이는 8가지 프롬프트 작성법을 공개합니다. AI를 똑똑한 신입사원처럼 부리는 비법과 바로 사용하는 만능 템플릿까지 확인해 보세요.]]></summary></entry><entry><title type="html">AI를 믿을 수 있을까? 인간이 할루시네이션을 구분할줄 알아야 한다.</title><link href="https://hwangrolee.github.io/blog/AI%EB%A5%BC-%EB%AF%BF%EC%9D%84-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C-%EC%9D%B8%EA%B0%84%EC%9D%B4-%ED%95%A0%EB%A3%A8%EC%8B%9C%EB%84%A4%EC%9D%B4%EC%85%98%EC%9D%84-%EA%B5%AC%EB%B6%84%ED%95%A0%EC%A4%84-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%9C%EB%8B%A4/" rel="alternate" type="text/html" title="AI를 믿을 수 있을까? 인간이 할루시네이션을 구분할줄 알아야 한다."/><published>2025-08-21T00:00:00+00:00</published><updated>2025-08-21T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/AI%EB%A5%BC-%EB%AF%BF%EC%9D%84-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C-%EC%9D%B8%EA%B0%84%EC%9D%B4-%ED%95%A0%EB%A3%A8%EC%8B%9C%EB%84%A4%EC%9D%B4%EC%85%98%EC%9D%84-%EA%B5%AC%EB%B6%84%ED%95%A0%EC%A4%84-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%9C%EB%8B%A4</id><content type="html" xml:base="https://hwangrolee.github.io/blog/AI%EB%A5%BC-%EB%AF%BF%EC%9D%84-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C-%EC%9D%B8%EA%B0%84%EC%9D%B4-%ED%95%A0%EB%A3%A8%EC%8B%9C%EB%84%A4%EC%9D%B4%EC%85%98%EC%9D%84-%EA%B5%AC%EB%B6%84%ED%95%A0%EC%A4%84-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%9C%EB%8B%A4/"><![CDATA[<h2 id="ai-검색이-일상이-되었지만">AI 검색이 일상이 되었지만…</h2> <p>AI를 잘 활용하기 위해 많은 사람들이 공부하면서 회사업무와 개인업무에 적용 중이다. 나 또한 네이버, 구글보다는 클로드, 제미나이, 챗지피티로 먼저 검색하는 습관이 생겨버렸다. 그리고 검색결과를 구글을 통해 더블 체크하는 습관도 같이 생겨버렸다.</p> <hr/> <h2 id="개발자가-경험하는-ai의-한계">개발자가 경험하는 AI의 한계</h2> <p>개발자로써 생산성을 높이기 위해 다양한 라이브러리와 개발방법론 등을 AI에게 먼저 물어보지만, 대부분은 다음과 같은 문제들이 발생한다:</p> <ul> <li>너무 예전 라이브러리를 추천하는 경우가 많다</li> <li>잘못된 사용법을 알려준다</li> <li>존재하지 않는 라이브러리를 알려주는 경우가 거의 대부분이다</li> </ul> <p>그렇기 때문에 1개의 물음을 해결하기 위해 최소 5번은 AI와 씨름을 하고 있는 것 같다. 그리고 요즘 더 심해지고 있다는 생각도 든다.</p> <hr/> <h2 id="ai를-정말-믿을-수-있을까">AI를 정말 믿을 수 있을까?</h2> <p>요즘은 이렇게 생각한다. 과연 AI가 주는 답변을 정말 믿을 수 있을까? 아직은 믿을 수 없다고 생각한다.</p> <hr/> <h2 id="가짜-데이터의-급증이-문제다">가짜 데이터의 급증이 문제다</h2> <p>AI가 이렇게까지 발전하기 전에도 가짜뉴스와 가짜 아티클은 있었지만 진짜보다는 상대적으로 적었기 때문에 구글의 검색결과에서 몇개 더 읽어보면 진짜를 쉽게 판단할 수 있었다.</p> <p>하지만 요즘에는 AI로 생성된 가짜 데이터가 너무 많아져서 AI의 할루시네이션이 심해진 것 같다는 생각이 든다.</p> <p>사람도 주변에 진짜가 아닌 가짜만 가득하다면 그것이 진실인 줄 알게 될 것이다. 이처럼 인터넷에 진짜보다 가짜 글이 많아지게 되면서 AI의 결과를 믿을 수 없는 상황에 발생할 수도 있지 않을까란 생각을 저버릴 수가 없다.</p> <blockquote> <p>참고: AI는 인터넷상에 존재하는 수많은 문서를 학습데이터로 활용하기 때문에 가짜 데이터가 많아질수록 AI의 할루시네이션이 심해질 수밖에 없다.</p> </blockquote> <hr/> <h2 id="ai-콘텐츠-제작자들에게-하고-싶은-말">AI 콘텐츠 제작자들에게 하고 싶은 말</h2> <p>AI로 아티클을 만드는 수많은 사람들에게 말하고 싶다.<br/> AI가 만들어준 아티클을 믿지 말고 꼭 검증을 한 후에 게시하라고…</p> <p>나도 다른 사람의 글을 읽고 인사이트를 얻길 원하듯 누군가는 내가 작성한 글을 읽고 다양한 인사이트를 얻길 희망한다.<br/> 나부터 퀄리티 높은 아티클을 만들기 위해 노력하고 실천했으면 좋겠다.</p> <hr/> <h2 id="ai의-올바른-활용법">AI의 올바른 활용법</h2> <p>AI로 사람의 일을 100에서 0으로 만들 순 없다. 아니 만들 순 있지만 신뢰성을 보장받지 못할 거라고 생각한다.</p> <p>AI는 사람의 일을 100에서 1로 줄여주기 위해 활용하는 것은 어떨까?</p> <p>아직까지는 혹은 앞으로도 계속 사람의 리뷰 과정은 꼭 필요하다고 생각한다.</p> <hr/> <h2 id="더-나은-ai-활용을-위한-노력">더 나은 AI 활용을 위한 노력</h2> <p>AI로부터 조금이라도 신뢰성 있는 답변을 얻고 싶다면 질문(프롬프트, Prompt)를 어떻게 할 것인가에 대해서 공부해보면 좋을 것 같다. 그래서 나도 프롬프트를 공부 중이다.</p> <p>이 말에 누군가는 “그럼 ai를 더 잘 만들면 되는거 아냐”라고 말할 수도 있다. 지금도 AI 회사는 전세계의 천재들을 모아서 개발 중이다. 하지만 아직까지도 해결이 안되고 있다.</p> <hr/> <h2 id="지금-당장-해야-할-것">지금 당장 해야 할 것</h2> <p>마냥 AI가 알아서 잘 답변할 때까지 기다릴 순 없다. 기다리다 보면 어느새 시대에 뒤처지는 사람이 될 테니까.</p> <p>지금 상황에서도 분명 AI를 잘 활용한다면 내 업무를 굉장히 많이 줄어들 것이고 남은 시간은 더 중요한 일에 활용할 수 있다.</p> <hr/> <h2 id="결론">결론</h2> <p><strong>AI를 믿지 말자. AI의 결과를 항상 의심하자. AI의 결과를 더블체크해서 신뢰성 높은 무언가를 만들자.</strong></p>]]></content><author><name></name></author><category term="ai"/><category term="ai"/><summary type="html"><![CDATA[AI 검색과 업무 활용의 현실, 개발자가 경험하는 AI의 한계와 할루시네이션 문제, 신뢰성 있는 AI 활용법과 프롬프트 학습의 중요성을 다룹니다.]]></summary></entry><entry><title type="html">JIT 컴파일러가 뭔가요? 왜 우리 프로그램이 더 빨라지는 걸까요?</title><link href="https://hwangrolee.github.io/blog/JIT-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EA%B0%80-%EB%AD%94%EA%B0%80%EC%9A%94/" rel="alternate" type="text/html" title="JIT 컴파일러가 뭔가요? 왜 우리 프로그램이 더 빨라지는 걸까요?"/><published>2025-08-14T00:00:00+00:00</published><updated>2025-08-14T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/JIT-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EA%B0%80-%EB%AD%94%EA%B0%80%EC%9A%94</id><content type="html" xml:base="https://hwangrolee.github.io/blog/JIT-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EA%B0%80-%EB%AD%94%EA%B0%80%EC%9A%94/"><![CDATA[<h2 id="0-jit-컴파일러-자바-실행의-비밀">0. JIT 컴파일러, 자바 실행의 비밀</h2> <p>프로그래밍을 처음 배울 때 이런 의문을 가져보신 적 있나요? “내가 작성한 Java 코드가 어떻게 컴퓨터에서 실행되는 거지?” 오늘은 그 비밀을 풀어보겠습니다. 특히 우리가 모르는 사이에 프로그램을 더 빠르게 만들어주는 <code class="language-plaintext highlighter-rouge">JIT 컴파일러</code>라는 마법같은 기술에 대해 알아보겠습니다.</p> <hr/> <h2 id="1-jit-컴파일러가-뭐예요">1. JIT 컴파일러가 뭐예요?</h2> <p>먼저 컴파일러의 종류를 알아봅시다<br/> 프로그램이 실행되는 방식을 이해하려면 세 가지 방식을 알아야 합니다.</p> <h3 id="인터프리터-방식">인터프리터 방식</h3> <p>카페에서 통역사가 실시간으로 대화를 번역해주는 것과 같습니다. 코드를 한 줄씩 읽으면서 바로바로 실행합니다. Python이나 JavaScript가 대표적인 예입니다. 장점은 코드를 바로 실행할 수 있다는 것이고, 단점은 매번 번역하느라 느리다는 것입니다.</p> <h3 id="aot-ahead-of-time-컴파일러">AOT (Ahead-Of-Time) 컴파일러</h3> <p>책을 통째로 다른 언어로 번역해놓는 것과 같습니다. 프로그램을 실행하기 전에 미리 모든 코드를 컴퓨터가 이해할 수 있는 기계어로 바꿔놓습니다. C나 C++이 이런 방식입니다. 한 번 번역해놓으면 빠르게 실행되지만, 다른 컴퓨터에서는 다시 번역해야 할 수 있습니다.</p> <h3 id="jit-just-in-time-컴파일러">JIT (Just-In-Time) 컴파일러</h3> <p>이름 그대로 ‘딱 필요할 때’ 번역하는 방식입니다. 프로그램이 실행되는 중에 자주 사용되는 부분을 발견하면, 그 부분만 골라서 빠른 기계어로 번역해놓습니다. 똑똑한 통역사가 자주 나오는 표현은 미리 외워두고 빠르게 말해주는 것과 비슷합니다.</p> <h4 id="just-in-time의-진짜-의미"><code class="language-plaintext highlighter-rouge">Just-In-Time</code>의 진짜 의미</h4> <p><code class="language-plaintext highlighter-rouge">Just-In-Time</code>이라는 말은 “딱 필요한 순간에”라는 뜻입니다. JIT 컴파일러는 프로그램을 실행하면서 “아, 이 부분이 자주 실행되네?“라고 판단되는 순간, 그때서야 그 부분을 최적화된 기계어로 바꿔놓습니다. 마치 자주 가는 길을 외워서 더 빠르게 갈 수 있게 되는 것처럼요.</p> <hr/> <h2 id="2-java는-이미-컴파일하는데-왜-또-컴파일할까요">2. Java는 이미 컴파일하는데, 왜 또 컴파일할까요?</h2> <p>Java를 처음 배울 때 이런 경험 있으시죠? <code class="language-plaintext highlighter-rouge">.java</code> 파일을 작성하고 <code class="language-plaintext highlighter-rouge">javac</code> 명령어로 컴파일하면 <code class="language-plaintext highlighter-rouge">.class</code> 파일이 생깁니다. “어? 벌써 컴파일했는데 왜 JIT에서 또 컴파일한다는 거지?”</p> <h3 id="javac가-만드는-것은-중간-언어">javac가 만드는 것은 ‘중간 언어’</h3> <p>사실 <code class="language-plaintext highlighter-rouge">javac</code>가 만드는 <code class="language-plaintext highlighter-rouge">.class</code> 파일 안에는 ‘바이트코드’라는 것이 들어있습니다. 바이트코드는 컴퓨터의 CPU가 직접 이해할 수 있는 언어가 아닙니다.</p> <p>이걸 비유로 설명하면:</p> <ul> <li>Java 코드 = 한국어로 쓴 편지</li> <li>바이트코드 = 영어로 번역한 편지 (전 세계 어디서든 읽을 수 있지만, 아직 각 지역 방언으로는 번역 안 됨)</li> <li>기계어 = 각 지역의 방언으로 번역한 편지 (그 지역 사람들이 가장 빠르게 이해할 수 있음)</li> </ul> <h3 id="jit이-런타임에서-하는-일">JIT이 런타임에서 하는 일</h3> <p>JVM(Java Virtual Machine)이 바이트코드를 실행할 때, 처음에는 인터프리터처럼 한 줄씩 번역해서 실행합니다. 그러다가 “어? 이 코드가 100번째 실행되네?“라고 판단되면, JIT 컴파일러가 나서서 그 부분을 해당 컴퓨터에 최적화된 기계어로 번역해놓습니다.</p> <hr/> <h2 id="3-warjar-안에는-무엇이-들어있나요">3. WAR/JAR 안에는 무엇이 들어있나요?</h2> <p>웹 개발을 하다 보면 WAR 파일이나 JAR 파일을 자주 보게 됩니다. 이 파일들 안에는 무엇이 들어있을까요?</p> <h3 id="바이트코드가-가득한-압축-파일">바이트코드가 가득한 압축 파일</h3> <p>WAR/JAR 파일은 사실 ZIP 파일과 같은 압축 파일입니다. 안에는:</p> <ul> <li>컴파일된 <code class="language-plaintext highlighter-rouge">.class</code> 파일들 (바이트코드)</li> <li>설정 파일들</li> <li>라이브러리들</li> <li>웹 리소스들 (HTML, CSS, JavaScript 등)</li> </ul> <p>이 모든 것들이 하나의 파일로 묶여있어서 배포하기 편합니다.</p> <h3 id="실행-과정-warjar--jvm--jit--cpu">실행 과정: WAR/JAR → JVM → JIT → CPU</h3> <ol> <li>WAR/JAR 파일 실행: 톰캣 같은 서버나 <code class="language-plaintext highlighter-rouge">java -jar</code> 명령어로 실행</li> <li>JVM이 바이트코드 로딩: 압축을 풀고 필요한 클래스들의 바이트코드를 메모리에 올림</li> <li>처음에는 인터프리터로 실행: 바이트코드를 한 줄씩 번역해서 실행</li> <li>JIT이 개입: 자주 실행되는 코드를 발견하면 기계어로 컴파일해서 저장</li> <li>다음부터는 기계어로 직접 실행: 훨씬 빠른 속도로 실행</li> </ol> <hr/> <h2 id="4-jit을-쓰면-뭐가-좋아질까요">4. JIT을 쓰면 뭐가 좋아질까요?</h2> <h3 id="실행-속도가-점점-빨라집니다">실행 속도가 점점 빨라집니다</h3> <p>JIT의 가장 큰 장점은 프로그램이 오래 실행될수록 점점 빨라진다는 것입니다. 마치 새로운 게임을 처음 할 때는 서툴지만, 계속 하다보면 실력이 늘어서 더 빠르게 클리어할 수 있게 되는 것과 같습니다.</p> <h3 id="핫스팟-최적화">핫스팟 최적화</h3> <p>JIT은 “핫스팟”이라는 것을 찾습니다. 이는 자주 실행되어서 “뜨거워진” 코드 부분을 의미합니다. 예를 들어 반복문이 1000번 돌아가는 코드가 있다면, JIT은 “아, 이 부분이 핫스팟이네!“라고 판단하고 최적화합니다.</p> <h3 id="인라인-최적화">인라인 최적화</h3> <p>함수 호출을 줄이는 최적화도 합니다. 원래는 함수를 부르고 결과를 받아오는 과정이 있었다면, JIT은 아예 함수 내용을 그 자리에 직접 넣어버립니다. 마치 “더하기 함수 부르지 말고 그냥 여기서 바로 더해버리자”는 식으로요.</p> <h3 id="루프-최적화">루프 최적화</h3> <p>반복문도 더 효율적으로 만듭니다. 불필요한 검사를 줄이거나, 여러 번 반복되는 계산을 미리 해놓기도 합니다.</p> <h3 id="자주-쓰는-코드는-캐시에-저장">자주 쓰는 코드는 캐시에 저장</h3> <p>JIT은 최적화한 기계어 코드를 메모리에 저장해둡니다. 다음에 같은 코드가 실행될 때는 저장된 기계어를 바로 사용하므로 훨씬 빠릅니다. 마치 자주 먹는 라면을 미리 끓여두고 데워먹는 것과 비슷합니다.</p> <hr/> <h2 id="5-우리가-모르는-사이에-이미-사용-중인-jit">5. 우리가 모르는 사이에 이미 사용 중인 JIT</h2> <h3 id="대부분의-현대-언어가-jit-사용">대부분의 현대 언어가 JIT 사용</h3> <p>놀랍게도 우리가 자주 사용하는 많은 언어들이 JIT을 사용합니다:</p> <ul> <li>Java: HotSpot JVM이나 OpenJ9 같은 JVM들이 JIT 컴파일러를 내장</li> <li>.NET (C#, VB.NET): .NET Runtime이 JIT 컴파일러 사용</li> <li>JavaScript: Chrome의 V8 엔진, Firefox의 SpiderMonkey 등이 JIT 사용</li> <li>Python: PyPy라는 구현체에서 JIT 사용</li> </ul> <p>이 모든 언어에서 JIT이 기본적으로 켜져있어서, 우리는 모르는 사이에 그 혜택을 누리고 있는 겁니다.</p> <h3 id="jit을-끄는-경우는-언제일까요">JIT을 끄는 경우는 언제일까요?</h3> <p>보통은 JIT을 끄지 않지만, 가끔 끄는 경우가 있습니다:</p> <ul> <li> <p><strong>메모리가 극도로 제한된 환경</strong><br/> JIT은 최적화된 코드를 저장하기 위해 추가 메모리를 사용합니다. IoT 기기처럼 메모리가 매우 적은 환경에서는 끄기도 합니다.</p> </li> <li> <p><strong>예측 가능한 성능이 중요한 경우</strong><br/> JIT은 최적화 과정에서 잠깐 성능이 떨어질 수 있습니다. 실시간 시스템처럼 성능 변동이 없어야 하는 경우에는 끄기도 합니다.</p> </li> <li> <p><strong>매우 짧게 실행되는 프로그램</strong><br/> JIT이 최적화할 시간도 없이 금방 끝나는 프로그램에서는 오히려 JIT이 오버헤드가 될 수 있습니다.</p> </li> </ul> <hr/> <h2 id="6-마무리">6. 마무리</h2> <p>JIT 컴파일러는 현대 프로그래밍에서 없어서는 안 될 기술입니다. 우리가 의식하지 못하는 사이에 프로그램을 더 빠르게 만들어주고, 다양한 환경에서 최적화된 성능을 제공해줍니다.</p> <p>다음번에 Java나 JavaScript로 개발할 때, “아, 지금 JIT이 내 코드를 더 빠르게 만들어주고 있구나!“라고 생각해보세요. 여러분의 프로그램 뒤에서 열심히 일하고 있는 JIT 컴파일러에게 감사의 마음을 가져보는 것도 좋을 것 같습니다.</p>]]></content><author><name></name></author><category term="java,"/><category term="컴파일러"/><category term="java,"/><category term="컴파일러"/><summary type="html"><![CDATA[JIT(Just-In-Time) 컴파일러가 어떻게 자바 프로그램의 실행 속도를 런타임 중에 극적으로 향상시키는지 궁금하신가요? 바이트코드부터 JVM의 역할, 핫스팟 최적화까지, 개발자라면 꼭 알아야 할 JIT 컴파일러의 동작 원리와 장점을 명확하게 설명합니다.]]></summary></entry><entry><title type="html">CQRS 패턴으로 데이터베이스 성능 문제를 해결해보자</title><link href="https://hwangrolee.github.io/blog/CQRS-%ED%8C%A8%ED%84%B4%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%B4%EB%B3%B4%EC%9E%90/" rel="alternate" type="text/html" title="CQRS 패턴으로 데이터베이스 성능 문제를 해결해보자"/><published>2025-08-08T02:00:00+00:00</published><updated>2025-08-08T02:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/CQRS-%ED%8C%A8%ED%84%B4%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%B4%EB%B3%B4%EC%9E%90</id><content type="html" xml:base="https://hwangrolee.github.io/blog/CQRS-%ED%8C%A8%ED%84%B4%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%B4%EB%B3%B4%EC%9E%90/"><![CDATA[<p>“왜 우리 시스템은 사용자가 몇 명만 늘어나도 이렇게 느려지는 걸까?”</p> <p>이런 고민을 해본 적이 있다면, 아마도 <strong>테이블 락(Table Lock)</strong> 문제를 겪고 있을 가능성이 높습니다. 오늘은 CQRS라는 패턴이 어떻게 이런 문제를 해결할 수 있는지 차근차근 알아보겠습니다.</p> <h2 id="cqrs가-뭔가요">CQRS가 뭔가요?</h2> <p><strong>CQRS(Command Query Responsibility Segregation)</strong>는 간단히 말해 “데이터를 읽는 것”과 “데이터를 변경하는 것”을 분리하는 패턴입니다.</p> <ul> <li><strong>Command (명령)</strong>: 데이터를 생성, 수정, 삭제하는 작업</li> <li><strong>Query (조회)</strong>: 데이터를 읽어오는 작업</li> </ul> <p>기존에는 하나의 코드에서 읽기와 쓰기를 모두 처리했다면, CQRS에서는 이 두 가지를 완전히 분리합니다.</p> <hr/> <h2 id="테이블-락이-뭐고-왜-문제가-될까요">테이블 락이 뭐고, 왜 문제가 될까요?</h2> <h3 id="테이블-락이란">테이블 락이란?</h3> <p>데이터베이스에서 동시에 여러 작업이 같은 데이터에 접근할 때, 데이터 일관성을 보장하기 위해 “잠시 기다려!”라고 말하는 메커니즘입니다.</p> <h3 id="실제-상황으로-이해해보기">실제 상황으로 이해해보기</h3> <p>온라인 쇼핑몰을 운영한다고 가정해봅시다:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>오후 2시: 관리자가 전체 상품 재고 현황 보고서를 조회합니다 (30초 소요)
오후 2시 5초: 고객 A가 상품을 주문합니다
오후 2시 7초: 고객 B가 같은 상품을 주문합니다
오후 2시 10초: 고객 C가 또 다른 상품을 주문합니다
</code></pre></div></div> <p><strong>문제 상황</strong>: 재고 현황 보고서 조회가 30초 동안 실행되는 동안, 모든 주문 처리가 대기 상태가 됩니다. 고객들은 “주문하기” 버튼을 눌러도 아무 반응이 없어 답답해합니다.</p> <h3 id="왜-이런-일이-발생하나요">왜 이런 일이 발생하나요?</h3> <p>기존 방식에서는 다음과 같은 작업들이 모두 같은 테이블에 락을 걸기 때문입니다:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 관리자의 복잡한 보고서 쿼리 (30초 소요)</span>
<span class="k">SELECT</span>
    <span class="n">p</span><span class="p">.</span><span class="n">product_name</span><span class="p">,</span>
    <span class="n">p</span><span class="p">.</span><span class="n">price</span><span class="p">,</span>
    <span class="n">i</span><span class="p">.</span><span class="n">current_stock</span><span class="p">,</span>
    <span class="n">s</span><span class="p">.</span><span class="n">supplier_name</span><span class="p">,</span>
    <span class="k">c</span><span class="p">.</span><span class="n">category_name</span><span class="p">,</span>
    <span class="k">AVG</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">rating</span><span class="p">)</span> <span class="k">as</span> <span class="n">avg_rating</span>
<span class="k">FROM</span> <span class="n">products</span> <span class="n">p</span>
<span class="k">JOIN</span> <span class="n">inventory</span> <span class="n">i</span> <span class="k">ON</span> <span class="n">p</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">product_id</span>
<span class="k">JOIN</span> <span class="n">suppliers</span> <span class="n">s</span> <span class="k">ON</span> <span class="n">p</span><span class="p">.</span><span class="n">supplier_id</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">id</span>
<span class="k">JOIN</span> <span class="n">categories</span> <span class="k">c</span> <span class="k">ON</span> <span class="n">p</span><span class="p">.</span><span class="n">category_id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">id</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="n">r</span> <span class="k">ON</span> <span class="n">p</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">product_id</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">p</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">product_name</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">price</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">current_stock</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">supplier_name</span><span class="p">,</span> <span class="k">c</span><span class="p">.</span><span class="n">category_name</span><span class="p">;</span>

<span class="c1">-- 고객의 주문 처리 (1초면 충분한데 위 쿼리 때문에 30초 대기)</span>
<span class="k">UPDATE</span> <span class="n">inventory</span> <span class="k">SET</span> <span class="n">current_stock</span> <span class="o">=</span> <span class="n">current_stock</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">WHERE</span> <span class="n">product_id</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">orders</span> <span class="p">(</span><span class="n">customer_id</span><span class="p">,</span> <span class="n">product_id</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">123</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div> <hr/> <h2 id="cqrs가-이-문제를-어떻게-해결하나요">CQRS가 이 문제를 어떻게 해결하나요?</h2> <h3 id="해결의-핵심-아이디어">해결의 핵심 아이디어</h3> <p>CQRS는 읽기와 쓰기를 완전히 분리해서, <strong>읽기 작업이 쓰기 작업을 방해하지 않도록</strong> 만듭니다.</p> <h3 id="1-읽기-전용-모델-query-model">1. 읽기 전용 모델 (Query Model)</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 기존 방식 - 읽기와 쓰기가 섞여있음</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ProductDto</span> <span class="nf">getProduct</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 복잡한 조회 로직</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateStock</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">,</span> <span class="kt">int</span> <span class="n">quantity</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 재고 업데이트 로직</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// CQRS 적용 - 읽기만 담당</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductQueryService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ProductDto</span> <span class="nf">getProduct</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 조회에만 최적화된 로직</span>
        <span class="c1">// 데이터를 변경하지 않음을 명시</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">ProductReportDto</span><span class="o">&gt;</span> <span class="nf">getInventoryReport</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 복잡한 보고서도 읽기 전용으로 처리</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="2-쓰기-전용-모델-command-model">2. 쓰기 전용 모델 (Command Model)</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// CQRS 적용 - 쓰기만 담당</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductCommandService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateStock</span><span class="o">(</span><span class="nc">UpdateStockCommand</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 재고 변경에만 집중</span>
        <span class="c1">// 최소한의 데이터만 업데이트</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createOrder</span><span class="o">(</span><span class="nc">CreateOrderCommand</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 주문 생성에만 집중</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="cqrs의-구체적인-이점들">CQRS의 구체적인 이점들</h2> <h3 id="이점-1-읽기-작업이-쓰기를-방해하지-않음">이점 1: 읽기 작업이 쓰기를 방해하지 않음</h3> <p><strong>기존 방식</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[복잡한 보고서 조회] ──── 테이블 락 ──── [간단한 주문 처리 대기 😢]
     30초 소요                               30초 대기
</code></pre></div></div> <p><strong>CQRS 적용 후</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[복잡한 보고서 조회] ──── 읽기 전용 ──── [락 없음]
     30초 소요

[간단한 주문 처리] ──── 쓰기 전용 ──── [즉시 처리 😊]
     1초 소요
</code></pre></div></div> <h3 id="이점-2-각각의-목적에-최적화된-코드">이점 2: 각각의 목적에 최적화된 코드</h3> <p><strong>읽기 최적화</strong>:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 보고서용 전용 뷰 또는 테이블</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">product_report_view</span>
<span class="k">WHERE</span> <span class="n">stock_level</span> <span class="o">=</span> <span class="s1">'LOW'</span><span class="p">;</span>
<span class="c1">-- 미리 계산된 데이터로 빠른 조회</span>
</code></pre></div></div> <p><strong>쓰기 최적화</strong>:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 필요한 컬럼만 업데이트</span>
<span class="k">UPDATE</span> <span class="n">inventory</span>
<span class="k">SET</span> <span class="n">current_stock</span> <span class="o">=</span> <span class="n">current_stock</span> <span class="o">-</span> <span class="o">?</span>
<span class="k">WHERE</span> <span class="n">product_id</span> <span class="o">=</span> <span class="o">?</span><span class="p">;</span>
<span class="c1">-- 최소한의 작업으로 빠른 처리</span>
</code></pre></div></div> <h3 id="이점-3-트랜잭션-최적화로-동시-처리-능력-대폭-향상">이점 3: 트랜잭션 최적화로 동시 처리 능력 대폭 향상</h3> <p><strong>시나리오</strong>: 100명의 사용자가 동시에 접속</p> <p><strong>기존 방식의 트랜잭션 처리</strong>:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleRequest</span><span class="o">(</span><span class="nc">Request</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 😱 모든 요청이 하나의 긴 트랜잭션으로 처리</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">isRead</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">processComplexQuery</span><span class="o">();</span> <span class="c1">// 30초</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">processSimpleUpdate</span><span class="o">();</span> <span class="c1">// 0.1초</span>
    <span class="o">}</span>
    <span class="c1">// 결과: 1명이 보고서 보면 99명이 30초 대기</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>CQRS 적용 후 트랜잭션 처리</strong>:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 읽기 전용 - 락 없는 동시 처리</span>
<span class="nd">@Transactional</span><span class="o">(</span><span class="n">readOnly</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleQuery</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">processComplexQuery</span><span class="o">();</span> <span class="c1">// 30초이지만 락 없음</span>
    <span class="c1">// ✅ 100명이 동시에 보고서 조회 가능</span>
<span class="o">}</span>

<span class="c1">// 쓰기 전용 - 짧은 락으로 빠른 처리</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleCommand</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">processSimpleUpdate</span><span class="o">();</span> <span class="c1">// 0.1초 락</span>
    <span class="c1">// ✅ 서로 다른 데이터면 100명이 동시에 업데이트 가능</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>결과 비교</strong>:</p> <ul> <li>기존: 순차 처리 (100 × 30초 = 50분)</li> <li>CQRS: 동시 처리 (최대 30초)</li> </ul> <h3 id="이점-4-코드-복잡도-감소">이점 4: 코드 복잡도 감소</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 기존 방식 - 하나의 메서드에서 모든 걸 처리</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ProductResponse</span> <span class="nf">handleProduct</span><span class="o">(</span><span class="nc">ProductRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">isReadOperation</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 복잡한 조회 로직</span>
            <span class="c1">// + 권한 체크</span>
            <span class="c1">// + 캐싱 로직</span>
            <span class="c1">// + 데이터 변환 로직</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 복잡한 쓰기 로직</span>
            <span class="c1">// + 유효성 검증</span>
            <span class="c1">// + 비즈니스 규칙 적용</span>
            <span class="c1">// + 트랜잭션 처리</span>
        <span class="o">}</span>
        <span class="c1">// 이 메서드는 너무 많은 책임을 가짐</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// CQRS 적용 - 각자의 책임에만 집중</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductQueryService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ProductDto</span> <span class="nf">getProduct</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 조회와 데이터 변환에만 집중</span>
        <span class="c1">// 코드가 단순하고 이해하기 쉬움</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductCommandService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateProduct</span><span class="o">(</span><span class="nc">UpdateProductCommand</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 데이터 변경에만 집중</span>
        <span class="c1">// 비즈니스 로직이 명확함</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="실제-적용해보기">실제 적용해보기</h2> <h3 id="단계-1-현재-코드-분석하기">단계 1: 현재 코드 분석하기</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 현재 이런 코드가 있다면?</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">OrderDto</span> <span class="nf">getOrder</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>           <span class="c1">// 읽기</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderDto</span><span class="o">&gt;</span> <span class="nf">getOrderList</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>        <span class="c1">// 읽기</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createOrder</span><span class="o">(</span><span class="nc">OrderDto</span> <span class="n">dto</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>       <span class="c1">// 쓰기</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateOrder</span><span class="o">(</span><span class="nc">OrderDto</span> <span class="n">dto</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>       <span class="c1">// 쓰기</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancelOrder</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>            <span class="c1">// 쓰기</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="단계-2-읽기와-쓰기-분리하기">단계 2: 읽기와 쓰기 분리하기</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 읽기 전용 서비스</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderQueryService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">OrderDto</span> <span class="nf">getOrder</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderDto</span><span class="o">&gt;</span> <span class="nf">getOrderList</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    <span class="c1">// 읽기만 하고 데이터를 변경하지 않음</span>
<span class="o">}</span>

<span class="c1">// 쓰기 전용 서비스</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCommandService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createOrder</span><span class="o">(</span><span class="nc">CreateOrderCommand</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateOrder</span><span class="o">(</span><span class="nc">UpdateOrderCommand</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancelOrder</span><span class="o">(</span><span class="nc">CancelOrderCommand</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    <span class="c1">// 쓰기만 하고 복잡한 조회는 하지 않음</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="단계-3-컨트롤러에서-적절히-사용하기">단계 3: 컨트롤러에서 적절히 사용하기</h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderController</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">OrderQueryService</span> <span class="n">queryService</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">OrderCommandService</span> <span class="n">commandService</span><span class="o">;</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/orders/{id}"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">OrderDto</span> <span class="nf">getOrder</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">queryService</span><span class="o">.</span><span class="na">getOrder</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>  <span class="c1">// 읽기 전용</span>
    <span class="o">}</span>

    <span class="nd">@PostMapping</span><span class="o">(</span><span class="s">"/orders"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createOrder</span><span class="o">(</span><span class="nd">@RequestBody</span> <span class="nc">CreateOrderCommand</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">commandService</span><span class="o">.</span><span class="na">createOrder</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>  <span class="c1">// 쓰기 전용</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="주의사항과-팁">주의사항과 팁</h2> <h3 id="언제-cqrs를-써야-할까">언제 CQRS를 써야 할까?</h3> <ul> <li>복잡한 조회 쿼리가 많은 시스템</li> <li>동시 사용자가 많은 시스템</li> <li>읽기와 쓰기 패턴이 다른 시스템</li> </ul> <h3 id="언제-cqrs가-오버엔지니어링일까">언제 CQRS가 오버엔지니어링일까?</h3> <ul> <li>사용자가 적고 단순한 시스템</li> <li>읽기와 쓰기가 1:1 매칭되는 단순한 CRUD</li> <li>성능 문제가 없는 시스템</li> </ul> <hr/> <h2 id="마무리">마무리</h2> <p>CQRS는 복잡해 보이지만, 핵심은 단순합니다. <strong>“읽는 것”과 “변경하는 것”을 분리하여 서로 방해하지 않게 만드는 것</strong>입니다.</p> <p>테이블 락 때문에 성능 문제를 겪고 있다면, CQRS 패턴을 적용해보세요. 사용자들이 더 이상 “왜 이렇게 느려?”라고 묻지 않을 것입니다.</p> <p>시작은 작은 기능 하나부터! 가장 성능 문제가 심한 부분부터 CQRS를 적용해보시면 됩니다.</p>]]></content><author><name></name></author><category term="개발방법론"/><category term="개발방법론"/><summary type="html"><![CDATA[사용자가 늘어날수록 시스템이 느려지는 '테이블 락' 문제로 고민하시나요? CQRS 패턴을 통해 데이터의 읽기와 쓰기를 분리하여 데이터베이스 성능을 획기적으로 개선하는 방법을 알아보세요. 실제 코드 예시와 함께 개발자들이 겪는 동시성 문제를 해결하는 명확한 가이드를 제공합니다.]]></summary></entry><entry><title type="html">CQRS 패턴, 읽기와 쓰기 분리로 애플리케이션 성능 극대화하기</title><link href="https://hwangrolee.github.io/blog/CQRS-%ED%8C%A8%ED%84%B4-%EC%9D%BD%EA%B8%B0%EC%99%80-%EC%93%B0%EA%B8%B0-%EB%B6%84%EB%A6%AC%EB%A1%9C-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%B1%EB%8A%A5-%EA%B7%B9%EB%8C%80%ED%99%94%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="CQRS 패턴, 읽기와 쓰기 분리로 애플리케이션 성능 극대화하기"/><published>2025-08-08T01:00:00+00:00</published><updated>2025-08-08T01:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/CQRS-%ED%8C%A8%ED%84%B4-%EC%9D%BD%EA%B8%B0%EC%99%80-%EC%93%B0%EA%B8%B0-%EB%B6%84%EB%A6%AC%EB%A1%9C-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%B1%EB%8A%A5-%EA%B7%B9%EB%8C%80%ED%99%94%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/CQRS-%ED%8C%A8%ED%84%B4-%EC%9D%BD%EA%B8%B0%EC%99%80-%EC%93%B0%EA%B8%B0-%EB%B6%84%EB%A6%AC%EB%A1%9C-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%B1%EB%8A%A5-%EA%B7%B9%EB%8C%80%ED%99%94%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="cqrs란-무엇인가요-현장-경험으로-설명드립니다">CQRS란 무엇인가요? 현장 경험으로 설명드립니다</h2> <p>개발을 하다 보면 가장 자주 마주치는 고민이 하나 있습니다. “왜 우리 시스템은 사용자가 늘어날수록 점점 느려질까요?”</p> <p>CQRS(Command and Query Responsibility Segregation)는 이런 고민에 대한 명쾌한 답 중 하나입니다. 복잡하게 들리지만, 핵심은 매우 단순합니다. 데이터를 “변경하는 일”과 “읽는 일”을 완전히 분리해서 각각 최적화하자는 것입니다.</p> <p>마치 음식점에서 주방(요리 만들기)과 홀(서빙하기)을 분리하는 것과 같습니다. 각자의 역할에 집중할 수 있어 전체적인 효율이 크게 향상됩니다.</p> <h2 id="기존-방식의-근본적인-문제점">기존 방식의 근본적인 문제점</h2> <p>대부분의 개발팀이 처음에는 하나의 서비스로 모든 작업을 처리합니다. 이는 초기에는 매우 합리적인 선택입니다. 코드가 간단하고, 이해하기 쉽고, 빠르게 개발할 수 있기 때문입니다.</p> <p>하지만 현실에서는 예상치 못한 일이 벌어집니다. 실제 서비스를 운영해보면 읽기와 쓰기의 비율이 극도로 불균형합니다. 쇼핑몰의 경우 상품을 보는 사람은 천 명인데, 실제 구매하는 사람은 열 명 정도입니다. 뉴스 사이트라면 더 극단적입니다. 기사를 읽는 사람은 수만 명인데, 기사를 작성하는 기자는 몇 명에 불과합니다.</p> <h3 id="데이터베이스의-딜레마">데이터베이스의 딜레마</h3> <p>데이터베이스 관리자라면 누구나 경험하는 딜레마가 있습니다. 조회를 빠르게 하려면 인덱스를 많이 만들어야 하는데, 인덱스가 많을수록 데이터를 추가하거나 수정할 때 더 오래 걸립니다.</p> <p>이는 마치 도서관에서 책을 빨리 찾기 위해 분류 체계를 복잡하게 만들수록, 새 책을 정리하는 데 더 많은 시간이 걸리는 것과 같습니다.</p> <h3 id="복잡성의-악순환">복잡성의 악순환</h3> <p>시간이 지나면서 하나의 서비스 안에 점점 더 많은 기능이 들어갑니다. 주문을 생성하는 로직, 주문을 수정하는 로직, 주문 목록을 보여주는 로직, 매출 통계를 계산하는 로직까지… 모든 것이 한 곳에 섞여있게 됩니다.</p> <p>결국 새로운 기능을 추가하거나 기존 기능을 수정할 때마다 “혹시 다른 기능에 영향을 주지 않을까?”라는 걱정을 하게 됩니다. 이는 개발 속도를 크게 저하시키는 주요 원인이 됩니다.</p> <h2 id="cqrs가-문제를-해결하는-방법">CQRS가 문제를 해결하는 방법</h2> <h3 id="1-각자의-역할에-집중">1. 각자의 역할에 집중</h3> <p>CQRS에서는 명령(Command) 영역과 조회(Query) 영역이 각자의 전문 분야에만 집중합니다.</p> <p><strong>명령 영역의 특징:</strong></p> <ul> <li>비즈니스 규칙 검증에 집중</li> <li>데이터 일관성 보장이 최우선</li> <li>복잡한 계산과 로직 처리</li> <li>처리 결과는 단순함 (성공/실패 여부)</li> </ul> <p><strong>조회 영역의 특징:</strong></p> <ul> <li>오직 데이터를 빠르게 가져오는 것에만 집중</li> <li>복잡한 비즈니스 로직 없음</li> <li>사용자 화면에 맞는 형태로 데이터 가공</li> <li>다양한 형태의 리포트와 통계 제공</li> </ul> <h3 id="2-데이터-구조의-최적화">2. 데이터 구조의 최적화</h3> <p>가장 놀라운 변화는 데이터 저장 방식입니다.</p> <p><strong>쓰기용 데이터베이스:</strong> 정교한 비즈니스 규칙을 지키기 위해 정규화된 구조를 유지합니다. 데이터의 정확성과 일관성이 가장 중요하므로, 필요한 제약조건과 관계를 모두 설정합니다.</p> <p><strong>읽기용 데이터베이스:</strong> 사용자가 보는 화면에 최적화된 구조로 설계합니다. 고객 이름, 상품명, 총 금액 등 화면에서 필요한 모든 정보를 미리 계산해서 하나의 테이블에 저장해둡니다. 마치 미리 만들어둔 요약본을 읽는 것처럼 빠릅니다.</p> <h3 id="3-성능-개선의-실제-효과">3. 성능 개선의 실제 효과</h3> <p><strong>조회 성능 혁신:</strong> 복잡한 JOIN 쿼리가 사라지면서 응답 시간이 극적으로 개선됩니다. 실제 프로젝트에서 500ms 걸리던 주문 상세 조회가 50ms로 단축되는 것을 여러 번 경험했습니다. 이는 단순히 10배 빠른 것이 아니라, 사용자 경험 자체를 바꾸는 수준의 개선입니다.</p> <p><strong>쓰기 성능 안정화:</strong> 읽기를 위한 복잡한 인덱스에서 해방되면서, 데이터 생성과 수정 작업이 안정적이고 예측 가능해집니다. 트래픽이 급증하는 상황에서도 핵심 비즈니스 로직은 영향받지 않고 정상 동작합니다.</p> <p><strong>확장성의 혁명:</strong> 읽기 서버와 쓰기 서버를 독립적으로 관리할 수 있다는 것은 엄청난 장점입니다. 블랙프라이데이처럼 조회 트래픽이 급증하는 상황에서는 읽기 서버만 추가로 띄우면 됩니다. 반대로 대량의 데이터 처리가 필요한 배치 작업 시에는 쓰기 서버의 성능만 강화하면 됩니다.</p> <h2 id="실무에서-검증된-폴더-구조">실무에서 검증된 폴더 구조</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/main/java/com/example/ecommerce/
├── controller/
│   ├── OrderCommandController.java    # 쓰기 API
│   └── OrderQueryController.java      # 읽기 API
├── service/
│   ├── command/
│   │   └── OrderCommandService.java
│   └── query/
│       └── OrderQueryService.java
├── repository/
│   ├── command/
│   │   └── OrderRepository.java
│   └── query/
│       └── OrderQueryRepository.java
├── dto/
│   ├── command/
│   │   └── CreateOrderRequest.java
│   └── query/
│       └── OrderSummaryDto.java
└── event/
    └── OrderCreatedEvent.java
</code></pre></div></div> <h2 id="핵심-구현-포인트">핵심 구현 포인트</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 명령 서비스: 비즈니스 로직에 집중</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCommandService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createOrder</span><span class="o">(</span><span class="nc">CreateOrderRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 1. 비즈니스 규칙 검증</span>
        <span class="c1">// 2. 데이터 저장</span>
        <span class="c1">// 3. 이벤트 발행 (조회 모델 동기화용)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 조회 서비스: 빠른 데이터 제공에 집중</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderQueryService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">OrderSummaryDto</span> <span class="nf">getOrderSummary</span><span class="o">(</span><span class="nc">Long</span> <span class="n">orderId</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// JOIN 없는 단순 조회로 최고 성능 달성</span>
        <span class="k">return</span> <span class="n">orderQueryRepository</span><span class="o">.</span><span class="na">findSummaryById</span><span class="o">(</span><span class="n">orderId</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="언제-cqrs를-도입해야-할까요">언제 CQRS를 도입해야 할까요?</h2> <p>실무에서의 경험을 바탕으로 말씀드리면, CQRS는 다음과 같은 상황에서 빛을 발합니다:</p> <p><strong>즉시 적용을 고려해야 하는 경우:</strong> 읽기 작업이 쓰기 작업보다 10배 이상 많은 시스템, 복잡한 리포팅과 대시보드가 필요한 시스템, 사용자 수가 급격히 증가하고 있는 시스템입니다.</p> <p><strong>신중하게 판단해야 하는 경우:</strong> 팀 규모가 5명 이하로 작거나, 시스템이 아직 단순한 CRUD 수준이거나, 읽기와 쓰기 비율이 비슷한 시스템에서는 섣불리 도입하지 않는 것이 좋습니다.</p> <h2 id="마무리-선택이-아닌-필수가-되는-순간">마무리: 선택이 아닌 필수가 되는 순간</h2> <p>CQRS는 복잡성을 추가하는 패턴입니다. 하지만 적절한 시점에 도입하면, 그 복잡성을 상쇄하고도 남을 만큼 큰 가치를 제공합니다.</p> <p>시스템이 성장하면서 성능 문제와 복잡성 문제에 직면하고 있다면, CQRS는 선택이 아닌 필수가 될 수 있습니다. 다만, 팀의 역량과 시스템의 특성을 신중히 고려하여 도입 시점을 결정하시기 바랍니다.</p> <p>기술은 문제를 해결하는 도구입니다. CQRS라는 도구가 여러분의 문제 해결에 적합한지 충분히 검토해보시고, 필요하다면 과감하게 도전해보시기 바랍니다.</p>]]></content><author><name></name></author><category term="개발방법론"/><category term="개발방법론"/><summary type="html"><![CDATA[CQRS 패턴으로 애플리케이션 성능을 10배 향상시키는 방법을 알아보세요. 읽기와 쓰기 분리로 데이터베이스 병목현상을 해결하고, Spring Boot에서 바로 적용할 수 있는 실무 폴더 구조와 구현 방법을 상세히 설명합니다.]]></summary></entry><entry><title type="html">현재 상태만 저장하지 말고 모든 변화를 기록하라, 이벤트소싱으로 데이터 히스토리 완벽 관리하기</title><link href="https://hwangrolee.github.io/blog/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%86%8C%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC-%EC%99%84%EB%B2%BD-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="현재 상태만 저장하지 말고 모든 변화를 기록하라, 이벤트소싱으로 데이터 히스토리 완벽 관리하기"/><published>2025-08-08T00:00:00+00:00</published><updated>2025-08-08T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%86%8C%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC-%EC%99%84%EB%B2%BD-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%86%8C%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC-%EC%99%84%EB%B2%BD-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/"><![CDATA[<blockquote> <p>“데이터베이스에 현재 상태만 저장하는 게 당연하다고 생각했다면, 이 글을 끝까지 읽어보세요.”</p> </blockquote> <h2 id="들어가며-왜-이벤트소싱을-알아야-할까요">들어가며: 왜 이벤트소싱을 알아야 할까요?</h2> <p>주니어 개발자 시절, 저는 항상 이런 의문이 있었습니다.</p> <ul> <li> <p><em>“계좌 잔액이 10만 원인 건 알겠는데, 이 돈이 언제 어떻게 들어왔는지는 왜 따로 관리해야 하지?”</em></p> </li> <li> <p><em>“사용자 프로필이 변경됐을 때, 이전 상태는 왜 날려버리는 거지?”</em></p> </li> </ul> <p>바로 이런 의문에서 시작되는 것이 <strong>이벤트소싱(Event Sourcing)</strong>입니다.</p> <hr/> <h2 id="1-이벤트소싱이란--동영상-vs-스냅샷의-차이">1. 이벤트소싱이란? — 동영상 vs 스냅샷의 차이</h2> <h3 id="전통적인-방식-스냅샷-저장"><strong>전통적인 방식: 스냅샷 저장</strong></h3> <p>대부분의 시스템은 데이터의 <strong>현재 상태</strong>만 저장합니다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 일반적인 계좌 테이블</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">accounts</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">BIGINT</span><span class="p">,</span>
    <span class="n">balance</span> <span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>  <span class="c1">-- 현재 잔액만 저장</span>
<span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">accounts</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100000</span><span class="p">);</span>
<span class="c1">-- 10만 원이 있다는 것만 알 수 있음</span>
</code></pre></div></div> <p>이는 마치 <strong>현재 모습의 사진 한 장</strong>만 저장하는 것과 같습니다.</p> <h3 id="이벤트소싱-방식-모든-변화-기록"><strong>이벤트소싱 방식: 모든 변화 기록</strong></h3> <p>이벤트소싱은 <strong>지금까지 일어난 모든 사건(이벤트)</strong>을 순서대로 저장합니다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 이벤트소싱 방식</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">account_events</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">BIGINT</span><span class="p">,</span>
    <span class="n">account_id</span> <span class="nb">BIGINT</span><span class="p">,</span>
    <span class="n">event_type</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
    <span class="n">amount</span> <span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
    <span class="nb">timestamp</span> <span class="nb">TIMESTAMP</span><span class="p">,</span>
    <span class="n">event_data</span> <span class="n">JSON</span>
<span class="p">);</span>

<span class="c1">-- 실제 저장되는 이벤트들</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">account_events</span> <span class="k">VALUES</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">'AccountCreated'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">'2025-08-01 09:00:00'</span><span class="p">,</span> <span class="s1">'{"initial_balance": 0}'</span><span class="p">),</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">'MoneyDeposited'</span><span class="p">,</span> <span class="mi">50000</span><span class="p">,</span> <span class="s1">'2025-08-01 10:30:00'</span><span class="p">,</span> <span class="s1">'{"source": "salary"}'</span><span class="p">),</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">'MoneyDeposited'</span><span class="p">,</span> <span class="mi">30000</span><span class="p">,</span> <span class="s1">'2025-08-05 14:20:00'</span><span class="p">,</span> <span class="s1">'{"source": "bonus"}'</span><span class="p">),</span>
<span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">'MoneyDeposited'</span><span class="p">,</span> <span class="mi">20000</span><span class="p">,</span> <span class="s1">'2025-08-07 16:45:00'</span><span class="p">,</span> <span class="s1">'{"source": "refund"}'</span><span class="p">);</span>
</code></pre></div></div> <p>현재 잔액을 알고 싶다면? <strong>이벤트들을 순서대로 재생</strong>하면 됩니다.</p> <ul> <li>0 + 50,000 + 30,000 + 20,000 = <strong>100,000원</strong></li> </ul> <p>이는 <strong>처음부터 지금까지의 모든 동영상</strong>을 저장하는 것과 같습니다.</p> <hr/> <h2 id="2-왜-필요한가요--실무에서-마주치는-문제들">2. 왜 필요한가요? — 실무에서 마주치는 문제들</h2> <h3 id="시나리오-1-고객-문의-상황"><strong>시나리오 1: 고객 문의 상황</strong></h3> <blockquote> <p><em>“어? 제 계좌에서 3만 원이 사라졌어요. 언제 어떻게 빠진 건가요?”</em></p> </blockquote> <p><strong>전통적인 방식의 한계:</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">balance</span> <span class="k">FROM</span> <span class="n">accounts</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="c1">-- 결과: 70000</span>
<span class="c1">-- 3만 원이 줄어든 건 맞는데... 언제? 왜?</span>
</code></pre></div></div> <p><strong>이벤트소싱의 답:</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">account_events</span> <span class="k">WHERE</span> <span class="n">account_id</span> <span class="o">=</span> <span class="mi">100</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="nb">timestamp</span><span class="p">;</span>
<span class="c1">-- 2025-08-10 15:30:00: MoneyWithdrawn, -30000, {"reason": "ATM_withdrawal", "location": "강남역"}</span>
<span class="c1">-- 명확한 추적 가능!</span>
</code></pre></div></div> <h3 id="시나리오-2-버그-발생-시-복구"><strong>시나리오 2: 버그 발생 시 복구</strong></h3> <p>시스템 버그로 인해 2025년 8월 8일부터 잘못된 계산이 적용되었다면?</p> <p><strong>전통적인 방식:</strong></p> <ul> <li>현재 상태만 있으므로 <strong>복구 불가능</strong></li> <li>백업에서 복원해야 함 (데이터 손실 발생)</li> </ul> <p><strong>이벤트소싱 방식:</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 8월 7일까지의 이벤트만 재생하여 올바른 상태로 복구</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Event</span><span class="o">&gt;</span> <span class="n">eventsUntilAugust7</span> <span class="o">=</span> <span class="n">getEventsUntil</span><span class="o">(</span><span class="s">"2025-08-07"</span><span class="o">);</span>
<span class="nc">AccountState</span> <span class="n">correctState</span> <span class="o">=</span> <span class="n">replayEvents</span><span class="o">(</span><span class="n">eventsUntilAugust7</span><span class="o">);</span>
</code></pre></div></div> <hr/> <h2 id="3-핵심-개념-정리">3. 핵심 개념 정리</h2> <h3 id="이벤트event"><strong>이벤트(Event)</strong></h3> <blockquote> <p><em>시스템에서 발생한 의미있는 사건</em></p> </blockquote> <ul> <li><strong>과거형으로 표현</strong>: <code class="language-plaintext highlighter-rouge">UserRegistered</code>, <code class="language-plaintext highlighter-rouge">OrderPlaced</code>, <code class="language-plaintext highlighter-rouge">PaymentCompleted</code></li> <li><strong>불변(Immutable)</strong>: 한 번 발생한 이벤트는 수정되지 않음</li> <li><strong>시간순 정렬</strong>: 발생 순서가 매우 중요</li> </ul> <h3 id="이벤트-재생event-replay"><strong>이벤트 재생(Event Replay)</strong></h3> <blockquote> <p><em>저장된 이벤트들을 순서대로 실행하여 현재 상태를 복원하는 과정</em></p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AccountAggregate</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">accountId</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">BigDecimal</span> <span class="n">balance</span> <span class="o">=</span> <span class="nc">BigDecimal</span><span class="o">.</span><span class="na">ZERO</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="nc">MoneyDepositedEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">balance</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">balance</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAmount</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="nc">MoneyWithdrawnEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">balance</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">balance</span><span class="o">.</span><span class="na">subtract</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAmount</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="이벤트-스토어event-store"><strong>이벤트 스토어(Event Store)</strong></h3> <blockquote> <p><em>이벤트들을 저장하는 특수한 데이터베이스</em></p> </blockquote> <ul> <li>일반 RDBMS, NoSQL, 또는 전용 Event Store 사용</li> <li><strong>Append-only</strong>: 새로운 이벤트만 추가, 기존 이벤트는 수정/삭제 금지</li> </ul> <hr/> <h2 id="4-장점--왜-복잡해-보이는데-쓸까요">4. 장점 — 왜 복잡해 보이는데 쓸까요?</h2> <h3 id="완벽한-감사-추적audit-trail"><strong>완벽한 감사 추적(Audit Trail)</strong></h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 특정 기간의 모든 거래 내역 조회</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Event</span><span class="o">&gt;</span> <span class="n">transactions</span> <span class="o">=</span> <span class="n">eventStore</span><span class="o">.</span><span class="na">getEvents</span><span class="o">(</span>
    <span class="n">accountId</span><span class="o">,</span>
    <span class="nc">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2025</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span>
    <span class="nc">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2025</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">31</span><span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div> <p><strong>활용 사례:</strong></p> <ul> <li>금융 시스템의 규제 준수</li> <li>게임에서 치팅 방지</li> <li>의료 시스템의 환자 기록 추적</li> </ul> <h3 id="타임머신-기능--과거-상태-재현"><strong>타임머신 기능 — 과거 상태 재현</strong></h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 2025년 8월 5일 시점의 계좌 상태 확인</span>
<span class="nc">AccountState</span> <span class="n">pastState</span> <span class="o">=</span> <span class="n">replayEventsUntil</span><span class="o">(</span><span class="n">accountId</span><span class="o">,</span> <span class="s">"2025-08-05"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"8월 5일 잔액: "</span> <span class="o">+</span> <span class="n">pastState</span><span class="o">.</span><span class="na">getBalance</span><span class="o">());</span>
</code></pre></div></div> <p><strong>실무 활용:</strong></p> <ul> <li>A/B 테스트 결과 분석</li> <li>과거 시점 기준 리포트 생성</li> <li>버그 재현 및 디버깅</li> </ul> <h3 id="자연스러운-이벤트-발행"><strong>자연스러운 이벤트 발행</strong></h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@EventHandler</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">MoneyDepositedEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 다른 서비스에 즉시 알림</span>
    <span class="n">emailService</span><span class="o">.</span><span class="na">sendDepositNotification</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAccountId</span><span class="o">(),</span> <span class="n">event</span><span class="o">.</span><span class="na">getAmount</span><span class="o">());</span>
    <span class="n">loyaltyService</span><span class="o">.</span><span class="na">addPoints</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAccountId</span><span class="o">(),</span> <span class="n">calculatePoints</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAmount</span><span class="o">()));</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>마이크로서비스 환경</strong>에서 서비스 간 데이터 동기화가 자연스럽게 해결됩니다.</p> <hr/> <h2 id="5-단점과-해결책--현실적인-고민들">5. 단점과 해결책 — 현실적인 고민들</h2> <h3 id="데이터-저장소-사용량-증가"><strong>데이터 저장소 사용량 증가</strong></h3> <p><strong>문제:</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 1년간 거래가 많은 계좌의 이벤트</span>
<span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">account_events</span> <span class="k">WHERE</span> <span class="n">account_id</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="c1">-- 결과: 50,000개 이벤트</span>
</code></pre></div></div> <p><strong>해결책: 스냅샷(Snapshot) 기법</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1000개 이벤트마다 스냅샷 생성</span>
<span class="k">if</span> <span class="o">(</span><span class="n">eventCount</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Snapshot</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Snapshot</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">,</span> <span class="n">currentState</span><span class="o">,</span> <span class="n">eventCount</span><span class="o">);</span>
    <span class="n">snapshotStore</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">snapshot</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 상태 복원 시 최신 스냅샷부터 시작</span>
<span class="nc">Snapshot</span> <span class="n">latestSnapshot</span> <span class="o">=</span> <span class="n">snapshotStore</span><span class="o">.</span><span class="na">getLatest</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">);</span>
<span class="nc">AccountState</span> <span class="n">state</span> <span class="o">=</span> <span class="n">latestSnapshot</span><span class="o">.</span><span class="na">getState</span><span class="o">();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Event</span><span class="o">&gt;</span> <span class="n">eventsAfterSnapshot</span> <span class="o">=</span> <span class="n">eventStore</span><span class="o">.</span><span class="na">getEventsAfter</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">,</span> <span class="n">latestSnapshot</span><span class="o">.</span><span class="na">getVersion</span><span class="o">());</span>
<span class="k">return</span> <span class="nf">replayEvents</span><span class="o">(</span><span class="n">state</span><span class="o">,</span> <span class="n">eventsAfterSnapshot</span><span class="o">);</span>
</code></pre></div></div> <h3 id="이벤트-재생-성능-이슈"><strong>이벤트 재생 성능 이슈</strong></h3> <p><strong>문제:</strong> 이벤트가 많아지면 상태 복원이 느려짐</p> <p><strong>해결책:</strong></p> <ol> <li><strong>CQRS 패턴 적용</strong> — 읽기 전용 뷰 모델 분리</li> <li><strong>캐싱</strong> — 자주 조회되는 상태는 메모리에 캐싱</li> <li><strong>이벤트 압축</strong> — 중요하지 않은 중간 이벤트 제거</li> </ol> <h3 id="개발-복잡도-증가"><strong>개발 복잡도 증가</strong></h3> <p><strong>전통적 CRUD:</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateBalance</span><span class="o">(</span><span class="nc">String</span> <span class="n">accountId</span><span class="o">,</span> <span class="nc">BigDecimal</span> <span class="n">newBalance</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">accountRepository</span><span class="o">.</span><span class="na">updateBalance</span><span class="o">(</span><span class="n">accountId</span><span class="o">,</span> <span class="n">newBalance</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>이벤트소싱:</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">deposit</span><span class="o">(</span><span class="nc">String</span> <span class="n">accountId</span><span class="o">,</span> <span class="nc">BigDecimal</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Account</span> <span class="n">account</span> <span class="o">=</span> <span class="n">loadAccount</span><span class="o">(</span><span class="n">accountId</span><span class="o">);</span>
    <span class="nc">MoneyDepositedEvent</span> <span class="n">event</span> <span class="o">=</span> <span class="n">account</span><span class="o">.</span><span class="na">deposit</span><span class="o">(</span><span class="n">amount</span><span class="o">);</span>
    <span class="n">eventStore</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">accountId</span><span class="o">,</span> <span class="n">event</span><span class="o">);</span>
    <span class="n">account</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>해결책:</strong> 프레임워크 활용 (Axon Framework, EventStore 등)</p> <hr/> <h2 id="6-실전-적용-언제-사용하면-좋을까요">6. 실전 적용: 언제 사용하면 좋을까요?</h2> <h3 id="강력-추천-사례"><strong>강력 추천 사례</strong></h3> <h4 id="금융결제-시스템">금융/결제 시스템</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PaymentAggregate</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">PaymentInitiatedEvent</span> <span class="nf">initiatePayment</span><span class="o">(</span><span class="nc">PaymentCommand</span> <span class="n">cmd</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 결제 시작 이벤트</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">PaymentCompletedEvent</span> <span class="nf">completePayment</span><span class="o">(</span><span class="nc">String</span> <span class="n">paymentId</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 결제 완료 이벤트</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">PaymentFailedEvent</span> <span class="nf">failPayment</span><span class="o">(</span><span class="nc">String</span> <span class="n">paymentId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">reason</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 결제 실패 이벤트</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>이유:</strong> 금융 감독 기관의 <strong>추적 가능성</strong> 요구사항을 자연스럽게 만족</p> <h4 id="전자상거래-주문-시스템">전자상거래 주문 시스템</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 주문 생명주기 추적</span>
<span class="nc">OrderCreatedEvent</span> <span class="o">-&gt;</span> <span class="nc">OrderPaidEvent</span> <span class="o">-&gt;</span> <span class="nc">OrderShippedEvent</span> <span class="o">-&gt;</span> <span class="nc">OrderDeliveredEvent</span>
</code></pre></div></div> <p><strong>이유:</strong> 고객 문의 대응과 <strong>배송 추적</strong>이 필수</p> <h4 id="게임-서비스">게임 서비스</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 플레이어 행동 기록</span>
<span class="nc">PlayerJoinedEvent</span> <span class="o">-&gt;</span> <span class="nc">ItemPurchasedEvent</span> <span class="o">-&gt;</span> <span class="nc">LevelUpEvent</span> <span class="o">-&gt;</span> <span class="nc">GameCompletedEvent</span>
</code></pre></div></div> <p><strong>이유:</strong> <strong>치팅 방지</strong>와 <strong>게임 밸런싱</strong> 분석에 활용</p> <h3 id="신중하게-고려해야-할-사례"><strong>신중하게 고려해야 할 사례</strong></h3> <h4 id="단순한-crud-애플리케이션">단순한 CRUD 애플리케이션</h4> <ul> <li>사용자 프로필 관리</li> <li>상품 카탈로그 관리</li> <li>정적 컨텐츠 관리</li> </ul> <p><strong>이유:</strong> 이력 추적의 <strong>비즈니스 가치</strong>가 낮고 <strong>복잡도</strong>만 증가</p> <h4 id="실시간-성능이-중요한-시스템">실시간 성능이 중요한 시스템</h4> <ul> <li>고빈도 거래 시스템 (HFT)</li> <li>실시간 게임 서버</li> <li>IoT 센서 데이터 처리</li> </ul> <p><strong>이유:</strong> 이벤트 재생으로 인한 <strong>지연시간</strong> 문제</p> <hr/> <h2 id="7-실제-구현-예시--spring-boot--jpa">7. 실제 구현 예시 — Spring Boot + JPA</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventEntity</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">aggregateId</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">eventType</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">eventData</span><span class="o">;</span>  <span class="c1">// JSON 형태로 저장</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">occurredAt</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">version</span><span class="o">;</span>  <span class="c1">// 낙관적 락을 위한 버전</span>
<span class="o">}</span>

<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventStore</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EventRepository</span> <span class="n">eventRepository</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">ObjectMapper</span> <span class="n">objectMapper</span><span class="o">;</span>

    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">append</span><span class="o">(</span><span class="nc">String</span> <span class="n">aggregateId</span><span class="o">,</span> <span class="nc">DomainEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">EventEntity</span> <span class="n">entity</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EventEntity</span><span class="o">();</span>
        <span class="n">entity</span><span class="o">.</span><span class="na">setAggregateId</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">);</span>
        <span class="n">entity</span><span class="o">.</span><span class="na">setEventType</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">());</span>
        <span class="n">entity</span><span class="o">.</span><span class="na">setEventData</span><span class="o">(</span><span class="n">objectMapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">event</span><span class="o">));</span>
        <span class="n">entity</span><span class="o">.</span><span class="na">setOccurredAt</span><span class="o">(</span><span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>

        <span class="n">eventRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">entity</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">DomainEvent</span><span class="o">&gt;</span> <span class="nf">getEvents</span><span class="o">(</span><span class="nc">String</span> <span class="n">aggregateId</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">EventEntity</span><span class="o">&gt;</span> <span class="n">entities</span> <span class="o">=</span> <span class="n">eventRepository</span>
            <span class="o">.</span><span class="na">findByAggregateIdOrderByOccurredAt</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">entities</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">deserialize</span><span class="o">)</span>
            <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toList</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="8-마무리-이벤트소싱을-시작하기-전에">8. 마무리: 이벤트소싱을 시작하기 전에</h2> <h3 id="스스로에게-물어보세요"><strong>스스로에게 물어보세요</strong></h3> <ol> <li><strong>“우리 시스템에서 데이터 변경 이력이 중요한가?”</strong> <ul> <li>중요하다면 → 이벤트소싱 고려</li> <li>중요하지 않다면 → 전통적 방식으로 충분</li> </ul> </li> <li><strong>“감사 추적이나 규제 준수가 필요한가?”</strong> <ul> <li>필요하다면 → 이벤트소싱 강력 추천</li> <li>필요없다면 → 다른 아키텍처 패턴 고려</li> </ul> </li> <li><strong>“팀이 복잡도 증가를 감당할 수 있는가?”</strong> <ul> <li>가능하다면 → 점진적 도입</li> <li>어렵다면 → 충분한 학습 후 적용</li> </ul> </li> </ol> <h3 id="시작하기-좋은-방법"><strong>시작하기 좋은 방법</strong></h3> <ol> <li><strong>작은 도메인부터</strong>: 전체 시스템이 아닌 <strong>한 개 도메인</strong>에만 적용</li> <li><strong>프레임워크 활용</strong>: Axon Framework, EventStore 등으로 <strong>러닝커브 단축</strong></li> <li><strong>하이브리드 접근</strong>: 핵심 도메인만 이벤트소싱, 나머지는 전통적 방식</li> </ol> <hr/> <h2 id="한-줄-요약">한 줄 요약</h2> <p><strong>이벤트소싱은 “모든 변화를 기록하여 완벽한 추적성을 제공하는” 아키텍처 패턴입니다.</strong></p> <p>단순한 현재 상태 저장이 아닌 <strong>변화의 역사</strong>를 보존함으로써, 더 강력한 <strong>감사 추적</strong>, <strong>디버깅</strong>, <strong>복구 능력</strong>을 제공합니다.</p> <p>복잡해 보이지만, 비즈니스에 진짜 가치를 제공하는 영역에서는 그 복잡함을 상쇄하고도 남을 만큼 강력한 도구입니다.</p> <p><strong><em>이벤트소싱이 모든 문제의 해답은 아닙니다. 하지만 언제 써야 하고 언제 쓰지 말아야 하는지를 아는 것만으로도 더 나은 아키텍처 결정을 내릴 수 있을 것입니다.</em></strong></p>]]></content><author><name></name></author><category term="개발방법론"/><category term="개발방법론"/><summary type="html"><![CDATA[이벤트소싱 완벽 가이드, 현재 상태만 저장하는 방식의 한계를 벗어나 모든 데이터 변화를 기록하는 아키텍처 패턴. 실무 예제와 Spring Boot 구현 코드로 배우는 Event Sourcing 입문서]]></summary></entry><entry><title type="html">Java 문자열 포맷팅 비교 String.format() vs MessageFormat 성능과 사용법 정리</title><link href="https://hwangrolee.github.io/blog/Java-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%8F%AC%EB%A7%B7%ED%8C%85-%EB%B9%84%EA%B5%90/" rel="alternate" type="text/html" title="Java 문자열 포맷팅 비교 String.format() vs MessageFormat 성능과 사용법 정리"/><published>2025-08-07T00:00:00+00:00</published><updated>2025-08-07T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/Java-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%8F%AC%EB%A7%B7%ED%8C%85-%EB%B9%84%EA%B5%90</id><content type="html" xml:base="https://hwangrolee.github.io/blog/Java-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%8F%AC%EB%A7%B7%ED%8C%85-%EB%B9%84%EA%B5%90/"><![CDATA[<h3 id="1-stringformat-vs-messageformat-소개">1. String.format() vs MessageFormat 소개</h3> <p>Java에서 문자열을 동적으로 조합할 때 가장 많이 사용되는 방법 중 하나가 바로 String.format()입니다. 하지만 국제화(i18n)나 다국어 메시지를 처리할 때는 MessageFormat이라는 또 다른 강력한 도구도 있습니다. 이 두 방식은 비슷해 보이지만, 실제로는 목적과 기능 면에서 상당한 차이를 가지고 있습니다.</p> <h3 id="2-stringformat--간결하고-빠른-문자열포매팅">2. String.format() – 간결하고 빠른 문자열 포매팅</h3> <p>String.format()은 C언어의 printf() 스타일 포맷을 기반으로 하며, 가독성이 좋고 직관적인 방식으로 문자열을 구성할 수 있습니다. 간단한 변수 삽입, 숫자 포맷, 정렬 등이 필요한 경우에 매우 유용합니다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"홍길동"</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">30</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"이름: %s, 나이: %d"</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
<span class="c1">// 출력: 이름: 홍길동, 나이: 30</span>
</code></pre></div></div> <ul> <li>%s, %d, %f 같은 포맷 문자를 사용</li> <li>위치 기반이 아닌 순차적 변수 삽입</li> <li>단순한 텍스트 처리에 적합</li> <li>성능이 좋고 코드가 짧음</li> </ul> <h3 id="3-messageformat--다국어-처리에-강한-국제화-포맷도구">3. MessageFormat – 다국어 처리에 강한 국제화 포맷 도구</h3> <p>반면 MessageFormat은 Java의 국제화(i18n) 지원을 위해 설계된 포맷팅 도구입니다 ResourceBundle과 함께 자주 사용되며, 로케일(Locale)에 따라 날짜, 숫자, 통화 등의 포맷을 자동으로 조정할 수 있습니다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.text.MessageFormat</span><span class="o">;</span>

<span class="nc">String</span> <span class="n">pattern</span> <span class="o">=</span> <span class="s">"이름: {0}, 나이: {1}"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">MessageFormat</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">pattern</span><span class="o">,</span> <span class="s">"홍길동"</span><span class="o">,</span> <span class="mi">30</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
<span class="c1">// 출력: 이름: 홍길동, 나이: 30</span>
</code></pre></div></div> <ul> <li>{0}, {1} 형태의 인덱스 기반 변수 삽입</li> <li>내부적으로 로케일 지원, 날짜/숫자 자동 포맷 가능</li> <li>다국어 메시지 파일과의 궁합이 뛰어남</li> <li>복잡한 메시지 구성이 필요한 경우에 적합</li> </ul> <h3 id="4-언제-어떤-걸-써야할까">4. 언제 어떤 걸 써야 할까?</h3> <ul> <li>빠르고 간단한 문자열 치환만 필요할 때는 String.format()이 훨씬 효율적입니다.</li> <li>로케일에 따라 메시지 포맷이 달라지거나, 메시지를 ResourceBundle로 관리하는 경우에는 MessageFormat이 필수입니다.</li> </ul> <h3 id="5-성능-비교-stringformat-vs-messageformat">5. 성능 비교: String.format() vs MessageFormat</h3> <p>문자열 포맷팅 방식은 실제 애플리케이션에서 반복적으로 호출되는 경우가 많기 때문에, 성능 차이는 무시할 수 없습니다. 이번 섹션에서는 String.format()과 MessageFormat의 실제 성능 차이와 메모리 사용량을 간단히 비교해 보겠습니다.</p> <h4 id="6간단한-벤치마크결과">6.간단한 벤치마크 결과</h4> <table> <thead> <tr> <th>항목</th> <th>String.format()</th> <th>MessageFormat.format()</th> </tr> </thead> <tbody> <tr> <td>평균 실행 시간</td> <td>약 4~6 마이크로초(μs)</td> <td>약 10~15 마이크로초(μs)</td> </tr> <tr> <td>메모리 사용량</td> <td>낮음</td> <td>상대적으로 높음</td> </tr> <tr> <td>GC 발생</td> <td>거의 없음</td> <td>간헐적으로 발생 가능</td> </tr> <tr> <td>특징</td> <td>포맷 분석이 단순하고 빠름</td> <td>포맷 문자열을 파싱하는 과정이 복잡하여 오버헤드 발생</td> </tr> <tr> <td> </td> <td> </td> <td> </td> </tr> </tbody> </table> <ul> <li>단순한 문자열 처리라면 String.format()이 속도와 메모리 면에서 유리합니다.</li> <li>다국어 처리, 로케일 기반 포맷팅이 필요한 경우는 MessageFormat이 적합합니다.</li> <li>두 방식은 성능 차이가 2배 이상 발생할 수 있으므로, 용도에 맞는 선택이 중요합니다.</li> </ul>]]></content><author><name></name></author><category term="자바"/><category term="자바"/><summary type="html"><![CDATA[Java String.format()과 MessageFormat 성능 비교와 사용법 완벽 가이드. 언제 어떤 방식을 선택해야 하는지 벤치마크 결과와 실제 예제로 알아보세요. 국제화 처리부터 최적화까지.]]></summary></entry><entry><title type="html">Java 8 이후 바뀐 자바 문법 총정리 — Java 17까지 꼭 알아야 할 핵심 변화</title><link href="https://hwangrolee.github.io/blog/Java17%EA%B9%8C%EC%A7%80-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%ED%95%B5%EC%8B%AC-%EB%B3%80%ED%99%94/" rel="alternate" type="text/html" title="Java 8 이후 바뀐 자바 문법 총정리 — Java 17까지 꼭 알아야 할 핵심 변화"/><published>2025-08-06T00:00:00+00:00</published><updated>2025-08-06T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/Java17%EA%B9%8C%EC%A7%80-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%ED%95%B5%EC%8B%AC-%EB%B3%80%ED%99%94</id><content type="html" xml:base="https://hwangrolee.github.io/blog/Java17%EA%B9%8C%EC%A7%80-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%ED%95%B5%EC%8B%AC-%EB%B3%80%ED%99%94/"><![CDATA[<p>Java 8은 오랜 기간 동안 자바 개발의 중심이었습니다.</p> <p>람다, 스트림, Optional 등 지금도 널리 쓰이는 기능들이 도입되면서 자바 개발자들에게 새로운 방식의 프로그래밍을 소개했던 버전입니다.</p> <p>하지만 그로부터 벌써 10년이 흘렀고, 자바는 지금도 꾸준히 진화하고 있습니다. 많은 개발자들이 Java 8에 머물러 있는 동안, 자바는 코드 작성 방식, API 설계 방식, 클래스 설계 방식에서 많은 변화를 겪었습니다.</p> <h3 id="java-17이-중요한이유">Java 17이 중요한 이유</h3> <p>가장 큰 이유는 Spring Boot 3.x부터 Java 17 이상을 필수로 요구하기 때문입니다.</p> <p>이제 새로운 프로젝트나 주요 프레임워크를 최신으로 사용하려면 Java 17은 선택이 아니라 기본 전제가 되었습니다.</p> <p>또한 Java 17은 장기 지원(LTS) 버전입니다.</p> <p>Java 11 이후 6년 만에 등장한 LTS 버전으로, 기업 환경에서도 안정적으로 채택되고 있으며 다양한 프레임워크들이 Java 17을 기준으로 개발되고 있습니다.</p> <h3 id="바뀐-건-단순히-버전-숫자만이아닙니다">바뀐 건 단순히 버전 숫자만이 아닙니다</h3> <p><strong><em>Java 9부터 17까지는 단순한 기능 추가나 마이너 개선이 아니라, 자바라는 언어의 방향성과 스타일 자체에 변화가 있었습니다.</em></strong> 기존의 장황한 코딩 방식은 더 이상 필수가 아니며, 이제는 간결하고 읽기 쉬운 코드, 명확한 타입 추론, 안전한 클래스 설계 방식이 주류가 되었습니다.</p> <p>또한 자바는 최근 몇 년간의 변화 속도도 매우 빨라졌습니다. 예전에는 몇 년마다 새 버전이 나왔지만, 이제는 매년 새로운 기능과 개선 사항이 정기적으로 포함되며, 이러한 변화는 자바를 과거의 언어가 아닌 현대적인 언어로 다시 만들어가고 있습니다.</p> <p><strong><em>Java 17을 기준으로 개발 환경이 재편되고 있습니다.</em></strong> 현재 대부분의 주요 프레임워크와 라이브러리는 Java 17을 기준으로 작동하거나, 그 이상을 요구하고 있습니다. 예를 들어 Spring Boot 3, Hibernate 6 등의 프레임워크는 Java 17 이상에서 개발 및 테스트되고 있으며, 이전 버전의 자바에서는 호환되지 않거나 일부 기능을 쓸 수 없는 경우도 많습니다.</p> <p>또한 클라우드 네이티브 개발 환경, 빌드 시스템, 테스트 프레임워크 등도 Java 17에 맞춰 업데이트되고 있습니다. 자바 개발자로서의 경쟁력을 유지하고 싶다면 Java 17은 더 이상 선택이 아닌 필수입니다.</p> <h3 id="java-8-개발자라면-지금이적기입니다">Java 8 개발자라면 지금이 적기입니다.</h3> <p>Java 17로의 전환은 생각보다 어렵지 않습니다. 특히 Java 8까지 익숙한 개발자라면, 지금부터 주요 문법과 특징 몇 가지만 익히면 금방 적응할 수 있습니다.</p> <ul> <li>새로운 프로젝트를 Java 17 기반으로 시작하려는 분들,</li> <li>Spring Boot 3로 마이그레이션을 고민 중인 분들,</li> <li>Lombok 없이 깔끔한 코드를 작성하고 싶은 분들이라면,</li> </ul> <p>이제는 Java 17을 학습할 시점입니다.</p> <h3 id="var-키워드--지역-변수-타입-추론-java-10도입">var 키워드 – 지역 변수 타입 추론 (Java 10 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <pre><code class="language-javaa">var scores = new HashMap&lt;String, List&lt;Integer&gt;&gt;();
</code></pre> <p><strong>어떤 점이 좋아졌나?</strong></p> <p>코드가 훨씬 간결해집니다. 특히 제네릭 타입이 길어질수록 우측 타입만으로 충분히 추론 가능할 때, 가독성이 올라갑니다.</p> <p>타입은 컴파일 타임에 고정되므로 동적 타입처럼 오해할 필요가 없습니다.</p> <p><strong>주의할 점</strong></p> <p>타입을 명확히 드러내는 것이 중요한 경우, var 대신 명시적 타입 사용이 오히려 낫습니다.</p> <h3 id="record--불변-데이터-클래스를-한-줄로-java-16도입">record – 불변 데이터 클래스를 한 줄로 (Java 16 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

    <span class="o">}</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>불변 객체 패턴을 아주 간결하게 작성할 수 있습니다.</li> <li>생성자, getter, equals, hashCode, toString을 자동 생성합니다.</li> <li>Lombok 없이도 DTO를 쉽게 만들 수 있습니다.</li> <li>데이터 중심 클래스를 명확히 표현할 수 있습니다.</li> </ul> <h3 id="text-block--멀티라인-문자열-java-15도입">Text Block – 멀티라인 문자열 (Java 15 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">json</span> <span class="o">=</span> <span class="s">"{\n"</span> <span class="o">+</span>
    <span class="s">" \"name\": \"John\",\n"</span> <span class="o">+</span>
    <span class="s">" \"age\": 30\n"</span> <span class="o">+</span>
    <span class="s">"}"</span><span class="o">;</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">json</span> <span class="o">=</span> <span class="sh">"""
    {
    "name": "John",
    "age": 30
    }
    """</span><span class="o">;</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>멀티라인 문자열을 이스케이프 없이 그대로 표현할 수 있습니다.</li> <li>SQL, JSON, XML, HTML 같은 문자열을 쓸 때 가독성이 대폭 향상됩니다.</li> <li>들여쓰기나 줄바꿈 처리도 유연하게 지원됩니다.</li> </ul> <h3 id="switch-표현식--조건문을-더-간결하고-안전하게-java-14도입">switch 표현식 – 조건문을 더 간결하고 안전하게 (Java 14 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">result</span><span class="o">;</span>
<span class="k">switch</span> <span class="o">(</span><span class="n">day</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nl">MONDAY:</span>
    <span class="k">case</span> <span class="nl">TUESDAY:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">"Weekday"</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="k">case</span> <span class="nl">SATURDAY:</span>
    <span class="k">case</span> <span class="nl">SUNDAY:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">"Weekend"</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">"Unknown"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="k">switch</span> <span class="o">(</span><span class="n">day</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="no">MONDAY</span><span class="o">,</span> <span class="no">TUESDAY</span> <span class="o">-&gt;</span> <span class="s">"Weekday"</span><span class="o">;</span>
    <span class="k">case</span> <span class="no">SATURDAY</span><span class="o">,</span> <span class="no">SUNDAY</span> <span class="o">-&gt;</span> <span class="s">"Weekend"</span><span class="o">;</span>
    <span class="k">default</span> <span class="o">-&gt;</span> <span class="s">"Unknown"</span><span class="o">;</span>
<span class="o">};</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>값을 반환할 수 있는 switch 표현식이 도입되어, 변수를 미리 선언할 필요가 없습니다. <ul> <li>문법으로 break 누락으로 인한 실수 방지.</li> </ul> </li> <li>yield를 활용하면 복잡한 로직도 표현 가능.</li> <li>함수형 스타일에 더 가까워졌습니다.</li> </ul> <h3 id="pattern-matching-for-instanceof--타입-검사와-캐스팅을-동시에-java-16도입">Pattern Matching for instanceof – 타입 검사와 캐스팅을 동시에 (Java 16 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">User</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="o">(</span><span class="nc">User</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>중복 코드 제거: 타입 체크 후 명시적 캐스팅을 반복할 필요가 없습니다.</li> <li>가독성 향상: 조건문에서 타입 이름을 한 번만 쓰면 됩니다.</li> <li>향후 도입될 switch 패턴 매칭과도 연계됩니다.</li> </ul> <h2 id="sealed-class--상속을-명시적으로-제한-java-17-정식도입">sealed class – 상속을 명시적으로 제한 (Java 17 정식 도입)</h2> <p><strong>Java 8 방식</strong></p> <ul> <li>상속 제한을 하려면 final로 막거나, 문서로 설명해야 했습니다.</li> </ul> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">sealed</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="n">permits</span> <span class="nc">Dog</span><span class="o">,</span> <span class="nc">Cat</span> <span class="o">{}</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{}</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{}</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>허용된 하위 클래스만 상속할 수 있도록 제한합니다.</li> <li>클래스 계층 구조가 예측 가능하고 안전해집니다.</li> <li>도메인 모델링 시, 허용된 상태나 유형만 정의 가능.</li> <li>자바 컴파일러가 하위 클래스를 정확히 알기 때문에 패턴 매칭에도 최적화됩니다.</li> </ul> <h3 id="기타-유용한변화들">기타 유용한 변화들</h3> <ul> <li>String에 새로운 메서드들 추가</li> <li>isBlank(): 공백 문자열 여부 확인</li> <li>repeat(int): 문자열 반복</li> <li>lines(): 줄 단위로 스트림 처리</li> <li>HttpClient: java.net.http.HttpClient가 정식 API로 도입됨 (Java 11)</li> <li>jshell: 자바 REPL 지원 (Java 9) – 빠른 테스트 가능</li> </ul> <h3 id="마무리-요약">마무리 요약</h3> <p>Java 17로 넘어오면서 자바는 더 이상 “장황한 코드”를 쓰는 언어가 아닙니다. 코드는 짧아졌고, 타입은 안전해졌으며, 불변성을 쉽게 유지할 수 있고, 조건문도 더 선언적으로 바뀌었습니다.</p> <p>기존 Java 8 방식에 익숙한 개발자라면, 다음과 같은 점에서 만족하실 수 있습니다:</p> <ul> <li>DTO 작성이 1줄로 끝난다 (record)</li> <li>조건문이 훨씬 직관적이다 (switch, pattern matching)</li> <li>JSON이나 SQL 문자열을 쓸 때 코드가 지저분하지 않다 (text block)</li> <li>상속과 타입 검사도 명확해졌다 (sealed, instanceof 개선)</li> </ul> <p>지금 Java 17을 익혀두신다면 앞으로 자바 개발에서 훨씬 높은 생산성과 안정성을 얻을 수 있습니다.</p>]]></content><author><name></name></author><category term="자바"/><category term="자바"/><summary type="html"><![CDATA[Java 8에서 Java 17로 업그레이드해야 하는 이유와 핵심 신기능들을 실무 예제와 함께 알아보세요]]></summary></entry><entry><title type="html">왜 개발자들은 OAuth와 OpenID Connect를 헷갈릴까?</title><link href="https://hwangrolee.github.io/blog/%EC%99%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%80-OAuth%EC%99%80-OpenID-Connect%EB%A5%BC-%ED%97%B7%EA%B0%88%EB%A6%B4%EA%B9%8C/" rel="alternate" type="text/html" title="왜 개발자들은 OAuth와 OpenID Connect를 헷갈릴까?"/><published>2025-08-05T00:00:00+00:00</published><updated>2025-08-05T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/%EC%99%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%80-OAuth%EC%99%80-OpenID-Connect%EB%A5%BC-%ED%97%B7%EA%B0%88%EB%A6%B4%EA%B9%8C</id><content type="html" xml:base="https://hwangrolee.github.io/blog/%EC%99%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%80-OAuth%EC%99%80-OpenID-Connect%EB%A5%BC-%ED%97%B7%EA%B0%88%EB%A6%B4%EA%B9%8C/"><![CDATA[<blockquote> <p>“구글 로그인은 OAuth 2.0으로 만들었어요.”</p> <p>“카카오 로그인은 OAuth API 써서 붙였어요.”</p> </blockquote> <p>많은 개발자들이 ‘소셜 로그인 = OAuth 2.0’ 이라고 이야기합니다. 하지만 사실 소셜 로그인은 OAuth가 아니라 OpenID Connect(OIDC) 덕분에 가능한 기능입니다.</p> <p>이 글에서는 개발자들이 OAuth와 OIDC를 혼용하는 이유와 왜 구글/카카오 로그인은 OIDC라고 말해야 하는지를 정리해봅니다.</p> <h2 id="oauth-20과-openid-connectoidc는-뭐가-다를까">OAuth 2.0과 OpenID Connect(OIDC)는 뭐가 다를까?</h2> <h3 id="oauth-20">OAuth 2.0</h3> <ul> <li>목적: 권한 위임(Authorization)</li> <li>예: “내 구글 드라이브 파일에 접근할 수 있는 권한을 앱에 줄게”</li> </ul> <h2 id="openid-connect-oidc">OpenID Connect (OIDC)</h2> <ul> <li>목적: 인증(Authentication)</li> <li>OAuth 2.0 기반 프로토콜 + ID Token 개념 추가</li> <li>예: “이 사용자가 ‘홍길동’인지 확인하고 로그인 처리해줘”</li> <li>정리하면 OAuth는 ‘무엇을 할 수 있는지’, OIDC는 ‘누구인지’ 를 해결하는 프로토콜입니다.</li> </ul> <h2 id="개발자들이-혼용하는-대표-케이스">개발자들이 혼용하는 대표 케이스</h2> <blockquote> <p>“구글 로그인은 OAuth 2.0을 사용했다.”</p> </blockquote> <p>왜 혼동될까? 구글 개발자 문서에 ‘Google OAuth 2.0’이라고 적혀 있어서. 실제 구현도 OAuth Authorization Code Flow를 사용하기 때문.</p> <h3 id="정확한-설명">정확한 설명</h3> <ul> <li>구글 API 호출 -&gt; OAuth</li> <li>구글 로그인 -&gt; OpenID Connect</li> <li>구글 로그인을 구현했다면 “OIDC를 사용했다”고 말하는 게 정확합니다.</li> <li>“OAuth로 로그인 기능을 만들었다.”</li> </ul> <h3 id="oauth-flow를-사용하니까-로그인도-oauth로-가능하다고-착각">OAuth Flow를 사용하니까 로그인도 OAuth로 가능하다고 착각.</h3> <ul> <li>OAuth는 권한 위임만 담당합니다.</li> <li>로그인 기능을 가능하게 해주는 건 OIDC에서 발급하는 ID Token 덕분입니다.</li> <li>OAuth만 쓰면 사용자 ‘신원’은 확인할 수 없습니다.</li> <li>“ID Token도 Access Token 중 하나다.”</li> </ul> <h3 id="왜-혼동될까-둘-다-토큰이니까-같은-개념이라고-생각">왜 혼동될까? 둘 다 ‘토큰’이니까 같은 개념이라고 생각.</h3> <ul> <li>JWT 구조도 비슷해서 더 헷갈립니다.</li> <li>Access Token -&gt; API 자원 접근 용도</li> <li>ID Token -&gt; 로그인 인증 용도 (이메일, 이름, 사용자 ID 포함)</li> </ul> <h3 id="그렇다면-구글카카오-로그인은-oauth일까-oidc일까">그렇다면, 구글/카카오 로그인은 OAuth일까 OIDC일까?</h3> <ul> <li>정확히 말하면 -&gt; OIDC를 활용한 것입니다.</li> <li>OAuth 2.0 -&gt; 권한 위임 (예: 내 구글 드라이브 파일 접근 허용)</li> <li>OpenID Connect(OIDC) -&gt; OAuth 2.0 기반 + “사용자 인증(로그인)” 기능 추가</li> </ul> <p>구글 로그인 / 카카오 로그인은 “로그인(= 인증)”이 목적이라 OIDC를 사용했다고 해야 정확합니다.</p> <h3 id="면접이나-블로그에서-이렇게-설명할-수-있습니다">면접이나 블로그에서 이렇게 설명할 수 있습니다</h3> <p>구글, 카카오 로그인 기능을 내 서비스에 붙일 때 OAuth 2.0 Flow(Authorization Code)를 사용하긴 했지만, 실제로 로그인 기능을 가능하게 한 건 OpenID Connect(OIDC)입니다.</p> <p>OAuth만 쓰면 단순 권한 위임만 가능하지만, OIDC는 ID Token을 통해 사용자 정보를 확인할 수 있기 때문에 로그인 구현이 가능합니다.</p> <h2 id="결론-이렇게-기억하면-안-헷갈림">결론: 이렇게 기억하면 안 헷갈림</h2> <ul> <li>OAuth 2.0 -&gt; 권한 위임 (내 API를 대신 호출하게 권한 줌)</li> <li>OIDC -&gt; OAuth 2.0 + 로그인 기능 (이 사용자가 누구인지 알려줌)</li> </ul> <h2 id="마무리">마무리</h2> <p>다음에 누군가 “구글 로그인은 OAuth로 만들었어?” 라고 물으면</p> <blockquote> <p>“정확히는 OAuth 위에 인증 기능을 추가한 OpenID Connect로 구현했어”</p> </blockquote> <p>라고 말해보세요. OAuth는 ‘무엇을 할 수 있나’, OIDC는 ‘누구인가’. 이 한 줄만 기억하면 더 이상 헷갈리지 않을 겁니다.</p>]]></content><author><name></name></author><category term="인증/인가"/><category term="OAuth,"/><category term="OIDC,"/><category term="OpenID"/><category term="Connect,"/><category term="소셜로그인,"/><category term="Authentication,"/><category term="Authorization"/><summary type="html"><![CDATA[개발자들이 흔히 혼동하는 OAuth 2.0과 OpenID Connect(OIDC)의 차이점을 명확히 설명합니다. 소셜 로그인이 OAuth가 아닌 OIDC인 이유, 인증(Authentication)과 권한 위임(Authorization)의 핵심 개념을 알아보고 정확한 기술 용어를 사용하세요.]]></summary></entry></feed>