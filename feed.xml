<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://hwangrolee.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://hwangrolee.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-08T07:20:41+00:00</updated><id>https://hwangrolee.github.io/feed.xml</id><title type="html">이황로의 포트폴리오</title><subtitle>개발을 좋아하는 이황로입니다. 스타트업에서 웹 프론트엔드/백엔드 업무 모두 경험을 했고 수많은 새로운 기능을 개발했으며 버그를 수정해왔습니다. 그리고 서비스가 불안정할 때 MySQL, Redis 등 시스템 퍼포먼스를 개선하여 안정화 시킨 경험이 있고 제가 좋아하는 업무입니다. </subtitle><entry><title type="html">MySQL 실시간 쿼리 확인하기</title><link href="https://hwangrolee.github.io/blog/MySQL-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%BF%BC%EB%A6%AC-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="MySQL 실시간 쿼리 확인하기"/><published>2025-03-08T00:00:00+00:00</published><updated>2025-03-08T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/MySQL-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%BF%BC%EB%A6%AC-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/MySQL-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%BF%BC%EB%A6%AC-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/"><![CDATA[<h1 id="mysql에서-락-문제-해결-및-관리-방법">MySQL에서 락 문제 해결 및 관리 방법</h1> <p>많은 서비스에서 MySQL을 메인 데이터베이스로 사용하여 서비스를 개발하고 있습니다. MySQL은 RDBMS로서 <strong>Transaction</strong> 단위로 쿼리를 실행하게 되며, <strong>ACID</strong> 특성에 의해 데이터의 신뢰성을 보장합니다. 하지만, 트랜잭션에 의해 락이 발생하고, 락에 의해 쿼리 지연이 발생하면서 서비스 장애를 초래할 수 있습니다. 이번 글에서는 MySQL에서 발생할 수 있는 락 문제를 어떻게 해결할 수 있는지에 대해 살펴보겠습니다.</p> <h2 id="락-발생-원인">락 발생 원인</h2> <h3 id="1-트랜잭션에-의한-락">1. 트랜잭션에 의한 락</h3> <p>MySQL에서 트랜잭션은 <strong>ACID</strong> 특성(Atomicity, Consistency, Isolation, Durability)을 보장하기 위해 실행됩니다. 하지만, 트랜잭션이 실행되는 동안 <strong>락</strong>이 발생하게 되어 다른 트랜잭션이 대기 상태로 들어갑니다. 이로 인해 쿼리 지연이 발생하고, 서비스 장애를 초래할 수 있습니다.</p> <h3 id="2-ddl-명령어에-의한-락">2. DDL 명령어에 의한 락</h3> <p><strong>DDL(Data Definition Language)</strong> 명령어(예: <code class="language-plaintext highlighter-rouge">ALTER</code>, <code class="language-plaintext highlighter-rouge">DROP</code>, <code class="language-plaintext highlighter-rouge">CREATE</code>)는 테이블이나 데이터베이스 구조를 변경합니다. 이러한 명령어는 해당 테이블에 <strong>테이블 락</strong>을 걸어 다른 트랜잭션이 해당 테이블을 수정하는 것을 차단하게 됩니다. 이로 인해 서비스 지연이 발생할 수 있으므로 DDL 실행 시 특별한 주의가 필요합니다.</p> <h2 id="락-문제-해결-방법">락 문제 해결 방법</h2> <h3 id="1-현재-실행-중인-쿼리-모니터링">1. 현재 실행 중인 쿼리 모니터링</h3> <p>쿼리 락이나 DDL 명령어 실행에 의해 락이 발생하면, 해당 락을 유발하는 쿼리를 찾아서 중단시켜야 합니다. 이를 위해 <code class="language-plaintext highlighter-rouge">information_schema.INNODB_TRX</code>를 사용하여 현재 실행 중인 트랜잭션을 모니터링할 수 있습니다. 다음 쿼리를 통해 현재 실행 중인 트랜잭션과 관련된 정보를 확인할 수 있습니다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_id</span><span class="p">,</span>
       <span class="n">aa</span><span class="p">.</span><span class="n">trx_mysql_thread_id</span><span class="p">,</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_state</span><span class="p">,</span>
       <span class="n">bb</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="k">user</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="k">host</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="n">db</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="n">command</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="nb">time</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="k">state</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="n">info</span><span class="p">,</span>
       <span class="n">aa</span><span class="p">.</span><span class="n">trx_started</span><span class="p">,</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_requested_lock_id</span><span class="p">,</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_wait_started</span><span class="p">,</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_weight</span>
<span class="k">FROM</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">INNODB_TRX</span> <span class="n">aa</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">PROCESSLIST</span> <span class="n">bb</span>
    <span class="k">ON</span> <span class="p">(</span><span class="n">bb</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_mysql_thread_id</span><span class="p">)</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_state</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="nb">time</span> <span class="k">DESC</span><span class="p">;</span>
</code></pre></div></div> <p>위 쿼리를 통해 현재 실행 중인 트랜잭션과 관련된 정보를 확인할 수 있습니다. 만약 락을 유발하는 쿼리를 발견하면, KILL 명령어를 통해 해당 쿼리를 중단시킬 수 있습니다.</p> <h3 id="2-락을-유발하는-쿼리-중단">2. 락을 유발하는 쿼리 중단</h3> <p>락을 유발하는 쿼리를 찾아 중지시켜야 합니다. 위에서 제공된 쿼리로 확인한 후, 락을 발생시키는 트랜잭션을 KILL 명령어로 종료합니다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">KILL</span> <span class="p">[</span><span class="n">trx_mysql_thread_id</span><span class="p">];</span>
</code></pre></div></div> <p>이 명령어를 통해 해당 트랜잭션을 강제로 종료시킬 수 있습니다. 이 과정은 락이 발생하여 서비스에 영향을 미치고 있을 때 빠르게 대응할 수 있도록 도와줍니다.</p> <h2 id="락-예방을-위한-best-practices">락 예방을 위한 Best Practices</h2> <h3 id="1-ddl-및-dml-명령어-실행-전-사이드-이펙트-고려">1. DDL 및 DML 명령어 실행 전 사이드 이펙트 고려</h3> <p>DDL 및 DML 명령어를 실행하기 전에 해당 명령어가 락을 발생시킬 수 있는지 여부를 충분히 고려해야 합니다. 이를 통해 락 발생 가능성을 미리 예측하고, 서비스에 미치는 영향을 최소화할 수 있습니다.</p> <h3 id="2-ddl-및-dml-명령어-실행-후-락-모니터링">2. DDL 및 DML 명령어 실행 후 락 모니터링</h3> <p>DDL 및 DML 명령어 실행 후에는 information_schema.INNODB_TRX를 사용하여 현재 실행 중인 쿼리를 모니터링해야 합니다. 쿼리가 밀리는 현상이 발생하면 즉시 락을 유발한 쿼리를 중단하여 서비스 장애를 예방할 수 있습니다.</p> <h3 id="3-트랜잭션-최적화">3. 트랜잭션 최적화</h3> <p>트랜잭션을 가능한 한 작은 범위로 만들어 락의 지속 시간을 줄여야 합니다. 불필요한 쿼리를 실행하지 않도록 하여 락이 필요한 시간을 최소화하고, 트랜잭션 격리 수준을 적절히 설정해 락 경합을 줄일 수 있습니다.</p> <h3 id="4-락-모니터링-도구-사용">4. 락 모니터링 도구 사용</h3> <p>MySQL의 성능 스키마나 MySQL Enterprise Monitor와 같은 도구를 활용하여 실시간으로 락 문제를 모니터링할 수 있습니다. 문제 발생 시 자동으로 알림을 받아 대응할 수 있습니다.</p> <h2 id="결론">결론</h2> <p>MySQL에서 락을 관리하는 것은 서비스의 성능과 안정성에 중요한 영향을 미칩니다. 트랜잭션을 최적화하고, DDL 명령어 실행 시 주의를 기울이며, 락 모니터링을 통해 실시간으로 문제를 해결할 수 있어야 합니다. 이러한 관리 방법을 통해 서비스 장애를 예방하고, 데이터베이스의 성능을 최적화할 수 있습니다.</p>]]></content><author><name></name></author><category term="MySQL"/><category term="MySQL,"/><category term="MySQL"/><category term="트랜잭션,"/><category term="MySQL"/><category term="락,"/><category term="MySQL"/><category term="DDL"/><category term="락,"/><category term="MySQL"/><category term="성능"/><category term="최적화,"/><category term="MySQL"/><category term="트랜잭션"/><category term="락,"/><category term="MySQL"/><category term="인덱스"/><category term="최적화,"/><category term="MySQL"/><category term="Deadlock"/><category term="해결,"/><category term="MySQL"/><category term="DML"/><category term="최적화,"/><category term="데이터베이스"/><category term="성능"/><category term="튜닝,"/><category term="InnoDB"/><category term="트랜잭션,"/><category term="MySQL"/><category term="쿼리"/><category term="최적화,"/><category term="MySQL"/><category term="모니터링,"/><category term="MySQL"/><category term="정보"/><category term="스키마,"/><category term="MySQL"/><category term="프로세스"/><category term="관리"/><summary type="html"><![CDATA[MySQL에서 발생하는 락 문제를 해결하는 방법과 락을 유발하는 쿼리를 찾아 종료하는 절차를 설명합니다. 트랜잭션, DDL, DML 명령어의 락 사이드 이펙트를 고려하여 서비스 장애를 예방하고, 락을 관리하는 방법을 소개합니다.]]></summary></entry><entry><title type="html">백엔드 개발자가 리액트 네이티브로 달력 앱을 배포해보았습니다.</title><link href="https://hwangrolee.github.io/blog/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C%EB%A1%9C-%EB%8B%AC%EB%A0%A5-%EC%95%B1%EC%9D%84-%EB%B0%B0%ED%8F%AC%ED%95%B4%EB%B3%B4%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/" rel="alternate" type="text/html" title="백엔드 개발자가 리액트 네이티브로 달력 앱을 배포해보았습니다."/><published>2025-03-08T00:00:00+00:00</published><updated>2025-03-08T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80%20%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C%EB%A1%9C-%EB%8B%AC%EB%A0%A5-%EC%95%B1%EC%9D%84-%EB%B0%B0%ED%8F%AC%ED%95%B4%EB%B3%B4%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4</id><content type="html" xml:base="https://hwangrolee.github.io/blog/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C%EB%A1%9C-%EB%8B%AC%EB%A0%A5-%EC%95%B1%EC%9D%84-%EB%B0%B0%ED%8F%AC%ED%95%B4%EB%B3%B4%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/"><![CDATA[<p>저는 2016년부터 꾸준히 백엔드 개발을 해왔습니다. 백엔드 개발하면서 백오피스개발도 해왔기에 기본적인 프론트엔드 개발 기술은 알고 있는 상태였습니다. 웹 프론트엔드 기술 중 바닐라, 리액트, Nextjs, Angularjs 를 활용해서 웹 프론트엔드를 개발해왔지만 앱을 만들어 본적은 없었어요.</p> <p>퇴근 회사를 퇴사하면서 이번에 앱을 만들어 보고자 크로스 플랫폼에 대해서 공부했습니다.</p> <h3 id="리액트-네이티브-vs-플러터">리액트 네이티브 vs 플러터</h3> <p>빠르고 간단하게 앱을 만들고 싶었기에 당연하게 크로스 플랫폼 기반으로 앱을 만들기로 정했습니다. 그리고 리액트 네이티브와 플러터를 비교해보았고 저는 <em>리액트 네이티브</em> 를 선택했습니다.</p> <p>제가 리액트 네이티브를 선택한 이유는…</p> <p><em>1. 자바스크립트(타입스크립트)로 개발이 가능합니다.</em></p> <p>자바스크립트로 개발을 할 수 있다는 것은 굉장히 큰 메리트였습니다. 웹 프론트엔드 개발 경험이 있어서 자바스크립트에 대해서는 크게 불편함이 없었기에 언어에 대한 허들이 낮았기에 쉽게 접근 할 수 있을 거라 생각 했습니다. 그리고 플러터를 개발하기 위해 Dart(다트) 언어를 공부해도 되지만 제가 다시 앱을 만들지 않는 이상 Dart 언어를 사용할 일은 없을 거라 아마 다시 까먹게 될 언어라고 생각했습니다.</p> <p><em>2. 프레임워크 생태계가 리액트 네이티브가 더 커요.</em></p> <p>리액트 네이티브는 리액트 기반이기 때문에 플러터보다 먼저 오픈소스 생태계가 활성화 되어 있었기 때문에 구글링으로 빠르게 이슈를 해결할 수 있을 거라 생각했습니다. 앱 개발에 있어서 이슈 해결을 위한 프레임워크 생태계는 생각보다 많이 중요하기 때문입니다.</p> <p><em>3. 플러터의 장점이 저에게 있어선 큰 장점이 아니었어요.</em></p> <p>플러터가 리액트 네이티브보다 성능면에서 좋다고 합니다. 제가 플러터를 경험해보지 않았고 직접 경험해보지 않았지만 확실히 성능 측면에서는 차이가 있다고 해서 조금 고민을 했습니다. 하지만 제가 만들 달력 앱은 간단한 앱이기 때문에 애니메이션, 렌더링, 데이터 처리 등등 성능 측면에서 큰 문제가 되지 않을 거라 생각했습니다. 만약 성능 측면에서 많이 고려해야하는 앱을 만들 예정이었다면 플러터를 고려하지 않았을까 생각됩니다.</p> <p>위 3가지의 이유로 리액트 네이티브를 선택하였고 개발을 시작했죠.</p> <h3 id="라이브러리-선택의-갈림길">라이브러리 선택의 갈림길</h3> <p>개발은 생각보다 순조로웠고 어렵다는 생각이 들지 않았습니다.</p> <p><em>1. 상태 관리 라이브러리는 무엇을 맞을까? (Redux vs Recoil)</em></p> <p>과거 리액트 시장에서는 상태 관리 라이브러리는 당연히 Redux 였습니다. 하지만 몇 년전 recoil 이라는 새로운 라이브러리를 리액트에서 만들었고 많이 사용되고 있죠. Redux 는 과거부터 사용해왔기에 당연히 생태계와 안정성은 많은 사람들에게 인정받아왔고 지금이 많이 활용되고 있습니다. 하지만 저는 Recoil 을 사용하기로 했습니다. 이유는 상태 관리가 그렇게 복잡하지 않을 뿐더러 복잡하더라도 Redux 보다는 리액트에서 직접 만든 Recoil 이 저에게 있어서 좀 더 신뢰도가 높기 때문입니다. 사용성도 편한 것 같고..</p> <p><em>2. 스타일링 라이브러리는 무엇이 좋을까?(Styled Component VS Style Sheet)</em></p> <p>처음 개발 시작 할 때에는 Style Sheet 를 사용했어요. 테마 기능을 넣으려고 보니 Style Sheet 로는 한계점이 보였고 과감하게 Styled Component 로 옮겼습니다. 테마 관리에 있어서는 Styled Component 가 훨씬 편하기 때문입니다.</p> <p>프레임워크 생태계가 방대하다는 것은 다양한 라이브러리가 존재하고 개발자 취향에 따라 원하는 라이브러리를 선택할 수 있다는 점이지만 때로는 선택을 하는데 너무 많은 시간을 소비해야하는 단점이 있는 것 같네요.</p> <h3 id="피그마로-앱-아이콘-앱-소개-이미지를-만들어-보았어요">피그마로 앱 아이콘, 앱 소개 이미지를 만들어 보았어요.</h3> <p>달력앱을 만드는 것은 어렵지 않았어요. 오히려 기본 기능을 개발 후 배포하는 것이 더 어렵고 힘든 작업이었습니다. 혼자서 하려니 생각할 것이 너무나 많았습니다.</p> <p>디자이너가 만든 피그마를 확인해서 개발한 적은 있지만 직접 피그마로 디자인해보는 건 처음 이었어요. 다행히 피그마에는 앱 아이콘, 앱 소개 이미지를 위한 다양한 템플릿이 있었고 이것 저것 사용해보다가 초보인 제가 사용하기 쉬운 템플릿으로 앱 아이콘과 앱 소개 이미지를 제작했습니다.</p> <ul> <li><a href="https://www.figma.com/design/6VPVTMzVb65jwiyOQhIKLC/App-Icon-Toolkit---iOS%2FmacOS%2FAndroid-(Community)?m=auto&amp;t=8rs8r8NsRwi6oqMx-6">앱 아이콘 템플릿</a></li> <li><a href="https://www.figma.com/design/P9dmo9eVszzV8Ej0HXXsNI/App-Store-Screenshot-Template-(Community)?m=auto&amp;t=MNR6nfA6x2cdmcr5-6">앱 이미지 템플릿</a></li> </ul> <h3 id="앱-노출-극대화를-위한-키워드-리서치-앱-소개글-작성하기">앱 노출 극대화를 위한 키워드 리서치, 앱 소개글 작성하기</h3> <p>흔히 ASO 라고 해서 앱 스토어에서 앱 노출 극대화를 위해 키워드 리서치를 합니다. 키워드 리서치할 때 많이 사용하는 툴은 드래곤 메트릭스와 같은 툴을 많이 사용하지만 저는 ChatGPT 를 사용했어요 귀찮…</p> <h3 id="결론">결론</h3> <p>백엔드 개발자인 제가 앱을 배포해본다는 것은 좋은 경험이었고 저와 같이 일하는 다른 팀원분들의 고충도 이해하게 되었습니다.</p>]]></content><author><name></name></author><category term="React"/><category term="Native"/><category term="React"/><category term="Native,"/><category term="Flutter,"/><category term="크로스플랫폼"/><category term="앱"/><category term="개발,"/><category term="리액트"/><category term="네이티브"/><category term="vs"/><category term="플러터,"/><category term="백엔드"/><category term="개발자"/><category term="앱"/><category term="개발,"/><category term="React"/><category term="Native"/><category term="상태"/><category term="관리,"/><category term="Recoil"/><category term="vs"/><category term="Redux,"/><category term="Styled"/><category term="Component,"/><category term="앱"/><category term="개발"/><category term="과정,"/><category term="앱"/><category term="배포"/><category term="경험,"/><category term="앱스토어"/><category term="최적화(ASO),"/><category term="앱"/><category term="키워드"/><category term="리서치,"/><category term="피그마"/><category term="앱"/><category term="디자인,"/><category term="앱"/><category term="아이콘"/><category term="제작,"/><category term="앱"/><category term="소개"/><category term="이미지,"/><category term="iOS"/><category term="앱"/><category term="개발,"/><category term="Android"/><category term="앱"/><category term="개발,"/><category term="React"/><category term="Native"/><category term="라이브러리"/><category term="선택,"/><category term="개발자"/><category term="앱"/><category term="출시,"/><category term="앱스토어"/><category term="마케팅"/><summary type="html"><![CDATA[백엔드 개발자가 리액트 네이티브를 활용해 첫 앱을 배포한 경험을 공유합니다. 리액트 네이티브 vs 플러터 비교, 상태 관리, 스타일링, ASO 키워드 리서치까지!]]></summary></entry><entry><title type="html">MySQL 트랜잭션 격리수준 Isolation level 알아보기</title><link href="https://hwangrolee.github.io/blog/MySQL-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80-Isolation-level-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/" rel="alternate" type="text/html" title="MySQL 트랜잭션 격리수준 Isolation level 알아보기"/><published>2024-12-15T00:00:00+00:00</published><updated>2024-12-15T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/MySQL-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80-Isolation-level-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/MySQL-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80-Isolation-level-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/"><![CDATA[<p>트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 다른 트랜잭션에서 변경이 일어났을 때 해당 데이터를 또 다른 트랜잭션에서 조회가 가능하게 할지를 허용할지 말지를 결정하는 것이다. 격리 수준에는 총 4개가 있다.</p> <ul> <li>READ UNCOMMITTED</li> <li>READ COMMITTED</li> <li>REPEATABLE READ</li> <li>SERIALIZABLE 위 4개 중 첫번째인 READ UNCOMMITTED는 격리수준이 가장 낮고 SERIALIZABLE 은 격리 수준이 가장 높다.</li> </ul> <h2 id="1-read-uncommitted">1. READ UNCOMMITTED</h2> <p>트랜잭션 격리수준 중 가장 낮은 단계로 성능이 가장 좋지만 다른 트랜잭션에서 커밋되지 않은 데이터를 읽어 올 수 있기 때문에 잘 못 사용할 경우 데이터 정합성에 큰 이슈가 발생 할 수 있다.</p> <p>Transaction_A 에서 INSERT, UPDATE, DELETE 쿼리를 실행 후 아직 커밋하지 않았지만 Transaction_B 에서 SELECT 쿼리를 실행시키게 되면 INSERT, UPDATE, DELETE 쿼리 결과가 보이게 된다. 이 때 Transaction_A 는 COMMIT 하지 않고 ROLLBACK 을 하게 되면 Transaction_B 는 실제 데이터베이스에 없는 데이터를 읽게 된 것이며 이를 더티리드(Dirty read) 라고 한다.</p> <p>트랜잭션에서 INSERT, UPDATE, DELETE 쿼리를 실행할 경우 커밋하기 전에는 Undo 영역에 변경 전 데이터를 저장하고 레코드의 값을 변경한다. 이 때 Rollback 을 하게 되면 Undo 영역에 있던 데이터를 레코드로 복원하게 된다.</p> <p>READ_UNCOMMITTED 는 레코드에 저장된 값을 가저오기 때문에 롤백이 된 데이터를 읽어 올 수 있다.</p> <p>READ UNCOMMITTED 는 정합성 이슈가 발생하지 않는 SELECT 쿼리에서만 사용할 것을 권장하며 READ UNCOMMITTED로 읽은 데이터로 INSERT, UPDATE, DELETE 에 사용하지 않도록 주의해야 한다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- [SESSION_1]</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">SET</span> <span class="k">SESSION</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">UNCOMMITTED</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- name = 'one' 인 데이터가 출력됨.</span>

<span class="c1">-- [SESSION_2]</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="k">user</span> <span class="k">SET</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'two'</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'one'</span><span class="p">;</span>
<span class="c1">-- name = 'one' 을 'two' 로 업데이트함. 아직 커밋하지 않았음.</span>
<span class="c1">-- [SESSION_1]</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- name = 'two' 인 데이터 출력됨.</span>
<span class="c1">-- [SESSION_2]</span>
<span class="k">ROLLBACK</span><span class="p">;</span>
<span class="c1">-- 트랜잭션을 롤백</span>
<span class="c1">-- [SESSION_1]</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- 롤백전에는 name = 'two' 인 데이터가 출력되었지만 롤백 후에는 이전 데이터인 'one'인 데이터가 출력됨</span>
</code></pre></div></div> <p>위 내용을 직접 테스트해 보았을 때 name = ‘two’ 는 트랜잭션 내부에서 업데이트문만 실행했을 뿐 COMMIT 하지 않았지만 다른 세션에서 실행한 트랜잭션에서 읽을 수 있다. name = ‘two’가 제대로 커밋 된다면 다행이지만 롤백이 된다면 잘못된 데이터를 불러온 것이 된다.</p> <blockquote class="block-tip"> <h5 id="tip">TIP</h5> <p>READ UNCOMMITTED 는 자주 호출되지만 INSERT, UPDATE, DELETE 쿼리에는 영향이 가지 않는 곳에서 사용해야만 한다.</p> </blockquote> <h2 id="2-read-committed">2. READ COMMITTED</h2> <p>MSSQL, Oracle 의 기본 트랜잭션 격리수준으로 커밋 된 데이터를 읽을 수 있는 격리수준이다. 커밋 된 데이터만 읽기 때문에 READ UNCOMMITTED 처럼 더티리드(Dirty read)가 발생하지 않기 때문에 대부분의 데이터를 신뢰할 수 있다.</p> <p>READ COMMITTED 격리수준이라고 해서 모든 상황에서 데이터를 신뢰 할 수 있는 것은 아니다. 바로 Unrepeatable read 로 인해 다른 트랜잭션 간에 커밋 타이밍에 따라 데이터 정합성이 어긋 날 수 있기 때문이다. 그래서 READ COMMITTED 는 대부분의 데이터를 신뢰할 수 있다 라고 표현했다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- [SESSION_1]</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">SET</span> <span class="k">SESSION</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">COMMITTED</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- name = 'one' 인 데이터가 출력됨.</span>
<span class="c1">-- [SESSION_2]</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="k">user</span> <span class="k">SET</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'two'</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'one'</span><span class="p">;</span>
<span class="c1">-- name = 'one' 을 'two' 로 업데이트함. 아직 커밋하지 않았음.</span>
<span class="c1">-- [SESSION_1]</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- SESSION_2가 커밋되지 않았기 때문에 name = 'one' 인 데이터 출력됨.</span>
<span class="c1">-- [SESSION_2]</span>
<span class="k">COMMIT</span><span class="p">;</span>
<span class="c1">-- 커밋했기 때문에 디비에 데이터 반영됨.</span>
<span class="c1">-- [SESSION_1]</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- SESSION_2가 커밋되면서 name = 'two' 인 데이터가 출력된.</span>
<span class="n">name</span><span class="o">=</span><span class="s1">'one'</span>
</code></pre></div></div> <p>위 상황과 같이 SESSION_1 은 트랜잭션이 시작 했을 때 데이터를 확인해보면 name=’one’ 인 상태인데 SESSION_2 에서 트랜잭션 시작 후 업데이트 후 커밋까지 한 후 SESSION_1 에서 다시 조회를 하면 name = ‘two’ 로 바뀌어 있습니다. 이 처럼 같은 트랜잭션 내에게 같은 데이터를 조회했을 때 다른 데이터가 출력된다면 이 또한 데이터 정합성에 문제가 발생할 수 있다.</p> <p>일반적인 상황에서는 크게 문제되지 않지만 같은 트랜잭션 내에서 같은 SELECT 쿼리 여러번 호출하는 경우에는 이슈가 발생할 수 있다. 되도록이면 같은 트랜잭션 내에서 같은 SELECT 쿼리를 호출하는 케이스를 줄이도록 한다면 위와 같이 Unrepeatable read 현상을 줄일 수 있다.</p> <h2 id="3-repeatable-read">3. REPEATABLE READ</h2> <p>READ COMMITTED 와 같이 커밋 된 데이터를 읽지만 Unrepeatable read 현상이 발생하지 않는 격리 수준이다. MySQL 의 InnoDB 엔진에서 사용하는 기본격리수준이다.</p> <p>REPEATABLE READ는 Unrepeatable read 가 발생하지 않도록 트랜잭션이 시작하는 시점의 스냅샷을 기준으로 데이터를 조회한다. 다른 트랜잭션에 데이터가 업데이트되었더라도 현재 트랜잭션에서는 스냅샷 기준으로 데이터를 가저오기 때문에 Unrepeatable read 현상이 발생하지 않는다.</p> <p>트랜잭션을 시작하게 되면 트랜잭션에는 번호를 가지게 되고 언두 영역의 백업된 모든 레코드에는 백업한 트랜잭션 번호가 포함되어 있다. 그리고 언두 영역의 백업된 데이터는 InnoDB 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제한다.</p> <p>REPEATABLE READ 는 PHANTOM READ(=PHANTOM ROW) 라는 이슈가 발생한다. PHANTOM READ는 첫번째 SELECT 문에서 보이지 않았던 데이터가 두번째 SELECT 쿼리에서는 보이는 현상이다.</p> <p>InnoDB 에서의 독특한 매커니즘으로 인해 PHANTOM READ 현상은 발생하지 않는다. 직접 MySQL 로 테스트를 해보았을 때 발생하지 않았다.</p> <p>INSERT 쿼리 실행 후 커밋하지 않은 상태에서 다른 트랜잭션에서 SELECT ~ FOR UPDATE 를 실행 시 INSERT 를 실행 한 트랜잭션에 의해 SELECT ~ FOR UPDATE 쿼리는 락이 걸리게 되어 PHANTOM READ 가 발생하지 않는다.</p> <h2 id="4-serializable">4. SERIALIZABLE</h2> <p>가장 엄격한 격리수준으로 동시 작업 성능이 가장 떨어지는 격리 수준이다. SELECT 쿼리는 기본적으로 SHARED LOCk 을 기본적으로 획득하게되어 SELECT 중 INSERT, UPDATE, DELETE 가 불가능하다.</p> <h2 id="5-결론">5. 결론</h2> <p>기본적으로 <em>READ COMMITTED 혹은 REPEATABLE READ 를 사용할 것을 권장</em>한다.</p> <p>되도록이면 1개의 트랜잭션에서 같은 SELECT 쿼리를 실행하지 않도록 주의한다. READ COMMITTED의 경우 1개의 트랜잭션에서 같은 SELECT 문을 실행시 Unrepeatable read 현상이 발생할 여지가 있다. REPEATABLE READ 의 경우 PHANTOM READ가 발생할 수 있다. (InnoDB 외 다른 엔진에서 PHANTOM READ 발생)</p> <p>SERIALIZABLE 은 사용하지 않는 것이 정신 건강에 좋다. 실시간성을 보장받지 않고 데이터가 정확하지 않아도 되는 기능의 경우 READ UNCOMMITTED 를 사용하면 성능을 높일 수 있다.</p> <h2 id="6-참고">6. 참고</h2> <ul> <li>https://zzang9ha.tistory.com/381</li> <li>Real Mysql 8.0</li> </ul>]]></content><author><name></name></author><category term="MySQL"/><category term="mysql,"/><category term="트랜잭션,"/><category term="Isolation"/><category term="Level,"/><category term="트랜잭션"/><category term="격리수준,"/><category term="Transaction"/><summary type="html"><![CDATA[MySQL 트랜잭션 격리수준 Isolation level 알아보기]]></summary></entry><entry><title type="html">레디스에 대한 간단한 설명과 성능향상시키기</title><link href="https://hwangrolee.github.io/blog/%EB%A0%88%EB%94%94%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%84%A4%EB%AA%85%EA%B3%BC-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%8B%9C%ED%82%A4%EA%B8%B0/" rel="alternate" type="text/html" title="레디스에 대한 간단한 설명과 성능향상시키기"/><published>2024-12-08T00:00:00+00:00</published><updated>2024-12-08T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/%EB%A0%88%EB%94%94%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%84%A4%EB%AA%85%EA%B3%BC-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%8B%9C%ED%82%A4%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/%EB%A0%88%EB%94%94%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%84%A4%EB%AA%85%EA%B3%BC-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%8B%9C%ED%82%A4%EA%B8%B0/"><![CDATA[<h2 id="0-레디스란">0. 레디스란?</h2> <p>memcached와 같은 인메모리 데이터베이스로 데이터를 메모리에 저장하기 때문에 속도가 빨라 서비스의 성능을 개선시키는 목적으로 많이 사용한다.</p> <p>데이터가 메모리에서 관리되기 때문에 레디스를 재가동할경우 저장된 데이터는 사라진다. 이러한 문제는 백업, 클러스터, 센티널등을 활용하여 개선할 수 있다.</p> <p>레디스의 경우 memcached와 많이 비교가 되고 있다. memcached의 경우 key-value로만 데이터를 저장할 수 있지만 레디스는 Lists, Sets, Hashes등 많은 데이터타입을 지원하고 있어서 현업에서 많이 쓰이고 있다.</p> <p>레디스는 기본적으로 싱글쓰레드로 동작한다. 그렇기 때문에 명령어를 사용할때 최대한 실행복잡도가 O(1) 인 명령어를 사용하도록 노력해야 한다. 특히, keys, flushall, flushdb, smembers, hgetall 과 같은 명령어는 사용을 금지하도록 개발자들끼리 소통을 하면 좋다. 혹은 redis 6.0.0 부터 지원하는 ACL기능을 사용하여 강제로 명령어를 막아도 좋다. (ACL기능은 직접사용해 보진 못했다.)</p> <p><code class="language-plaintext highlighter-rouge">keys, smembers, hgetall 과 같은 기능은 scan, sscan, hscan 으로 명령어를 대체할 수 있다.</code></p> <hr/> <h2 id="1-데이터-타입">1. 데이터 타입</h2> <h3 id="11string">1.1.String</h3> <p>Key와 Value 가 일 대 일 관계이다. 알파벳, 숫자, 한글등을 저장할 수 있다. Key 와 Value 모두 최대 길이는 512MB 이다.</p> <h3 id="12-lists">1.2. Lists</h3> <p>데이터를 링크드 리스트 형태로 관리하여 입력된 순서대로 저장되어 큐, 스택으로도 활용이 가능하다. 단 같은 값을 넣었을 때 중복으로 데이터가 들어갈 수 있다.</p> <p>Redis 3.2 이전 버전에서는 데이터수가 512개이하라면 짚리스트를 사용하고 513개부터를 링크드리스트를 사용한다고 한다.</p> <p>Redis 3.2 부터는 퀵리스트로 데이터를 저장하도록 확정되었다. 퀵리스트는 레디스를 메인디비로 사용한다고 알려진 트위터에서 발표했으며 Yao yu가 발표했다고 한다. 짚리스트, 링크드 리스트의 성능을 대폭 향상시켰다고 한다.</p> <blockquote class="block-warning"> <h5 id="주의사항"><strong>주의사항</strong></h5> <p><code class="language-plaintext highlighter-rouge">BRPOP</code>: 데이터가 들어오면 오른쪽에서 데이터를 꺼내온다. 데이터가 있다면 RPOP처럼 오른쪽 데이터를 꺼내오지만 데이터가 없다면 데이터가 들어올때까지 timeout 시간만큼 기다린다</p> <p><code class="language-plaintext highlighter-rouge">BLPOP</code>: 데이터가 들어오면 왼쪽에서 데이터를 꺼내온다. 데이터가 있다면 LPOP처럼 왼쪽 데이터를 꺼내오지만 데이터가 없다면 데이터가 들어올때까지 timeout 시간만큼 기다린다</p> <p><code class="language-plaintext highlighter-rouge">BRPOPLPUSH</code>: 데이터가 들어오면 오른쪽에서 꺼내서 왼쪽으로 넣는다. 데이터가 있다면 RPOPLPUSH처럼 오른쪽에서 꺼내서 왼쪽에 넣지만 데이터가 없다면 데이터가 들어올때까지 timeout 시간만큼 기다린다.</p> <p>레디스는 싱글쓰레드로 동작한다. 위 3개의 명령어는 레디스에 락을 유도할 수 있기 때문에 사용에 특히 유념해야 한다.</p> </blockquote> <h3 id="13-sets">1.3. Sets</h3> <p>데이터의 중복을 허용하지 않은 일대 다 관계입니다. Sets의 데이터는 기본적으로 해시테이블로 저장되지만 숫자의 경우 정수배열데이터 구조를 가진다. 정수배열 데이터 구조는 해시테이블보다 메모리를 적게 사용합니다.메모리 용량을 중요시한다면 데이터를 정수 값으로 관리하면 좋을것 같다.</p> <p><code class="language-plaintext highlighter-rouge">smembers 대신 sscan 명령어를 사용하자.</code></p> <h3 id="14-hashes">1.4. Hashes</h3> <p>데이터를 field, value 구조로 저장가능하며 rdb의 테이블 구조와 비슷하다. 1개의 key에 field, value 쌍으로 약 40억개를 저장할 수 있다. 하지만 퍼포먼스 측면에서 1,000개정도의 데이터씩 관리하는걸 추천한다고 한다. hashes에 한번 너무 많은 데이터를 넣은 후 삭제할 경우 이슈가 생길 수 있다.</p> <p><code class="language-plaintext highlighter-rouge">hgetall 대신 hscan 명령어를 사용하자.</code></p> <h3 id="15-sorted-set">1.5. Sorted Set</h3> <p>1개의 key에 여러개의 score, value 형태로 저장할 수 있으며 value는 중복된 데이터를 넣을 수 없고 score로 정렬된다. 정렬을 필요로 하는 데이터 관리하면 좋다.</p> <hr/> <h2 id="2-레디스를-운영할때-기억하면-좋은-것들">2. 레디스를 운영할때 기억하면 좋은 것들</h2> <h3 id="21-만료일을-항상-넣는다">2.1. 만료일을 항상 넣는다.</h3> <p>메모리라는 한정된 데이터를 사용하기 때문에 만료일을 지정하여 데이터가 만료일에 지워질 수 있게 관리하자.</p> <h3 id="22-지워지면-안되는-데이터라면-백업을-하자">2.2. 지워지면 안되는 데이터라면 백업을 하자.</h3> <p>지워지면 안되는 데이터라면 RDB + AOF 기능을 사용하여 항상 백업을 하자. RDB 를사용하여 디스크에 바이너리파일로 백업하자.RDB로 백업을 안하는 시간동안에는 AOF로 백업을 하자.</p> <h3 id="23-slowlog로-성능을-확인하자">2.3. Slowlog로 성능을 확인하자</h3> <p>redis는 상당히 빠른 속도를 자랑하는 데이터베이스이기 때문에 조금만 느려지더라도 사용량에 따라 서비스에 큰 영향을 줄 수 있다. 그래서 레디스에 이슈가 있을때 가장 먼저 보는 것 중 하나는 Slowlog이다.</p> <p>slowlog를 통해 command, timestamp, duration, ip 등의 정보를 알 수 있어 오래걸리는 명령어를 찾기 편리합니다. 하지만 slowlog는 기본적으로 메모리에 저장된다. enterprise 버전에서는 파일로 기록도 가능하다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 설정한 시간(microseconds) 이상인 명령을 기록한다.</span>
<span class="c"># 기본값은 10000(10ms) 이다.</span>
<span class="c"># 0으로 입력하면 모든 명령어를 기록한다.</span>
<span class="c"># 비활성화 하려면 음수로 설정.</span>
slowlog-log-slower-than 10000

<span class="c"># 설정한 수 만큼 보관한다.</span>
<span class="c"># 기본값은 128이다.</span>
<span class="c"># 제한은 없으며 꽉차면 오래된 것부터 지우고 새로운 명령어가 기록된다.</span>
slowlog-max-len 128
</code></pre></div></div> <h3 id="24-aof로-명령어-백업하기">2.4. AOF로 명령어 백업하기</h3> <p>명령어들을 파일에 저장 후 레디스가 리부트되면 파일에 저장된 명령어를 실행시켜서 데이터를 복구한다. 기본적으로 appendonly.aof 에 기록되며 입력/수정/삭제명령어 실행될때 마다 버퍼에 기록 후 파일에 기록된다.</p> <p>파일이 너무 커질 것을 대비하여 일정 시간마다 파일을 다시 쓰게 되며 rewrite 시 최종값이 파일에 기록된다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># AOF 기능 사용 유무</span>
appendonly <span class="nb">yes</span>|no

<span class="c"># 파일 이름을 지정한다.</span>
appendfilename <span class="o">[</span>filename]

<span class="c"># 파일에 명령어를 기록하는 시점.</span>
<span class="c"># always: 명령 실행시마다 AOF 파일에 기록.</span>
<span class="c"># everysec: 1초마다 파일에 기록. 1초 사이의 데이터가 유실될 수 있다.</span>
<span class="c"># no: 파일에 기록하는 시점을 os가 지정. 리눅스는 30초 간격으로 기록.</span>
appendfsync <span class="o">[</span>always | everysec | no]

<span class="c"># 이 값을 100으로 했다면 이전 다시 쓰기한 다음 AOF 파일 크기가 100% 증가했으면 다시 쓰기한다.</span>
<span class="c"># 즉 값이 100이고, 이전 rewrite 했을때 1GB 였는데 파일이 2GB 되었다면 (100% 증가) rewrite 한다.</span>

auto-aof-rewrite-percentage <span class="o">[</span> 0-100 <span class="o">]</span>

<span class="c"># 64mb 이하면 rewrite를 하지 않는다.</span>
auto-aof-rewrite-min-size <span class="o">[</span> 64mb <span class="o">]</span>

<span class="c"># AOF 파일을 rewrite 할 때 disk에 쓰는 fsync를 32mb씩 나누어서 한다.</span>
<span class="c"># 이것은 대량 디스크 쓰기로 발생할 수 있는 문제를 피할 수 있다.</span>
aof-rewrite-incremental-fsync <span class="o">[</span> <span class="nb">yes</span> | no <span class="o">]</span>

<span class="c"># AOF 파일을 재작성할 때, Redis는 RDB preamble을 이용하여 더 빠르게 쓰고 복구할 수 있다.</span>
<span class="c"># 이 옵션이 활성화되어 있다면, AOF파일을 재작성하는 작업은 다음 두 가지 스탠자(구)로 구성된다.</span>
<span class="c"># 로딩 중, Redis는 AOF 파일이 "REDIS"라는 문자열로 시작한다면 알아차리고, 고정된 앞 부분은 RDB 파일로 로드하고, 계속해서 뒷 부분은 AOF파일로 로드한다.</span>
<span class="c"># Redis 5.0 부터 기본값 yes. 5.0 이전은 no</span>
aof-use-rdb-preamble <span class="o">[</span> <span class="nb">yes</span> | no <span class="o">]</span>
</code></pre></div></div> <h3 id="25-rdb로-백업하기">2.5. RDB로 백업하기</h3> <p>레디스 데이터를 특정 시점에 바이너리 파일로 저장하는 방식으로 명령어를 저장하는 AOF 파일보다 파일 사이즈가 작기때문에 레디스 시작시 빠르게 데이터를 로드한다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># rdb 저장 시점을 지정한다.</span>
<span class="c"># time동안 count 만큼의 key변경이 발생하면 파일로 저장</span>
save <span class="o">[</span><span class="nb">time</span><span class="o">]</span>, <span class="o">[</span>count]

<span class="c"># 저장된 파일명을 지정</span>
dbfilename <span class="o">[</span> filename <span class="o">]</span>

<span class="c"># yes 일때 파일로 쓰다 실패하면 이 후 모든 쓰기 요청을 막는다.</span>
<span class="c"># no 일때 파일ㄹ을 쓰다 실패하면 이 후 모든 동작으로 정상적으로 처리한다.</span>
<span class="c"># save 명령어일때에만 적용되며 bgsave에서는 적용되지 않는다.</span>
stop-writes-on-bgsave-error <span class="o">[</span> <span class="nb">yes</span> | no <span class="o">]</span>

<span class="c"># 파일을 쓸때 LZF 방식으로 압축할지 정한다.</span>
<span class="c"># 기본값은 yes 이고 저장공간활용 측면에서 유리하다</span>
<span class="c"># 압축할때 CPU를 사용하는데 부담된다면 no.</span>
rdbcompression <span class="o">[</span> <span class="nb">yes</span> | no <span class="o">]</span>

<span class="c"># 파일이 정확히 저장되었는지 확인하는 방법으로 checksum을 파일 끝에 추가할 수 있다.</span>
<span class="c"># 이 기능을 사용하면 파일의 정확성을 높일 수 있지만 파일을 저장할때, 로딩할때 10%정도 성능저하를 일으킬 수 있다.</span>
<span class="c"># 기본값 yes</span>
rdbchecksum <span class="o">[</span> <span class="nb">yes</span> | no <span class="o">]</span>

<span class="c"># RDB 파일을 쓸 때 disk에 쓰는 fsync를 32mb씩 나누어서 한다.</span>
<span class="c"># 이점은 appendfsync가 everysec일 때, 디스크를 나누어서 사용하므로써,</span>
<span class="c"># 1초마다 발생하는 AOF file 디스크 쓰기에 문제가 없도록하기 위함이다.</span>
<span class="c"># 기본값 yes</span>
rdb-save-incremental-fsync <span class="o">[</span> <span class="nb">yes</span> | no <span class="o">]</span>
</code></pre></div></div> <h3 id="26-클러스터-센티널환경이라면-백업은-선택사항이다">2.6. 클러스터, 센티널환경이라면 백업은 선택사항이다.</h3> <p>클러스터와 센티널환경이라면 마스터가 다운되면 자동으로 슬레이브가 마스터로 승격되고 죽었던 이전 마스터노드는 슬레이브로 바뀌기 때문에 데이터 손실이 없다고 봐도 무방하기 때문에 백업을 하지 않아도 된다고 한다.</p> <h3 id="27-데이터-삭제는-lazyfree-기능을-활용하자">2.7. 데이터 삭제는 Lazyfree 기능을 활용하자</h3> <p>데이터를 삭제하는 작업은 레디스에게 있어 큰 부담을 주는 작업이다. 하나의 키에 있는 데이터를 모두 지워야 하게 때문에 키에 담긴 데이터에 따라 수행시간이 얼마나 걸릴지 알 수 없다. 그래서 Redis 4.0 부터는 lazyfree 파라미터가 추가되었다.</p> <ul> <li><code class="language-plaintext highlighter-rouge">lazyfree-lazy-eviction</code>: eviction policy 에 의해 데이터가 지워질때 Del 명령어가 아닌 Unlink 명령으로 삭제한다.</li> <li><code class="language-plaintext highlighter-rouge">lazyfree-lazy-expire</code>: 만료된 키를 제거할때 Unlink 명령어를 사용합니다. 기본적으로 Del 명령어를 사용한다.</li> <li><code class="language-plaintext highlighter-rouge">lazyfree-lazy-server-del</code>: 존재하는 키에 SET 으로 다른 값을 넣을때, 키 이름을 바꿀때, SUNIONSTORE 명령에서 destination key와 source key를 같은 key로 지정했을 때 Unlink 명령어를 사용한다.</li> <li><code class="language-plaintext highlighter-rouge">lazyfree-lazy-user-del</code>: Del 명령이 내부적으로 Unlink로 동작한다.</li> <li><code class="language-plaintext highlighter-rouge">slate-lazy-flush</code>: slave 가 master로부터 전체 데이터를 받을 때 기존 데이터를 삭제하는데 이 때 Flushall async 로 데이터를 삭제하기 때문에 보다 빠르게 동기화 할 수 있다. 단, 비동기여도 삭제중에 데이터를 저장하는 것이기 때문에 메모리가 더 필요하다.</li> </ul> <h3 id="28-maxmemory-를-활용하자">2.8. Maxmemory 를 활용하자</h3> <p>레디스를 캐시로 사용한다면 maxmemory와 eviction policy를 설정하게 활용하자. maxmemory는 32비트 환경에서는 3GB가 기본으로 세팅되어 있고 64비트에서는 무제한으로 설정되어 있다.</p> <p>머신의 메모리를 넘게 되면 레디스는 죽게되고 서비스에도 큰 장애를 줄 수 있다. maxmemory과 eviction policy를 지정하면 메모리가 maxmemory만큼 찻을때 eviction policy 에 따라 자동으로 기존 키가 제거되고 새로운 키를 저장한다.</p> <p>Eviction policy의 종류는 아래와 같이 있다.</p> <ul> <li><code class="language-plaintext highlighter-rouge">noeviction</code>: maxmemory에 도달하면 쓰기/삭제 작업시 오류를 반환한다.</li> <li><code class="language-plaintext highlighter-rouge">allkeys-lru</code>: 새로 추가된 데이터의 용량을 확보하기 위해 최근에 사용하지 않은 키를 제거한다.</li> <li><code class="language-plaintext highlighter-rouge">volatile-lru</code>: 새로 추가된 데이터의 용량을 확보하기 위해 TTL이 설정된 키들 중 최근에 사용하지 않은 키를 제거한다.</li> <li><code class="language-plaintext highlighter-rouge">allkeys-lfu</code>: 새로 추가된 데이터의 용량을 확보하기 위해 사용빈도수가 가장 적은 키를 제거한다. (최근 저장된 키라도 사용 빈도수가 적다면 대상이 될 수 있다.)</li> <li><code class="language-plaintext highlighter-rouge">volatile-lfu</code>: 새로 추가된 데이터의 용량을 확보하기 위해 TTL이 설정된 키들 중 사용빈도 수가 적은 키를 제거한다 (최근 저장된 키라도 사용 빈도수가 적다면 대상이 될 수 있다.)</li> <li><code class="language-plaintext highlighter-rouge">allkeys-random</code>: 새로 추가된 데이터의 용량을 확보하기 위해 무작위로 키를 제거한다.</li> <li><code class="language-plaintext highlighter-rouge">volatile-random</code>: 새로 추가된 데이터의 용량을 확보하기 위해 TTL이 설정된 키들 중 무작위로 키를 제거한다.</li> <li><code class="language-plaintext highlighter-rouge">volatile-ttl</code>: 새로 추가된 데이터의 용량을 확보하기 위해 TTL이 짧은 키를 제거한다.</li> </ul> <p>운영중인 레디스에 적용할 경우 config set 명령어를 사용하고 redis.conf 에도 업데이트한다.</p> <h3 id="29-tcp-keepalive를-조정하자">2.9. tcp-keepalive를 조정하자.</h3> <p>TCP 통신시 3-way handshake 가 필요하다. TCP 통신을 위해 반드시 지켜야하는 표준 규약이면 회피할 수 없는 방법이다. TCP 통신할때마다 3-way handshake를 진행한다면 상당한 리소스가 소모되기때이다. 통신이 지속적으로 이루어진다면 한번 열어둔 세션을 없애지 않고 사용하면 효율적이라고 판단이 되었고 이를 위해 TCP keepalive 개념이 생겨나게 되었다.</p> <p>tcp keepalive 기능은 커넥션을 유지하기 때문에 새로운 요청이 왔을때 기존 커넥션을 사용하여 통신을 할 수 있다. 하지만 반대로 요청을 받아들이지 않는 좀비 커넥션이 생길 수 있다는 단점도 가지고 있다.</p> <p>좀비 커넥션 생성을 막기 위해 tcp-keepalive에 초를 설정하면 설정한 시간마다 연결이 유지되었는지를 확인하고 응답을 받았다면 연결을 유지하고 응답을 받지 못한다면 소켓을 닫는다.</p> <blockquote class="block-tip"> <h5 id="tip">Tip</h5> <p>Redis 버전 3.2.1 부터 기본값 300이며 값이 0 이면 계속 열어둔다.</p> </blockquote> <h3 id="210-한번에-여러-명령어를-쓸-경우-pipeline-활용하자">2.10. 한번에 여러 명령어를 쓸 경우 pipeline 활용하자.</h3> <p>여러 명령어를 한번에 실행할 경우 매번 명령어를 실행하기 보다 pipeline 을 사용하여 명령어를 실행하면 매번 커넥션을 맺어야하는 리소스를 줄 일 수 있다.</p> <h3 id="211-tcp-backlog-사이즈-조절">2.11. Tcp backlog 사이즈 조절</h3> <p>backlog 는 응답을 클라이언트에게 보내고 잘받았는지 체크 후 backlog 에서 제거한다. 동시에 많은 명령어가 몰려올때 backlog에 쌓이는데 backlog 사이즈보다 backlog에 쌓이는 수가 많으면 이슈가 발생할 수 있다.</p> <h3 id="212-info-all-로-서버상태-확인하기">2.12. Info all 로 서버상태 확인하기</h3> <p>Info all로 레디스의 상태를 확인 할 수 있다. commandstats 영역에서는 지금까지 사용된 명령어의 통계를 볼 수 있기때문에 어떤 명령어에서 많은 시간이 걸렸는지 확인이 가능하다.info all 에 보이는 통계는 config resetstat 으로 초기화가 가능하다.</p> <h2 id="3-참고">3. 참고</h2> <ul> <li><a href="http://redisgate.kr/redis/configuration/internal_quicklist.php">http://redisgate.kr/redis/configuration/internal_quicklist.php</a></li> <li><a href="https://www.linkedin.com/pulse/performance-tuning-redis-lalit-kumar-jain/">https://www.linkedin.com/pulse/performance-tuning-redis-lalit-kumar-jain/</a></li> <li><a href="https://redis.com/blog/redis-running-slowly-heres-what-you-can-do-about-it/">https://redis.com/blog/redis-running-slowly-heres-what-you-can-do-about-it/</a></li> <li><a href="http://redisgate.kr/redis/configuration/param_save.php">http://redisgate.kr/redis/configuration/param_save.php</a></li> <li><a href="https://redis.io/topics/clients">https://redis.io/topics/clients</a></li> <li><a href="https://mozi.tistory.com/369">https://mozi.tistory.com/369</a></li> </ul>]]></content><author><name></name></author><category term="Redis"/><category term="redis,"/><category term="레디스,"/><category term="Redis"/><category term="Performance,"/><category term="Eviction"/><category term="Policy,"/><category term="Redis"/><category term="LazyFree"/><summary type="html"><![CDATA[레디스에 대한 간단한 설명과 성능향상시키기]]></summary></entry><entry><title type="html">Apple login 사용해보기</title><link href="https://hwangrolee.github.io/blog/apple-login-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/" rel="alternate" type="text/html" title="Apple login 사용해보기"/><published>2024-12-01T00:00:00+00:00</published><updated>2024-12-01T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/apple-login-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/apple-login-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/"><![CDATA[<h3 id="0-준비사항">0. 준비사항</h3> <p><a href="https://developer.apple.com/kr/news/?id=09122019b">애플 로그인 뉴스</a></p> <p>https://developer.apple.com/account 에서 필요한 정보를 알 수 있습니다.</p> <h3 id="1-ceriticates-ids--profile에서-세팅정보를-알수-있습니다">1. Ceriticates, IDs &amp; Profile에서 세팅정보를 알수 있습니다.</h3> <figure> <picture> <img src="/assets/img/posts/2024-12-01-apple-login/apple_login_1.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" alt="Ceriticates, IDs &amp; Profile에서 세팅정보를 알수 있습니다." title="Ceriticates, IDs &amp; Profile에서 세팅정보를 알수 있습니다." loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="2-identifiers-탭에서-본인의-identifier를-선택하세요">2. Identifiers 탭에서 본인의 identifier를 선택하세요</h3> <figure> <picture> <img src="/assets/img/posts/2024-12-01-apple-login/apple_login_2.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" alt="Identifiers 탭에서 본인의 identifier를 선택하세요" title="Identifiers 탭에서 본인의 identifier를 선택하세요" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="3-apple-id-prefix--team-id-bundle-id--client-id">3. Apple ID Prefix = Team ID, Bundle ID = Client ID</h3> <p>Apple ID Prefix는 Team ID 입니다.</p> <p>Bundle ID는 ClientId 입니다.</p> <figure> <picture> <img src="/assets/img/posts/2024-12-01-apple-login/apple_login_3.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" alt="Apple ID Prefix=Team ID, Bundle ID=Client ID" title="Apple ID Prefix=Team ID, Bundle ID=Client ID" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="4-로그인-기능을-활성화하세요">4. 로그인 기능을 활성화하세요.</h3> <figure> <picture> <img src="/assets/img/posts/2024-12-01-apple-login/apple_login_4.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" alt="로그인 기능을 활성화하세요." title="로그인 기능을 활성화하세요." loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="5-keys-에서-애플-로그인을-위한-서비스를-생성하세요">5. Keys 에서 애플 로그인을 위한 서비스를 생성하세요</h3> <figure> <picture> <img src="/assets/img/posts/2024-12-01-apple-login/apple_login_5.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" alt="Keys 에서 애플 로그인을 위한 서비스를 생성하세요" title="Keys 에서 애플 로그인을 위한 서비스를 생성하세요" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="6-key-id--private-key-를-확인하세요">6. key id &amp; private key 를 확인하세요.</h3> <p>Download 버튼을 클릭하면 private key 를 다운받으실 수 있습니다.</p> <figure> <picture> <img src="/assets/img/posts/2024-12-01-apple-login/apple_login_6.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" alt="key id &amp; private key 를 확인하세요." title="key id &amp; private key 를 확인하세요." loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="7-client_secret-을-구해보겠습니다">7. client_secret 을 구해보겠습니다.</h3> <p>jwt를 설치합니다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>gem <span class="nb">install </span>jwt
</code></pre></div></div> <p>아래 스크립트를 client_secret.rb 파일로 생성합니다.</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'jwt'</span>
<span class="n">key_file</span> <span class="o">=</span> <span class="s1">'private_key.p8'</span>
<span class="n">team_id</span> <span class="o">=</span> <span class="s1">'team_id'</span>
<span class="n">client_id</span> <span class="o">=</span> <span class="s1">'client_id'</span>
<span class="n">key_id</span> <span class="o">=</span> <span class="s1">'key_id'</span>
<span class="n">ecdsa_key</span> <span class="o">=</span> <span class="no">OpenSSL</span><span class="o">::</span><span class="no">PKey</span><span class="o">::</span><span class="no">EC</span><span class="p">.</span><span class="nf">new</span> <span class="no">IO</span><span class="p">.</span><span class="nf">read</span> <span class="n">key_file</span>
<span class="n">headers</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">'kid'</span> <span class="o">=&gt;</span> <span class="n">key_id</span>
<span class="p">}</span>
<span class="n">claims</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">'iss'</span> <span class="o">=&gt;</span> <span class="n">team_id</span><span class="p">,</span>
  <span class="s1">'iat'</span> <span class="o">=&gt;</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_i</span><span class="p">,</span>
  <span class="s1">'exp'</span> <span class="o">=&gt;</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_i</span> <span class="o">+</span> <span class="mi">86400</span><span class="o">*</span><span class="mi">180</span><span class="p">,</span>
  <span class="s1">'aud'</span> <span class="o">=&gt;</span> <span class="s1">'https://appleid.apple.com'</span><span class="p">,</span>
  <span class="s1">'sub'</span> <span class="o">=&gt;</span> <span class="n">client_id</span>
<span class="p">}</span>
<span class="n">token</span> <span class="o">=</span> <span class="no">JWT</span><span class="p">.</span><span class="nf">encode</span> <span class="n">claims</span><span class="p">,</span> <span class="n">ecdsa_key</span><span class="p">,</span> <span class="s1">'ES256'</span><span class="p">,</span> <span class="n">headers</span>
<span class="nb">puts</span> <span class="n">token</span>
</code></pre></div></div> <p>client_secret.rb 실행하여 client_secret 을 구합니다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ruby client_secret.rb
</code></pre></div></div> <blockquote class="block-tip"> <h5 id="tip">TIP</h5> <p>테스트할 때에는 웹을 사용하는데 그럴때에는 Client ID 에 Bundle ID가 아닌 Group ID를 넣어주면 더욱 편하게 테스트를 할 수있습니다.</p> </blockquote> <h3 id="8-토큰을-구하기-전에-먼저-사용자인증을-통해-code-값을-구합니다">8. 토큰을 구하기 전에 먼저 사용자인증을 통해 code 값을 구합니다.</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://appleid.apple.com/auth/authorize?response_type<span class="o">=</span>code&amp;client_id<span class="o">={</span>client_id<span class="o">}</span>&amp;redirect_uri<span class="o">={</span>redirect_uri<span class="o">}</span>
</code></pre></div></div> <figure> <picture> <img src="/assets/img/posts/2024-12-01-apple-login/apple_login_7.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" alt="토큰을 구하기 전에 먼저 사용자인증을 통해 code 값을 구합니다." title="토큰을 구하기 전에 먼저 사용자인증을 통해 code 값을 구합니다." loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <blockquote class="block-warning"> <h5 id="확인사항-1">확인사항 1</h5> <p>이 부분에서 상당히 시간소모를 했습니다. Client_id가 어떤것인지 애플쪽에서 정확히 명시하지 않아 헷갈려서 다른 값을 넣었고 에러코드가 client_id 가 틀리다고 나오질 않았기 때문에 다른 부분에서 문제가 있는줄 알고 구글서치만 수시간… 이 부분에서 redirect_uri를 입력했는데도 잘 안된다면 client_id 부터 의심하세요.</p> </blockquote> <blockquote class="block-warning"> <h5 id="확인사항-2">확인사항 2</h5> <p>만약 리디렉션됐는데도 Code가 안나온다면 response_mode, scope를 파라미터로 전달했는지 확인해보세요. response_mode와 scope를 전달하면 code를 받을 수 없습니다</p> </blockquote> <blockquote class="block-warning"> <h5 id="확인사항-3">확인사항 3</h5> <p>위 부분을 실행하면 xxx.com/?code={code} 형태로 리디렉션되며 code를 알 수 있습니다. 참고로 code는 5분간 유효한 키입니다.</p> </blockquote> <h3 id="9-code를-구했다면-이제는-access-token을-구할-수-있습니다">9. code를 구했다면 이제는 Access Token을 구할 수 있습니다.</h3> <p>id_token은 jwt로 인코딩되어있으며 https://jwt.io 에서 디코딩해서 데이터를 볼 수 있습니다.</p> <p>참고 : <a href="https://developer.apple.com/documentation/sign_in_with_apple/generate_and_validate_tokens?source=post_page-----a5b70fbf2f02--------------------------------">Generate and validate tokens</a></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-XPOST</span> <span class="s2">"https://appleid.apple.com/auth/token"</span> <span class="nt">-H</span> <span class="s2">"Content-Type: application/x-www-form-urlencoded"</span> <span class="nt">-d</span> <span class="s2">"client_id={client_id}&amp;client_secret={client_secret}&amp;grant_type=authorization_code&amp;code={code}"</span> | json_pp
<span class="o">{</span>
    <span class="s2">"refresh_token"</span> : <span class="s2">""</span>,
    <span class="s2">"expires_in"</span> : 3600,
    <span class="s2">"id_token"</span> : <span class="s2">""</span>,
    <span class="s2">"access_token"</span> : <span class="s2">""</span>,
    <span class="s2">"token_type"</span> : <span class="s2">"Bearer"</span>
<span class="o">}</span>
</code></pre></div></div> <p>이메일은 이메일 공유하기로 로그인한 경우 애플ID 로 보이고, 가리기를 선택한 경우 @private.appleid.com 으로 이메일이 생성되어집니다.</p> <p>sub라는 필드는 하나의 애플계정의 유니크한 값이니 이메일로 유저를 구분하지 않고 sub필드로 유저를 구분할 수 있습니다.</p> <h3 id="참고">참고</h3> <ul> <li><a href="https://sarunw.com/posts/sign-in-with-apple-4/">sign-in-with-apple-4</a></li> <li><a href="https://developer.apple.com/documentation/sign_in_with_apple/generate_and_validate_tokens">generate_and_validate_tokens</a></li> <li><a href="https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_rest_api/authenticating_users_with_sign_in_with_apple">authenticating_users_with_sign_in_with_apple</a></li> </ul>]]></content><author><name></name></author><category term="로그인"/><category term="애플로그인,"/><category term="AppleLogin"/><summary type="html"><![CDATA[Apple Login을 직접 구현하는 방법을 알아봅니다.]]></summary></entry><entry><title type="html">Spring boot에서 Elastic search 연동하며 느낀점</title><link href="https://hwangrolee.github.io/blog/Spring-boot%EC%97%90%EC%84%9C-Elasticsearch-%EC%97%B0%EB%8F%99%ED%95%98%EB%A9%B0-%EB%8A%90%EB%82%80%EC%A0%90/" rel="alternate" type="text/html" title="Spring boot에서 Elastic search 연동하며 느낀점"/><published>2019-05-11T13:05:00+00:00</published><updated>2019-05-11T13:05:00+00:00</updated><id>https://hwangrolee.github.io/blog/Spring-boot%EC%97%90%EC%84%9C-Elasticsearch-%EC%97%B0%EB%8F%99%ED%95%98%EB%A9%B0-%EB%8A%90%EB%82%80%EC%A0%90</id><content type="html" xml:base="https://hwangrolee.github.io/blog/Spring-boot%EC%97%90%EC%84%9C-Elasticsearch-%EC%97%B0%EB%8F%99%ED%95%98%EB%A9%B0-%EB%8A%90%EB%82%80%EC%A0%90/"><![CDATA[<p>Spring boot에서 Elasticsearch를 ORM으로 시도했다가 Rest Client로 바꾼 이유에 대해서 설명할게요.</p> <h4 id="시작은-orm으로-개발하기">시작은 ORM으로 개발하기</h4> <p>elasticsearch7 을 docker로 설치하여 curl로 테스트를 하다 spring boot로 테스트를 하고 싶어 spring boot 2.1.4 기반으로 개발을 해 보았습니다.</p> <p>spring boot에서 elasticsearch와 연동할때 <a href="https://mvnrepository.com/artifact/org.springframework.data/spring-data-elasticsearch/3.1.6.RELEASE">spring-boot-starter-data-elasticsearch</a>을 사용했는데 아직까진 elasticsearch 7에는 연결이 안되더군요…</p> <p>처음 시도하는거라 설정이 잘못된건가? spring에서 docker로 설치한 elasticsearch에 접근하지 못한건가? 싶어 많은 시간 삽질을 했습니다.</p> <p>그 결과, spring-data-elasticsearch와 elasticsearch는 버전에 큰 영향을 받기 때문에 연동시 문제가 될 수 있다고 합니다.</p> <p>그래서 제가 선택한 것은 ORM을 사용해보고 싶은 마음에 elasticsearch를 6.5로 downgrade 했고 spring-boot-starter-data-elasticsearch를 사용해 보았습니다.</p> <h4 id="orm에서-rest-client로-바꾼-이유">ORM에서 Rest Client로 바꾼 이유</h4> <p>결론은 저의 코딩스타일을 살리기 힘들어서 이 방법은 포기하고 Rest Client로 공부를 시작했습니다.</p> <blockquote> <p>저는 코딩시 <a href="https://en.wikipedia.org/wiki/Camel_case"><strong>CamelCase</strong></a>를 선호하고 저장소(database, elasticsearch, redis, ETC.)는 <a href="https://en.wikipedia.org/wiki/Snake_case"><strong>SnakeCase</strong></a>를 선호합니다.</p> </blockquote> <blockquote> <p>spring boot에서 <strong>@JsonProperty</strong>로 Elasticsearch field를 지정할 수 있었지만 elasticsearch 6.2.2 이후에는 지원하지 않아 ORM을 통해 Elasticsearch를 관리하고 싶다면 코딩을 <strong>SnakeCase</strong>로 바꾸거나 Elasticsearch field명을 <strong>CamelCase</strong>로 바꾸어야 하지만 그러긴 싫었습니다.</p> </blockquote> <h4 id="장점">장점</h4> <ul> <li>rest client로 연동할 경우 elasticsearch가 업데이트 될 경우 spring-data-elasticsearch가 새로운 elasticsearch를 지원할때까지 기다리지 않고 사용할 수 있습니다.</li> <li>elasticsearch의 다양한 쿼리는 직접 만들어볼 수 있습니다. 신나겠다.</li> <li>직접 쿼리를 만들어볼 수 있는 만큼 튜닝도 가능하니 성능을 향상시키기 위해 많은 공부를 할 수 있을거에요.</li> </ul> <h4 id="단점">단점</h4> <ul> <li>직접 쿼리를 만들어야하니 귀찮습니다.</li> </ul>]]></content><author><name></name></author><category term="Elastic"/><category term="Search"/><summary type="html"><![CDATA[Spring boot에서 Elasticsearch를 ORM으로 시도했다가 Rest Client로 바꾼 이유에 대해서 설명할게요.]]></summary></entry><entry><title type="html">Elasticsearch Simple Query String Query에 대해서 알아보기</title><link href="https://hwangrolee.github.io/blog/Elasticsearch-Simple-Query-String-Query%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/" rel="alternate" type="text/html" title="Elasticsearch Simple Query String Query에 대해서 알아보기"/><published>2019-05-09T13:45:00+00:00</published><updated>2019-05-09T13:45:00+00:00</updated><id>https://hwangrolee.github.io/blog/Elasticsearch-Simple-Query-String-Query%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/Elasticsearch-Simple-Query-String-Query%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/"><![CDATA[<p><em>query_string</em>과는 달리 <em>simple_query_string</em>쿼리는 예외를 throw하지 않으며 쿼리의 잘못된 부분을 삭제합니다.</p> <p><em>simple_query_string</em>은 특수문자를 통해 연산자를 선언할 수 있습니다.</p> <p><strong>+</strong> : AND operation</p> <p><strong>|</strong> : OR operation</p> <p><strong>-</strong> : 싱글 토큰을 무시합니다.</p> <p><strong>“</strong> : 검색어 구문 그대로 검색하기 위해 사용합니다.</p> <p><strong>*</strong> : 단어의 끝에 선언하는 prefix query</p> <p><strong>(</strong> <strong>)</strong> : 구문을 감쌀때 사용</p> <h4 id="example">example</h4> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="s2">"localhost:9200/sales-records/_search?pretty"</span> <span class="nt">-H</span> <span class="s2">"Content-Type:application/json"</span> <span class="nt">-d</span> <span class="s1">'
{
  "query": {
    "simple_query_string": {
      "fields": ["country"],
      "query": "kor* -south"
    }
  }
}'</span>
</code></pre></div></div> <p>kor로 시작하는 단어가 들어가며 south라는 단어는 빼고 검색합니다.</p> <blockquote> <p>참고사이트</p> <ol> <li>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-simple-query-string-query.html</li> </ol> </blockquote>]]></content><author><name></name></author><category term="Elastic"/><category term="Search"/><summary type="html"><![CDATA[Elasticsearch Simple Query String Query에 대해서 알아보기]]></summary></entry><entry><title type="html">Elasticsearch Common Terms Query에 대해서 알아보기</title><link href="https://hwangrolee.github.io/blog/Elasticsearch-Common-Terms-Query%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/" rel="alternate" type="text/html" title="Elasticsearch Common Terms Query에 대해서 알아보기"/><published>2019-05-09T00:00:00+00:00</published><updated>2019-05-09T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/Elasticsearch-Common-Terms-Query%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/Elasticsearch-Common-Terms-Query%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/"><![CDATA[<p>쿼리의 모든 term에는 비용이 있습니다.</p> <p>만약 “The brown fox”를 검색하려면 “the”, “brown”, “fox”로 검색을 하게 되며 “the”의 경우 많은 문서와 일치하므로 다른 두 용어보다 영향력이 적습니다.</p> <p>이러한 경우에 예전에는 빈도가 높은 용어를 무시하는 것이었습니다. “the”를 <em>stopword</em>로 처리하여 인덱스크기를 줄이고 실행하는 term 쿼리의 수를 줄이는 것입니다.</p> <p>이 방법의 문제점 <em>stopwords</em>가 관련성에는 미치는 영향이 적지만 중요한 부분도 존재합니다. <em>stopword</em>를 제거할 경우 정확도는 떨어지게됩니다.</p> <p>예를 들어 “happy” 와 “not happy”를 구분할 수 없습니다.</p> <p><em>common terms query</em>는 <em>query terms</em>를 더 중요한 그룹, 덜 중요한 그룹으로 나뉩니다.</p> <ol> <li> <p>중요한 용어와 일치하는 문서를 검색합니다. 이는 검색으로 나온 결과 문서가 적을 수록 관련성에 더 큰 영향력을 준다는 말이 됩니다.</p> </li> <li> <p>덜 중요한 용어(빈번하게 존재하며 낮은 관련성을 띄는 단어)에 대한 쿼리를 실행합니다. 그러나 모든 문서에 대한 관련성 점수를 계산하는 대신 첫번째 쿼리에서 이미 일치하는 문서의 <strong>_score</strong> 만 계산합니다.</p> </li> </ol> <p>이러한 방식으로 <em>high frequency terms</em>(많이 존재하는 단어?)에 대한 성능 저하 비용을 지불하지 않고도 관련도 계산을 향상시킬 수 있습니다.</p> <p>만약 쿼리에 <em>high frequency terms</em>로만 이루어져 있다면 <em>and</em> 쿼리로 실행합니다.</p> <p>Terms는 <em>relative frequency</em>(0.0 .. 1.0) 혹은 <em>absolute frequency</em>(&gt;=1)로 지정할 수 있는 <strong>cutoff_frequency</strong>에 따라 높거나 낮은 빈도 그룹으로 할당됩니다.</p> <h3 id="example">example</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="s2">"localhost:9200/sales-records/_search?pretty"</span> <span class="nt">-H</span> <span class="s2">"Content-Type:application/json"</span> <span class="nt">-d</span> <span class="s1">'
{
  "query": {
    "common": {
      "country": {
        "query": "Republic of",
        "cutoff_frequency": 0.001,
        "low_freq_operator": "and"
      }
    }
  }
}'</span>
</code></pre></div></div> <blockquote> <p>참고사이트</p> <ol> <li>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-common-terms-query.html</li> </ol> </blockquote>]]></content><author><name></name></author><category term="Elastic"/><category term="Search"/><summary type="html"><![CDATA[Elasticsearch Common Terms Query에 대해서 알아보기]]></summary></entry><entry><title type="html">Elasticsearch Query String Query에 대해서 알아보기</title><link href="https://hwangrolee.github.io/blog/Elasticsearch-Query-String-Query%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/" rel="alternate" type="text/html" title="Elasticsearch Query String Query에 대해서 알아보기"/><published>2019-05-09T00:00:00+00:00</published><updated>2019-05-09T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/Elasticsearch-Query-String-Query%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/Elasticsearch-Query-String-Query%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/"><![CDATA[<p><em>query string</em>쿼리는 연산자를 중심으로 텍스트를 분할하여 쿼리를 분석합니다.</p> <h4 id="example">example</h4> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="s2">"localhost:9200/sales-records/_search?pretty"</span> <span class="nt">-H</span> <span class="s2">"Content-Type:application/json"</span> <span class="nt">-d</span> <span class="s1">'
{
  "query": {
    "query_string": {
      "default_field": "country",
      "query": "(south africa) OR (south korea)"
    }
  }
}'</span>
</code></pre></div></div> <p>“south africa”와 “south korea”로 나뉘며 각 부분은 분석기에 의해서 독립적으로 분석됩니다.</p> <p>공백은 연산자로 간주되지 않아 공백 상태 그대로 분석기에 전달됩니다. 만약 각 단어를 개별적으로 쿼리하길 원한다면 단어에 연산자를 추가해야합니다.</p> <p>예를 들어, “south africa”을 검색하시려면 (south AND africa)으로 입력하시면 되며 “(south africa) OR (south korea)”는 “(south AND africa) OR (south AND korea)” 로 하시면 됩니다.</p> <p>여러 필드를 통해 검색을 하고 싶다면 <em>type</em> 속성을 사용하시면 됩니다. 기본값은 <em>“best_fields”</em>입니다. 그리고 <em>fields</em>를 검색할 필드명을 명시할 수 있습니다.</p> <h4 id="example-1">example</h4> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="s2">"localhost:9200/sales-records/_search?pretty"</span> <span class="nt">-H</span> <span class="s2">"Content-Type:application/json"</span> <span class="nt">-d</span> <span class="s1">'
{
  "query": {
    "query_string": {
      "query": "south AND asia",
      "fields": ["country", "message"]
    }
  }
}'</span>
</code></pre></div></div> <blockquote> <p>참고사이트</p> <ol> <li>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html</li> </ol> </blockquote>]]></content><author><name></name></author><category term="Elastic"/><category term="Search"/><summary type="html"><![CDATA[Elasticsearch Query String Query에 대해서 알아보기]]></summary></entry><entry><title type="html">Elasticsearch Multi Match Query에 대해서 알아보기</title><link href="https://hwangrolee.github.io/blog/Elasticsearch-Multi-Match-Query%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/" rel="alternate" type="text/html" title="Elasticsearch Multi Match Query에 대해서 알아보기"/><published>2019-05-08T10:35:00+00:00</published><updated>2019-05-08T10:35:00+00:00</updated><id>https://hwangrolee.github.io/blog/Elasticsearch-Multi-Match-Query%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/Elasticsearch-Multi-Match-Query%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/"><![CDATA[<p>쿼리를 시도할때 검색어를 하나의 필드가 아닌 여러개의 필드를 통해 검색을 하고 싶다면 <strong>Multi Match Query</strong>를 사용하세요.</p> <p>단, 한번에 검색할 수 있는 필드 수에는 제한이 있으며 기본값은 1024개이며 <em>indices.query.bool.max_clause_count</em> 검색설정에 정의되어있습니다.</p> <p>만약 검색하려는 필드가 비어있다면 모든 필드를 검색합니다. 단, 매핑타입에 맞는 필드로 한정하는 것 같습니다. 하지만 검색하려는 필드가 비어있을 일은 거의 없겠죠?</p> <h4 id="example1">example1</h4> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="s2">"localhost:9200/sales-records/_search?pretty"</span> <span class="nt">-H</span> <span class="s2">"Content-Type:application/json"</span> <span class="nt">-d</span> <span class="s1">'
{
  "query": {
    "multi_match": {
      "query": "south",
      "fields": ["country", "message"]
    }
  }
}'</span>
</code></pre></div></div> <p><em>“south”</em>라는 검색어를 <em>country</em>, <em>message</em>필드에서 검색합니다.</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"took"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">23</span><span class="p">,</span><span class="w">
  </span><span class="nl">"timed_out"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_shards"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"total"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="nl">"successful"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="nl">"skipped"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="nl">"failed"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"hits"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"total"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"value"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">10000</span><span class="p">,</span><span class="w">
      </span><span class="nl">"relation"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"gte"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"max_score"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mf">4.295763</span><span class="p">,</span><span class="w">
    </span><span class="nl">"hits"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
      </span><span class="err">...</span><span class="w">
    </span><span class="p">]</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>위 예제는 기본적인 Multi Match Query입니다.</p> <p>이외에도 유형을 정의하여 검색을 할 수 있습니다.</p> <h3 id="best_fields">best_fields</h3> <p><em>best_fields</em>는 동일한 필드에서 여러 단어를 검색할때 유용합니다. 그리고 정확도가 높은 필드의 <em>score</em>를 사용하지만 <em>tie_breaker</em>가 지정되 있다면 정확도가 높은 필드의 <em>_score</em> + 다른 모든 필드의 (<em>tie_breaker</em> * <em>_score</em>)로 score를 계산합니다.</p> <p><em>best_fields</em>의 동작방식은 각 필드에 대해 <em>match query</em>를 생성하고 <em>dis_max</em> 쿼리에서 래핑하여 가장 일치하는 단일 필드를 찾습니다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="s2">"localhost:9200/sales-records/_search?pretty"</span> <span class="nt">-H</span> <span class="s2">"Content-Type:application/json"</span> <span class="nt">-d</span> <span class="s1">'
{
  "query": {
    "multi_match": {
      "query": "south",
      "fields": ["country", "*ssage"],
      "type": "best_fields",
      "tie_breaker":0.3
    }
  }
}'</span>
</code></pre></div></div> <p>위와 같은 쿼리는 다음과 같습니다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="s2">"localhost:9200/sales-records/_search?pretty"</span> <span class="nt">-H</span> <span class="s2">"Content-Type:application/json"</span> <span class="nt">-d</span> <span class="s1">'
{
  "query": {
    "dis_max": {
      "queries": [
        { "match": { "country": "south" }},
        { "match": { "message": "south" }}
      ],
      "tie_breaker": 0.3
    }
  }
}'</span>
</code></pre></div></div> <h3 id="most_fields">most_fields</h3> <p><em>most_fields</em>는 다른 방식으로 같은 텍스트를 analyze 해서 여러 필드를 쿼리할때 유용합니다.</p> <p>예를들어 필드가 다른 형태소 분석기를 쓰는 경우입니다.</p> <h3 id="cross_fields">cross_fields</h3> <p><em>cross_fields</em>는 모든 필드를 하나의 필드 처럼 보고 검색을 진행합니다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="s2">"localhost:9200/sales-records/_search?pretty"</span> <span class="nt">-H</span> <span class="s2">"Content-Type:application/json"</span> <span class="nt">-d</span> <span class="s1">'
{
  "query": {
    "multi_match": {
      "query": "asia korea",
      "type": "cross_fields",
      "operator": "and",
      "fields": ["region", "country"]
    }
  }
}'</span>

</code></pre></div></div> <h3 id="phrase">phrase</h3> <p>각 필드에서 <em>match_phrase</em> 쿼리를 실행하고 최상의 필드에서 <em>_score</em>를 사용합니다.</p> <h3 id="phrase_prefix">phrase_prefix</h3> <p>각 필드에서 <em>match_phrase_prefix</em> 쿼리를 실행하고 각 필드의 <em>_score</em>를 사용합니다.</p> <blockquote> <p>참고사이트</p> <ol> <li>https://gist.github.com/einsub/86638954d3d6168bdfbe772c3f3d3d90</li> <li>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html#type-best-fields</li> </ol> </blockquote>]]></content><author><name></name></author><category term="Elastic"/><category term="Search"/><summary type="html"><![CDATA[Elasticsearch Multi Match Query에 대해서 알아보기]]></summary></entry></feed>