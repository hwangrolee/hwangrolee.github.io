<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://hwangrolee.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://hwangrolee.github.io/" rel="alternate" type="text/html" hreflang="ko"/><updated>2025-08-30T04:42:46+00:00</updated><id>https://hwangrolee.github.io/feed.xml</id><title type="html">이황로의 포트폴리오</title><subtitle>풀스택 개발자로서 시스템 최적화와 성능 개선에 보람을 느낍니다. 안정적이고 확장 가능한 서비스를 만듭니다.</subtitle><entry><title type="html">현재 상태만 저장하지 말고 모든 변화를 기록하라, 이벤트소싱으로 데이터 히스토리 완벽 관리하기</title><link href="https://hwangrolee.github.io/blog/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%86%8C%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC-%EC%99%84%EB%B2%BD-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="현재 상태만 저장하지 말고 모든 변화를 기록하라, 이벤트소싱으로 데이터 히스토리 완벽 관리하기"/><published>2025-08-08T00:00:00+00:00</published><updated>2025-08-08T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%86%8C%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC-%EC%99%84%EB%B2%BD-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%86%8C%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC-%EC%99%84%EB%B2%BD-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/"><![CDATA[<blockquote> <p>“데이터베이스에 현재 상태만 저장하는 게 당연하다고 생각했다면, 이 글을 끝까지 읽어보세요.”</p> </blockquote> <h2 id="들어가며-왜-이벤트소싱을-알아야-할까요">들어가며: 왜 이벤트소싱을 알아야 할까요?</h2> <p>주니어 개발자 시절, 저는 항상 이런 의문이 있었습니다.</p> <ul> <li> <p><em>“계좌 잔액이 10만 원인 건 알겠는데, 이 돈이 언제 어떻게 들어왔는지는 왜 따로 관리해야 하지?”</em></p> </li> <li> <p><em>“사용자 프로필이 변경됐을 때, 이전 상태는 왜 날려버리는 거지?”</em></p> </li> </ul> <p>바로 이런 의문에서 시작되는 것이 <strong>이벤트소싱(Event Sourcing)</strong>입니다.</p> <hr/> <h2 id="1-이벤트소싱이란--동영상-vs-스냅샷의-차이">1. 이벤트소싱이란? — 동영상 vs 스냅샷의 차이</h2> <h3 id="전통적인-방식-스냅샷-저장"><strong>전통적인 방식: 스냅샷 저장</strong></h3> <p>대부분의 시스템은 데이터의 <strong>현재 상태</strong>만 저장합니다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 일반적인 계좌 테이블</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">accounts</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">BIGINT</span><span class="p">,</span>
    <span class="n">balance</span> <span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>  <span class="c1">-- 현재 잔액만 저장</span>
<span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">accounts</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100000</span><span class="p">);</span>
<span class="c1">-- 10만 원이 있다는 것만 알 수 있음</span>
</code></pre></div></div> <p>이는 마치 <strong>현재 모습의 사진 한 장</strong>만 저장하는 것과 같습니다.</p> <h3 id="이벤트소싱-방식-모든-변화-기록"><strong>이벤트소싱 방식: 모든 변화 기록</strong></h3> <p>이벤트소싱은 <strong>지금까지 일어난 모든 사건(이벤트)</strong>을 순서대로 저장합니다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 이벤트소싱 방식</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">account_events</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">BIGINT</span><span class="p">,</span>
    <span class="n">account_id</span> <span class="nb">BIGINT</span><span class="p">,</span>
    <span class="n">event_type</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
    <span class="n">amount</span> <span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
    <span class="nb">timestamp</span> <span class="nb">TIMESTAMP</span><span class="p">,</span>
    <span class="n">event_data</span> <span class="n">JSON</span>
<span class="p">);</span>

<span class="c1">-- 실제 저장되는 이벤트들</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">account_events</span> <span class="k">VALUES</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">'AccountCreated'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">'2025-08-01 09:00:00'</span><span class="p">,</span> <span class="s1">'{"initial_balance": 0}'</span><span class="p">),</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">'MoneyDeposited'</span><span class="p">,</span> <span class="mi">50000</span><span class="p">,</span> <span class="s1">'2025-08-01 10:30:00'</span><span class="p">,</span> <span class="s1">'{"source": "salary"}'</span><span class="p">),</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">'MoneyDeposited'</span><span class="p">,</span> <span class="mi">30000</span><span class="p">,</span> <span class="s1">'2025-08-05 14:20:00'</span><span class="p">,</span> <span class="s1">'{"source": "bonus"}'</span><span class="p">),</span>
<span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">'MoneyDeposited'</span><span class="p">,</span> <span class="mi">20000</span><span class="p">,</span> <span class="s1">'2025-08-07 16:45:00'</span><span class="p">,</span> <span class="s1">'{"source": "refund"}'</span><span class="p">);</span>
</code></pre></div></div> <p>현재 잔액을 알고 싶다면? <strong>이벤트들을 순서대로 재생</strong>하면 됩니다.</p> <ul> <li>0 + 50,000 + 30,000 + 20,000 = <strong>100,000원</strong></li> </ul> <p>이는 <strong>처음부터 지금까지의 모든 동영상</strong>을 저장하는 것과 같습니다.</p> <hr/> <h2 id="2-왜-필요한가요--실무에서-마주치는-문제들">2. 왜 필요한가요? — 실무에서 마주치는 문제들</h2> <h3 id="시나리오-1-고객-문의-상황"><strong>시나리오 1: 고객 문의 상황</strong></h3> <blockquote> <p><em>“어? 제 계좌에서 3만 원이 사라졌어요. 언제 어떻게 빠진 건가요?”</em></p> </blockquote> <p><strong>전통적인 방식의 한계:</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">balance</span> <span class="k">FROM</span> <span class="n">accounts</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="c1">-- 결과: 70000</span>
<span class="c1">-- 3만 원이 줄어든 건 맞는데... 언제? 왜?</span>
</code></pre></div></div> <p><strong>이벤트소싱의 답:</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">account_events</span> <span class="k">WHERE</span> <span class="n">account_id</span> <span class="o">=</span> <span class="mi">100</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="nb">timestamp</span><span class="p">;</span>
<span class="c1">-- 2025-08-10 15:30:00: MoneyWithdrawn, -30000, {"reason": "ATM_withdrawal", "location": "강남역"}</span>
<span class="c1">-- 명확한 추적 가능!</span>
</code></pre></div></div> <h3 id="시나리오-2-버그-발생-시-복구"><strong>시나리오 2: 버그 발생 시 복구</strong></h3> <p>시스템 버그로 인해 2025년 8월 8일부터 잘못된 계산이 적용되었다면?</p> <p><strong>전통적인 방식:</strong></p> <ul> <li>현재 상태만 있으므로 <strong>복구 불가능</strong></li> <li>백업에서 복원해야 함 (데이터 손실 발생)</li> </ul> <p><strong>이벤트소싱 방식:</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 8월 7일까지의 이벤트만 재생하여 올바른 상태로 복구</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Event</span><span class="o">&gt;</span> <span class="n">eventsUntilAugust7</span> <span class="o">=</span> <span class="n">getEventsUntil</span><span class="o">(</span><span class="s">"2025-08-07"</span><span class="o">);</span>
<span class="nc">AccountState</span> <span class="n">correctState</span> <span class="o">=</span> <span class="n">replayEvents</span><span class="o">(</span><span class="n">eventsUntilAugust7</span><span class="o">);</span>
</code></pre></div></div> <hr/> <h2 id="3-핵심-개념-정리">3. 핵심 개념 정리</h2> <h3 id="이벤트event"><strong>이벤트(Event)</strong></h3> <blockquote> <p><em>시스템에서 발생한 의미있는 사건</em></p> </blockquote> <ul> <li><strong>과거형으로 표현</strong>: <code class="language-plaintext highlighter-rouge">UserRegistered</code>, <code class="language-plaintext highlighter-rouge">OrderPlaced</code>, <code class="language-plaintext highlighter-rouge">PaymentCompleted</code></li> <li><strong>불변(Immutable)</strong>: 한 번 발생한 이벤트는 수정되지 않음</li> <li><strong>시간순 정렬</strong>: 발생 순서가 매우 중요</li> </ul> <h3 id="이벤트-재생event-replay"><strong>이벤트 재생(Event Replay)</strong></h3> <blockquote> <p><em>저장된 이벤트들을 순서대로 실행하여 현재 상태를 복원하는 과정</em></p> </blockquote> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AccountAggregate</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">accountId</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">BigDecimal</span> <span class="n">balance</span> <span class="o">=</span> <span class="nc">BigDecimal</span><span class="o">.</span><span class="na">ZERO</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="nc">MoneyDepositedEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">balance</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">balance</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAmount</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="nc">MoneyWithdrawnEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">balance</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">balance</span><span class="o">.</span><span class="na">subtract</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAmount</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="이벤트-스토어event-store"><strong>이벤트 스토어(Event Store)</strong></h3> <blockquote> <p><em>이벤트들을 저장하는 특수한 데이터베이스</em></p> </blockquote> <ul> <li>일반 RDBMS, NoSQL, 또는 전용 Event Store 사용</li> <li><strong>Append-only</strong>: 새로운 이벤트만 추가, 기존 이벤트는 수정/삭제 금지</li> </ul> <hr/> <h2 id="4-장점--왜-복잡해-보이는데-쓸까요">4. 장점 — 왜 복잡해 보이는데 쓸까요?</h2> <h3 id="완벽한-감사-추적audit-trail"><strong>완벽한 감사 추적(Audit Trail)</strong></h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 특정 기간의 모든 거래 내역 조회</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Event</span><span class="o">&gt;</span> <span class="n">transactions</span> <span class="o">=</span> <span class="n">eventStore</span><span class="o">.</span><span class="na">getEvents</span><span class="o">(</span>
    <span class="n">accountId</span><span class="o">,</span>
    <span class="nc">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2025</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span>
    <span class="nc">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2025</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">31</span><span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div> <p><strong>활용 사례:</strong></p> <ul> <li>금융 시스템의 규제 준수</li> <li>게임에서 치팅 방지</li> <li>의료 시스템의 환자 기록 추적</li> </ul> <h3 id="타임머신-기능--과거-상태-재현"><strong>타임머신 기능 — 과거 상태 재현</strong></h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 2025년 8월 5일 시점의 계좌 상태 확인</span>
<span class="nc">AccountState</span> <span class="n">pastState</span> <span class="o">=</span> <span class="n">replayEventsUntil</span><span class="o">(</span><span class="n">accountId</span><span class="o">,</span> <span class="s">"2025-08-05"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"8월 5일 잔액: "</span> <span class="o">+</span> <span class="n">pastState</span><span class="o">.</span><span class="na">getBalance</span><span class="o">());</span>
</code></pre></div></div> <p><strong>실무 활용:</strong></p> <ul> <li>A/B 테스트 결과 분석</li> <li>과거 시점 기준 리포트 생성</li> <li>버그 재현 및 디버깅</li> </ul> <h3 id="자연스러운-이벤트-발행"><strong>자연스러운 이벤트 발행</strong></h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@EventHandler</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">MoneyDepositedEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 다른 서비스에 즉시 알림</span>
    <span class="n">emailService</span><span class="o">.</span><span class="na">sendDepositNotification</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAccountId</span><span class="o">(),</span> <span class="n">event</span><span class="o">.</span><span class="na">getAmount</span><span class="o">());</span>
    <span class="n">loyaltyService</span><span class="o">.</span><span class="na">addPoints</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAccountId</span><span class="o">(),</span> <span class="n">calculatePoints</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getAmount</span><span class="o">()));</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>마이크로서비스 환경</strong>에서 서비스 간 데이터 동기화가 자연스럽게 해결됩니다.</p> <hr/> <h2 id="5-단점과-해결책--현실적인-고민들">5. 단점과 해결책 — 현실적인 고민들</h2> <h3 id="데이터-저장소-사용량-증가"><strong>데이터 저장소 사용량 증가</strong></h3> <p><strong>문제:</strong></p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 1년간 거래가 많은 계좌의 이벤트</span>
<span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">account_events</span> <span class="k">WHERE</span> <span class="n">account_id</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="c1">-- 결과: 50,000개 이벤트</span>
</code></pre></div></div> <p><strong>해결책: 스냅샷(Snapshot) 기법</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1000개 이벤트마다 스냅샷 생성</span>
<span class="k">if</span> <span class="o">(</span><span class="n">eventCount</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Snapshot</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Snapshot</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">,</span> <span class="n">currentState</span><span class="o">,</span> <span class="n">eventCount</span><span class="o">);</span>
    <span class="n">snapshotStore</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">snapshot</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 상태 복원 시 최신 스냅샷부터 시작</span>
<span class="nc">Snapshot</span> <span class="n">latestSnapshot</span> <span class="o">=</span> <span class="n">snapshotStore</span><span class="o">.</span><span class="na">getLatest</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">);</span>
<span class="nc">AccountState</span> <span class="n">state</span> <span class="o">=</span> <span class="n">latestSnapshot</span><span class="o">.</span><span class="na">getState</span><span class="o">();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Event</span><span class="o">&gt;</span> <span class="n">eventsAfterSnapshot</span> <span class="o">=</span> <span class="n">eventStore</span><span class="o">.</span><span class="na">getEventsAfter</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">,</span> <span class="n">latestSnapshot</span><span class="o">.</span><span class="na">getVersion</span><span class="o">());</span>
<span class="k">return</span> <span class="nf">replayEvents</span><span class="o">(</span><span class="n">state</span><span class="o">,</span> <span class="n">eventsAfterSnapshot</span><span class="o">);</span>
</code></pre></div></div> <h3 id="이벤트-재생-성능-이슈"><strong>이벤트 재생 성능 이슈</strong></h3> <p><strong>문제:</strong> 이벤트가 많아지면 상태 복원이 느려짐</p> <p><strong>해결책:</strong></p> <ol> <li><strong>CQRS 패턴 적용</strong> — 읽기 전용 뷰 모델 분리</li> <li><strong>캐싱</strong> — 자주 조회되는 상태는 메모리에 캐싱</li> <li><strong>이벤트 압축</strong> — 중요하지 않은 중간 이벤트 제거</li> </ol> <h3 id="개발-복잡도-증가"><strong>개발 복잡도 증가</strong></h3> <p><strong>전통적 CRUD:</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateBalance</span><span class="o">(</span><span class="nc">String</span> <span class="n">accountId</span><span class="o">,</span> <span class="nc">BigDecimal</span> <span class="n">newBalance</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">accountRepository</span><span class="o">.</span><span class="na">updateBalance</span><span class="o">(</span><span class="n">accountId</span><span class="o">,</span> <span class="n">newBalance</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>이벤트소싱:</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">deposit</span><span class="o">(</span><span class="nc">String</span> <span class="n">accountId</span><span class="o">,</span> <span class="nc">BigDecimal</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Account</span> <span class="n">account</span> <span class="o">=</span> <span class="n">loadAccount</span><span class="o">(</span><span class="n">accountId</span><span class="o">);</span>
    <span class="nc">MoneyDepositedEvent</span> <span class="n">event</span> <span class="o">=</span> <span class="n">account</span><span class="o">.</span><span class="na">deposit</span><span class="o">(</span><span class="n">amount</span><span class="o">);</span>
    <span class="n">eventStore</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">accountId</span><span class="o">,</span> <span class="n">event</span><span class="o">);</span>
    <span class="n">account</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>해결책:</strong> 프레임워크 활용 (Axon Framework, EventStore 등)</p> <hr/> <h2 id="6-실전-적용-언제-사용하면-좋을까요">6. 실전 적용: 언제 사용하면 좋을까요?</h2> <h3 id="강력-추천-사례"><strong>강력 추천 사례</strong></h3> <h4 id="금융결제-시스템">금융/결제 시스템</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PaymentAggregate</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">PaymentInitiatedEvent</span> <span class="nf">initiatePayment</span><span class="o">(</span><span class="nc">PaymentCommand</span> <span class="n">cmd</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 결제 시작 이벤트</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">PaymentCompletedEvent</span> <span class="nf">completePayment</span><span class="o">(</span><span class="nc">String</span> <span class="n">paymentId</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 결제 완료 이벤트</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">PaymentFailedEvent</span> <span class="nf">failPayment</span><span class="o">(</span><span class="nc">String</span> <span class="n">paymentId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">reason</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 결제 실패 이벤트</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>이유:</strong> 금융 감독 기관의 <strong>추적 가능성</strong> 요구사항을 자연스럽게 만족</p> <h4 id="전자상거래-주문-시스템">전자상거래 주문 시스템</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 주문 생명주기 추적</span>
<span class="nc">OrderCreatedEvent</span> <span class="o">-&gt;</span> <span class="nc">OrderPaidEvent</span> <span class="o">-&gt;</span> <span class="nc">OrderShippedEvent</span> <span class="o">-&gt;</span> <span class="nc">OrderDeliveredEvent</span>
</code></pre></div></div> <p><strong>이유:</strong> 고객 문의 대응과 <strong>배송 추적</strong>이 필수</p> <h4 id="게임-서비스">게임 서비스</h4> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 플레이어 행동 기록</span>
<span class="nc">PlayerJoinedEvent</span> <span class="o">-&gt;</span> <span class="nc">ItemPurchasedEvent</span> <span class="o">-&gt;</span> <span class="nc">LevelUpEvent</span> <span class="o">-&gt;</span> <span class="nc">GameCompletedEvent</span>
</code></pre></div></div> <p><strong>이유:</strong> <strong>치팅 방지</strong>와 <strong>게임 밸런싱</strong> 분석에 활용</p> <h3 id="신중하게-고려해야-할-사례"><strong>신중하게 고려해야 할 사례</strong></h3> <h4 id="단순한-crud-애플리케이션">단순한 CRUD 애플리케이션</h4> <ul> <li>사용자 프로필 관리</li> <li>상품 카탈로그 관리</li> <li>정적 컨텐츠 관리</li> </ul> <p><strong>이유:</strong> 이력 추적의 <strong>비즈니스 가치</strong>가 낮고 <strong>복잡도</strong>만 증가</p> <h4 id="실시간-성능이-중요한-시스템">실시간 성능이 중요한 시스템</h4> <ul> <li>고빈도 거래 시스템 (HFT)</li> <li>실시간 게임 서버</li> <li>IoT 센서 데이터 처리</li> </ul> <p><strong>이유:</strong> 이벤트 재생으로 인한 <strong>지연시간</strong> 문제</p> <hr/> <h2 id="7-실제-구현-예시--spring-boot--jpa">7. 실제 구현 예시 — Spring Boot + JPA</h2> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventEntity</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">aggregateId</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">eventType</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">eventData</span><span class="o">;</span>  <span class="c1">// JSON 형태로 저장</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">occurredAt</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">version</span><span class="o">;</span>  <span class="c1">// 낙관적 락을 위한 버전</span>
<span class="o">}</span>

<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventStore</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EventRepository</span> <span class="n">eventRepository</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">ObjectMapper</span> <span class="n">objectMapper</span><span class="o">;</span>

    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">append</span><span class="o">(</span><span class="nc">String</span> <span class="n">aggregateId</span><span class="o">,</span> <span class="nc">DomainEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">EventEntity</span> <span class="n">entity</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EventEntity</span><span class="o">();</span>
        <span class="n">entity</span><span class="o">.</span><span class="na">setAggregateId</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">);</span>
        <span class="n">entity</span><span class="o">.</span><span class="na">setEventType</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">());</span>
        <span class="n">entity</span><span class="o">.</span><span class="na">setEventData</span><span class="o">(</span><span class="n">objectMapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">event</span><span class="o">));</span>
        <span class="n">entity</span><span class="o">.</span><span class="na">setOccurredAt</span><span class="o">(</span><span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>

        <span class="n">eventRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">entity</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">DomainEvent</span><span class="o">&gt;</span> <span class="nf">getEvents</span><span class="o">(</span><span class="nc">String</span> <span class="n">aggregateId</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">EventEntity</span><span class="o">&gt;</span> <span class="n">entities</span> <span class="o">=</span> <span class="n">eventRepository</span>
            <span class="o">.</span><span class="na">findByAggregateIdOrderByOccurredAt</span><span class="o">(</span><span class="n">aggregateId</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">entities</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">deserialize</span><span class="o">)</span>
            <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toList</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="8-마무리-이벤트소싱을-시작하기-전에">8. 마무리: 이벤트소싱을 시작하기 전에</h2> <h3 id="스스로에게-물어보세요"><strong>스스로에게 물어보세요</strong></h3> <ol> <li> <p><strong>“우리 시스템에서 데이터 변경 이력이 중요한가?”</strong></p> <ul> <li>중요하다면 → 이벤트소싱 고려</li> <li>중요하지 않다면 → 전통적 방식으로 충분</li> </ul> </li> <li> <p><strong>“감사 추적이나 규제 준수가 필요한가?”</strong></p> <ul> <li>필요하다면 → 이벤트소싱 강력 추천</li> <li>필요없다면 → 다른 아키텍처 패턴 고려</li> </ul> </li> <li> <p><strong>“팀이 복잡도 증가를 감당할 수 있는가?”</strong></p> <ul> <li>가능하다면 → 점진적 도입</li> <li>어렵다면 → 충분한 학습 후 적용</li> </ul> </li> </ol> <h3 id="시작하기-좋은-방법"><strong>시작하기 좋은 방법</strong></h3> <ol> <li><strong>작은 도메인부터</strong>: 전체 시스템이 아닌 <strong>한 개 도메인</strong>에만 적용</li> <li><strong>프레임워크 활용</strong>: Axon Framework, EventStore 등으로 <strong>러닝커브 단축</strong></li> <li><strong>하이브리드 접근</strong>: 핵심 도메인만 이벤트소싱, 나머지는 전통적 방식</li> </ol> <hr/> <h2 id="한-줄-요약">한 줄 요약</h2> <p><strong>이벤트소싱은 “모든 변화를 기록하여 완벽한 추적성을 제공하는” 아키텍처 패턴입니다.</strong></p> <p>단순한 현재 상태 저장이 아닌 <strong>변화의 역사</strong>를 보존함으로써, 더 강력한 <strong>감사 추적</strong>, <strong>디버깅</strong>, <strong>복구 능력</strong>을 제공합니다.</p> <p>복잡해 보이지만, 비즈니스에 진짜 가치를 제공하는 영역에서는 그 복잡함을 상쇄하고도 남을 만큼 강력한 도구입니다.</p> <p><strong><em>이벤트소싱이 모든 문제의 해답은 아닙니다. 하지만 언제 써야 하고 언제 쓰지 말아야 하는지를 아는 것만으로도 더 나은 아키텍처 결정을 내릴 수 있을 것입니다.</em></strong></p>]]></content><author><name></name></author><category term="개발방법론"/><category term="개발방법론"/><summary type="html"><![CDATA[이벤트소싱 완벽 가이드, 현재 상태만 저장하는 방식의 한계를 벗어나 모든 데이터 변화를 기록하는 아키텍처 패턴. 실무 예제와 Spring Boot 구현 코드로 배우는 Event Sourcing 입문서]]></summary></entry><entry><title type="html">Java 문자열 포맷팅 비교 String.format() vs MessageFormat 성능과 사용법 정리</title><link href="https://hwangrolee.github.io/blog/Java-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%8F%AC%EB%A7%B7%ED%8C%85-%EB%B9%84%EA%B5%90/" rel="alternate" type="text/html" title="Java 문자열 포맷팅 비교 String.format() vs MessageFormat 성능과 사용법 정리"/><published>2025-08-07T00:00:00+00:00</published><updated>2025-08-07T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/Java-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%8F%AC%EB%A7%B7%ED%8C%85-%EB%B9%84%EA%B5%90</id><content type="html" xml:base="https://hwangrolee.github.io/blog/Java-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%8F%AC%EB%A7%B7%ED%8C%85-%EB%B9%84%EA%B5%90/"><![CDATA[<h3 id="1-stringformat-vs-messageformat-소개">1. String.format() vs MessageFormat 소개</h3> <p>Java에서 문자열을 동적으로 조합할 때 가장 많이 사용되는 방법 중 하나가 바로 String.format()입니다. 하지만 국제화(i18n)나 다국어 메시지를 처리할 때는 MessageFormat이라는 또 다른 강력한 도구도 있습니다. 이 두 방식은 비슷해 보이지만, 실제로는 목적과 기능 면에서 상당한 차이를 가지고 있습니다.</p> <h3 id="2-stringformat--간결하고-빠른-문자열포매팅">2. String.format() – 간결하고 빠른 문자열 포매팅</h3> <p>String.format()은 C언어의 printf() 스타일 포맷을 기반으로 하며, 가독성이 좋고 직관적인 방식으로 문자열을 구성할 수 있습니다. 간단한 변수 삽입, 숫자 포맷, 정렬 등이 필요한 경우에 매우 유용합니다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"홍길동"</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">30</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"이름: %s, 나이: %d"</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
<span class="c1">// 출력: 이름: 홍길동, 나이: 30</span>
</code></pre></div></div> <ul> <li>%s, %d, %f 같은 포맷 문자를 사용</li> <li>위치 기반이 아닌 순차적 변수 삽입</li> <li>단순한 텍스트 처리에 적합</li> <li>성능이 좋고 코드가 짧음</li> </ul> <h3 id="3-messageformat--다국어-처리에-강한-국제화-포맷도구">3. MessageFormat – 다국어 처리에 강한 국제화 포맷 도구</h3> <p>반면 MessageFormat은 Java의 국제화(i18n) 지원을 위해 설계된 포맷팅 도구입니다 ResourceBundle과 함께 자주 사용되며, 로케일(Locale)에 따라 날짜, 숫자, 통화 등의 포맷을 자동으로 조정할 수 있습니다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.text.MessageFormat</span><span class="o">;</span>

<span class="nc">String</span> <span class="n">pattern</span> <span class="o">=</span> <span class="s">"이름: {0}, 나이: {1}"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">MessageFormat</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">pattern</span><span class="o">,</span> <span class="s">"홍길동"</span><span class="o">,</span> <span class="mi">30</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
<span class="c1">// 출력: 이름: 홍길동, 나이: 30</span>
</code></pre></div></div> <ul> <li>{0}, {1} 형태의 인덱스 기반 변수 삽입</li> <li>내부적으로 로케일 지원, 날짜/숫자 자동 포맷 가능</li> <li>다국어 메시지 파일과의 궁합이 뛰어남</li> <li>복잡한 메시지 구성이 필요한 경우에 적합</li> </ul> <h3 id="4-언제-어떤-걸-써야할까">4. 언제 어떤 걸 써야 할까?</h3> <ul> <li>빠르고 간단한 문자열 치환만 필요할 때는 String.format()이 훨씬 효율적입니다.</li> <li>로케일에 따라 메시지 포맷이 달라지거나, 메시지를 ResourceBundle로 관리하는 경우에는 MessageFormat이 필수입니다.</li> </ul> <h3 id="5-성능-비교-stringformat-vs-messageformat">5. 성능 비교: String.format() vs MessageFormat</h3> <p>문자열 포맷팅 방식은 실제 애플리케이션에서 반복적으로 호출되는 경우가 많기 때문에, 성능 차이는 무시할 수 없습니다. 이번 섹션에서는 String.format()과 MessageFormat의 실제 성능 차이와 메모리 사용량을 간단히 비교해 보겠습니다.</p> <h4 id="6간단한-벤치마크결과">6.간단한 벤치마크 결과</h4> <table> <thead> <tr> <th>항목</th> <th>String.format()</th> <th>MessageFormat.format()</th> </tr> </thead> <tbody> <tr> <td>평균 실행 시간</td> <td>약 4~6 마이크로초(μs)</td> <td>약 10~15 마이크로초(μs)</td> </tr> <tr> <td>메모리 사용량</td> <td>낮음</td> <td>상대적으로 높음</td> </tr> <tr> <td>GC 발생</td> <td>거의 없음</td> <td>간헐적으로 발생 가능</td> </tr> <tr> <td>특징</td> <td>포맷 분석이 단순하고 빠름</td> <td>포맷 문자열을 파싱하는 과정이 복잡하여 오버헤드 발생</td> </tr> <tr> <td> </td> <td> </td> <td> </td> </tr> </tbody> </table> <ul> <li>단순한 문자열 처리라면 String.format()이 속도와 메모리 면에서 유리합니다.</li> <li>다국어 처리, 로케일 기반 포맷팅이 필요한 경우는 MessageFormat이 적합합니다.</li> <li>두 방식은 성능 차이가 2배 이상 발생할 수 있으므로, 용도에 맞는 선택이 중요합니다.</li> </ul>]]></content><author><name></name></author><category term="자바"/><category term="자바"/><summary type="html"><![CDATA[Java String.format()과 MessageFormat 성능 비교와 사용법 완벽 가이드. 언제 어떤 방식을 선택해야 하는지 벤치마크 결과와 실제 예제로 알아보세요. 국제화 처리부터 최적화까지.]]></summary></entry><entry><title type="html">Java 8 이후 바뀐 자바 문법 총정리 — Java 17까지 꼭 알아야 할 핵심 변화</title><link href="https://hwangrolee.github.io/blog/Java17%EA%B9%8C%EC%A7%80-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%ED%95%B5%EC%8B%AC-%EB%B3%80%ED%99%94/" rel="alternate" type="text/html" title="Java 8 이후 바뀐 자바 문법 총정리 — Java 17까지 꼭 알아야 할 핵심 변화"/><published>2025-08-06T00:00:00+00:00</published><updated>2025-08-06T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/Java17%EA%B9%8C%EC%A7%80-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%ED%95%B5%EC%8B%AC-%EB%B3%80%ED%99%94</id><content type="html" xml:base="https://hwangrolee.github.io/blog/Java17%EA%B9%8C%EC%A7%80-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%ED%95%B5%EC%8B%AC-%EB%B3%80%ED%99%94/"><![CDATA[<p>Java 8은 오랜 기간 동안 자바 개발의 중심이었습니다.</p> <p>람다, 스트림, Optional 등 지금도 널리 쓰이는 기능들이 도입되면서 자바 개발자들에게 새로운 방식의 프로그래밍을 소개했던 버전입니다.</p> <p>하지만 그로부터 벌써 10년이 흘렀고, 자바는 지금도 꾸준히 진화하고 있습니다. 많은 개발자들이 Java 8에 머물러 있는 동안, 자바는 코드 작성 방식, API 설계 방식, 클래스 설계 방식에서 많은 변화를 겪었습니다.</p> <h3 id="java-17이-중요한이유">Java 17이 중요한 이유</h3> <p>가장 큰 이유는 Spring Boot 3.x부터 Java 17 이상을 필수로 요구하기 때문입니다.</p> <p>이제 새로운 프로젝트나 주요 프레임워크를 최신으로 사용하려면 Java 17은 선택이 아니라 기본 전제가 되었습니다.</p> <p>또한 Java 17은 장기 지원(LTS) 버전입니다.</p> <p>Java 11 이후 6년 만에 등장한 LTS 버전으로, 기업 환경에서도 안정적으로 채택되고 있으며 다양한 프레임워크들이 Java 17을 기준으로 개발되고 있습니다.</p> <h3 id="바뀐-건-단순히-버전-숫자만이아닙니다">바뀐 건 단순히 버전 숫자만이 아닙니다</h3> <p><strong><em>Java 9부터 17까지는 단순한 기능 추가나 마이너 개선이 아니라, 자바라는 언어의 방향성과 스타일 자체에 변화가 있었습니다.</em></strong> 기존의 장황한 코딩 방식은 더 이상 필수가 아니며, 이제는 간결하고 읽기 쉬운 코드, 명확한 타입 추론, 안전한 클래스 설계 방식이 주류가 되었습니다.</p> <p>또한 자바는 최근 몇 년간의 변화 속도도 매우 빨라졌습니다. 예전에는 몇 년마다 새 버전이 나왔지만, 이제는 매년 새로운 기능과 개선 사항이 정기적으로 포함되며, 이러한 변화는 자바를 과거의 언어가 아닌 현대적인 언어로 다시 만들어가고 있습니다.</p> <p><strong><em>Java 17을 기준으로 개발 환경이 재편되고 있습니다.</em></strong> 현재 대부분의 주요 프레임워크와 라이브러리는 Java 17을 기준으로 작동하거나, 그 이상을 요구하고 있습니다. 예를 들어 Spring Boot 3, Hibernate 6 등의 프레임워크는 Java 17 이상에서 개발 및 테스트되고 있으며, 이전 버전의 자바에서는 호환되지 않거나 일부 기능을 쓸 수 없는 경우도 많습니다.</p> <p>또한 클라우드 네이티브 개발 환경, 빌드 시스템, 테스트 프레임워크 등도 Java 17에 맞춰 업데이트되고 있습니다. 자바 개발자로서의 경쟁력을 유지하고 싶다면 Java 17은 더 이상 선택이 아닌 필수입니다.</p> <h3 id="java-8-개발자라면-지금이적기입니다">Java 8 개발자라면 지금이 적기입니다.</h3> <p>Java 17로의 전환은 생각보다 어렵지 않습니다. 특히 Java 8까지 익숙한 개발자라면, 지금부터 주요 문법과 특징 몇 가지만 익히면 금방 적응할 수 있습니다.</p> <ul> <li>새로운 프로젝트를 Java 17 기반으로 시작하려는 분들,</li> <li>Spring Boot 3로 마이그레이션을 고민 중인 분들,</li> <li>Lombok 없이 깔끔한 코드를 작성하고 싶은 분들이라면,</li> </ul> <p>이제는 Java 17을 학습할 시점입니다.</p> <h3 id="var-키워드--지역-변수-타입-추론-java-10도입">var 키워드 – 지역 변수 타입 추론 (Java 10 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <pre><code class="language-javaa">var scores = new HashMap&lt;String, List&lt;Integer&gt;&gt;();
</code></pre> <p><strong>어떤 점이 좋아졌나?</strong></p> <p>코드가 훨씬 간결해집니다. 특히 제네릭 타입이 길어질수록 우측 타입만으로 충분히 추론 가능할 때, 가독성이 올라갑니다.</p> <p>타입은 컴파일 타임에 고정되므로 동적 타입처럼 오해할 필요가 없습니다.</p> <p><strong>주의할 점</strong></p> <p>타입을 명확히 드러내는 것이 중요한 경우, var 대신 명시적 타입 사용이 오히려 낫습니다.</p> <h3 id="record--불변-데이터-클래스를-한-줄로-java-16도입">record – 불변 데이터 클래스를 한 줄로 (Java 16 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

    <span class="o">}</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>불변 객체 패턴을 아주 간결하게 작성할 수 있습니다.</li> <li>생성자, getter, equals, hashCode, toString을 자동 생성합니다.</li> <li>Lombok 없이도 DTO를 쉽게 만들 수 있습니다.</li> <li>데이터 중심 클래스를 명확히 표현할 수 있습니다.</li> </ul> <h3 id="text-block--멀티라인-문자열-java-15도입">Text Block – 멀티라인 문자열 (Java 15 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">json</span> <span class="o">=</span> <span class="s">"{\n"</span> <span class="o">+</span>
    <span class="s">" \"name\": \"John\",\n"</span> <span class="o">+</span>
    <span class="s">" \"age\": 30\n"</span> <span class="o">+</span>
    <span class="s">"}"</span><span class="o">;</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">json</span> <span class="o">=</span> <span class="sh">"""
    {
    "name": "John",
    "age": 30
    }
    """</span><span class="o">;</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>멀티라인 문자열을 이스케이프 없이 그대로 표현할 수 있습니다.</li> <li>SQL, JSON, XML, HTML 같은 문자열을 쓸 때 가독성이 대폭 향상됩니다.</li> <li>들여쓰기나 줄바꿈 처리도 유연하게 지원됩니다.</li> </ul> <h3 id="switch-표현식--조건문을-더-간결하고-안전하게-java-14도입">switch 표현식 – 조건문을 더 간결하고 안전하게 (Java 14 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">result</span><span class="o">;</span>
<span class="k">switch</span> <span class="o">(</span><span class="n">day</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nl">MONDAY:</span>
    <span class="k">case</span> <span class="nl">TUESDAY:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">"Weekday"</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="k">case</span> <span class="nl">SATURDAY:</span>
    <span class="k">case</span> <span class="nl">SUNDAY:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">"Weekend"</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">"Unknown"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="k">switch</span> <span class="o">(</span><span class="n">day</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="no">MONDAY</span><span class="o">,</span> <span class="no">TUESDAY</span> <span class="o">-&gt;</span> <span class="s">"Weekday"</span><span class="o">;</span>
    <span class="k">case</span> <span class="no">SATURDAY</span><span class="o">,</span> <span class="no">SUNDAY</span> <span class="o">-&gt;</span> <span class="s">"Weekend"</span><span class="o">;</span>
    <span class="k">default</span> <span class="o">-&gt;</span> <span class="s">"Unknown"</span><span class="o">;</span>
<span class="o">};</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>값을 반환할 수 있는 switch 표현식이 도입되어, 변수를 미리 선언할 필요가 없습니다. <ul> <li>문법으로 break 누락으로 인한 실수 방지.</li> </ul> </li> <li>yield를 활용하면 복잡한 로직도 표현 가능.</li> <li>함수형 스타일에 더 가까워졌습니다.</li> </ul> <h3 id="pattern-matching-for-instanceof--타입-검사와-캐스팅을-동시에-java-16도입">Pattern Matching for instanceof – 타입 검사와 캐스팅을 동시에 (Java 16 도입)</h3> <p><strong>Java 8 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">User</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="o">(</span><span class="nc">User</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>중복 코드 제거: 타입 체크 후 명시적 캐스팅을 반복할 필요가 없습니다.</li> <li>가독성 향상: 조건문에서 타입 이름을 한 번만 쓰면 됩니다.</li> <li>향후 도입될 switch 패턴 매칭과도 연계됩니다.</li> </ul> <h2 id="sealed-class--상속을-명시적으로-제한-java-17-정식도입">sealed class – 상속을 명시적으로 제한 (Java 17 정식 도입)</h2> <p><strong>Java 8 방식</strong></p> <ul> <li>상속 제한을 하려면 final로 막거나, 문서로 설명해야 했습니다.</li> </ul> <p><strong>Java 17 방식</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">sealed</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="n">permits</span> <span class="nc">Dog</span><span class="o">,</span> <span class="nc">Cat</span> <span class="o">{}</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{}</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{}</span>
</code></pre></div></div> <p><strong>어떤 점이 좋아졌나?</strong></p> <ul> <li>허용된 하위 클래스만 상속할 수 있도록 제한합니다.</li> <li>클래스 계층 구조가 예측 가능하고 안전해집니다.</li> <li>도메인 모델링 시, 허용된 상태나 유형만 정의 가능.</li> <li>자바 컴파일러가 하위 클래스를 정확히 알기 때문에 패턴 매칭에도 최적화됩니다.</li> </ul> <h3 id="기타-유용한변화들">기타 유용한 변화들</h3> <ul> <li>String에 새로운 메서드들 추가</li> <li>isBlank(): 공백 문자열 여부 확인</li> <li>repeat(int): 문자열 반복</li> <li>lines(): 줄 단위로 스트림 처리</li> <li>HttpClient: java.net.http.HttpClient가 정식 API로 도입됨 (Java 11)</li> <li>jshell: 자바 REPL 지원 (Java 9) – 빠른 테스트 가능</li> </ul> <h3 id="마무리-요약">마무리 요약</h3> <p>Java 17로 넘어오면서 자바는 더 이상 “장황한 코드”를 쓰는 언어가 아닙니다. 코드는 짧아졌고, 타입은 안전해졌으며, 불변성을 쉽게 유지할 수 있고, 조건문도 더 선언적으로 바뀌었습니다.</p> <p>기존 Java 8 방식에 익숙한 개발자라면, 다음과 같은 점에서 만족하실 수 있습니다:</p> <ul> <li>DTO 작성이 1줄로 끝난다 (record)</li> <li>조건문이 훨씬 직관적이다 (switch, pattern matching)</li> <li>JSON이나 SQL 문자열을 쓸 때 코드가 지저분하지 않다 (text block)</li> <li>상속과 타입 검사도 명확해졌다 (sealed, instanceof 개선)</li> </ul> <p>지금 Java 17을 익혀두신다면 앞으로 자바 개발에서 훨씬 높은 생산성과 안정성을 얻을 수 있습니다.</p>]]></content><author><name></name></author><category term="자바"/><category term="자바"/><summary type="html"><![CDATA[Java 8에서 Java 17로 업그레이드해야 하는 이유와 핵심 신기능들을 실무 예제와 함께 알아보세요]]></summary></entry><entry><title type="html">왜 개발자들은 OAuth와 OpenID Connect를 헷갈릴까?</title><link href="https://hwangrolee.github.io/blog/%EC%99%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%80-OAuth%EC%99%80-OpenID-Connect%EB%A5%BC-%ED%97%B7%EA%B0%88%EB%A6%B4%EA%B9%8C/" rel="alternate" type="text/html" title="왜 개발자들은 OAuth와 OpenID Connect를 헷갈릴까?"/><published>2025-08-05T00:00:00+00:00</published><updated>2025-08-05T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/%EC%99%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%80-OAuth%EC%99%80-OpenID-Connect%EB%A5%BC-%ED%97%B7%EA%B0%88%EB%A6%B4%EA%B9%8C</id><content type="html" xml:base="https://hwangrolee.github.io/blog/%EC%99%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%80-OAuth%EC%99%80-OpenID-Connect%EB%A5%BC-%ED%97%B7%EA%B0%88%EB%A6%B4%EA%B9%8C/"><![CDATA[<blockquote> <p>“구글 로그인은 OAuth 2.0으로 만들었어요.”</p> <p>“카카오 로그인은 OAuth API 써서 붙였어요.”</p> </blockquote> <p>많은 개발자들이 ‘소셜 로그인 = OAuth 2.0’ 이라고 이야기합니다. 하지만 사실 소셜 로그인은 OAuth가 아니라 OpenID Connect(OIDC) 덕분에 가능한 기능입니다.</p> <p>이 글에서는 개발자들이 OAuth와 OIDC를 혼용하는 이유와 왜 구글/카카오 로그인은 OIDC라고 말해야 하는지를 정리해봅니다.</p> <h2 id="oauth-20과-openid-connectoidc는-뭐가-다를까">OAuth 2.0과 OpenID Connect(OIDC)는 뭐가 다를까?</h2> <h3 id="oauth-20">OAuth 2.0</h3> <ul> <li>목적: 권한 위임(Authorization)</li> <li>예: “내 구글 드라이브 파일에 접근할 수 있는 권한을 앱에 줄게”</li> </ul> <h2 id="openid-connect-oidc">OpenID Connect (OIDC)</h2> <ul> <li>목적: 인증(Authentication)</li> <li>OAuth 2.0 기반 프로토콜 + ID Token 개념 추가</li> <li>예: “이 사용자가 ‘홍길동’인지 확인하고 로그인 처리해줘”</li> <li>정리하면 OAuth는 ‘무엇을 할 수 있는지’, OIDC는 ‘누구인지’ 를 해결하는 프로토콜입니다.</li> </ul> <h2 id="개발자들이-혼용하는-대표-케이스">개발자들이 혼용하는 대표 케이스</h2> <blockquote> <p>“구글 로그인은 OAuth 2.0을 사용했다.”</p> </blockquote> <p>왜 혼동될까? 구글 개발자 문서에 ‘Google OAuth 2.0’이라고 적혀 있어서. 실제 구현도 OAuth Authorization Code Flow를 사용하기 때문.</p> <h3 id="정확한-설명">정확한 설명</h3> <ul> <li>구글 API 호출 -&gt; OAuth</li> <li>구글 로그인 -&gt; OpenID Connect</li> <li>구글 로그인을 구현했다면 “OIDC를 사용했다”고 말하는 게 정확합니다.</li> <li>“OAuth로 로그인 기능을 만들었다.”</li> </ul> <h3 id="oauth-flow를-사용하니까-로그인도-oauth로-가능하다고-착각">OAuth Flow를 사용하니까 로그인도 OAuth로 가능하다고 착각.</h3> <ul> <li>OAuth는 권한 위임만 담당합니다.</li> <li>로그인 기능을 가능하게 해주는 건 OIDC에서 발급하는 ID Token 덕분입니다.</li> <li>OAuth만 쓰면 사용자 ‘신원’은 확인할 수 없습니다.</li> <li>“ID Token도 Access Token 중 하나다.”</li> </ul> <h3 id="왜-혼동될까-둘-다-토큰이니까-같은-개념이라고-생각">왜 혼동될까? 둘 다 ‘토큰’이니까 같은 개념이라고 생각.</h3> <ul> <li>JWT 구조도 비슷해서 더 헷갈립니다.</li> <li>Access Token -&gt; API 자원 접근 용도</li> <li>ID Token -&gt; 로그인 인증 용도 (이메일, 이름, 사용자 ID 포함)</li> </ul> <h3 id="그렇다면-구글카카오-로그인은-oauth일까-oidc일까">그렇다면, 구글/카카오 로그인은 OAuth일까 OIDC일까?</h3> <ul> <li>정확히 말하면 -&gt; OIDC를 활용한 것입니다.</li> <li>OAuth 2.0 -&gt; 권한 위임 (예: 내 구글 드라이브 파일 접근 허용)</li> <li>OpenID Connect(OIDC) -&gt; OAuth 2.0 기반 + “사용자 인증(로그인)” 기능 추가</li> </ul> <p>구글 로그인 / 카카오 로그인은 “로그인(= 인증)”이 목적이라 OIDC를 사용했다고 해야 정확합니다.</p> <h3 id="면접이나-블로그에서-이렇게-설명할-수-있습니다">면접이나 블로그에서 이렇게 설명할 수 있습니다</h3> <p>구글, 카카오 로그인 기능을 내 서비스에 붙일 때 OAuth 2.0 Flow(Authorization Code)를 사용하긴 했지만, 실제로 로그인 기능을 가능하게 한 건 OpenID Connect(OIDC)입니다.</p> <p>OAuth만 쓰면 단순 권한 위임만 가능하지만, OIDC는 ID Token을 통해 사용자 정보를 확인할 수 있기 때문에 로그인 구현이 가능합니다.</p> <h2 id="결론-이렇게-기억하면-안-헷갈림">결론: 이렇게 기억하면 안 헷갈림</h2> <ul> <li>OAuth 2.0 -&gt; 권한 위임 (내 API를 대신 호출하게 권한 줌)</li> <li>OIDC -&gt; OAuth 2.0 + 로그인 기능 (이 사용자가 누구인지 알려줌)</li> </ul> <h2 id="마무리">마무리</h2> <p>다음에 누군가 “구글 로그인은 OAuth로 만들었어?” 라고 물으면</p> <blockquote> <p>“정확히는 OAuth 위에 인증 기능을 추가한 OpenID Connect로 구현했어”</p> </blockquote> <p>라고 말해보세요. OAuth는 ‘무엇을 할 수 있나’, OIDC는 ‘누구인가’. 이 한 줄만 기억하면 더 이상 헷갈리지 않을 겁니다.</p>]]></content><author><name></name></author><category term="인증/인가"/><category term="OAuth,"/><category term="OIDC,"/><category term="OpenID"/><category term="Connect,"/><category term="소셜로그인,"/><category term="Authentication,"/><category term="Authorization"/><summary type="html"><![CDATA[개발자들이 흔히 혼동하는 OAuth 2.0과 OpenID Connect(OIDC)의 차이점을 명확히 설명합니다. 소셜 로그인이 OAuth가 아닌 OIDC인 이유, 인증(Authentication)과 권한 위임(Authorization)의 핵심 개념을 알아보고 정확한 기술 용어를 사용하세요.]]></summary></entry><entry><title type="html">DB 락(Database Lock) 완벽 이해하기 - 개발자라면 꼭 알아야 할 개념</title><link href="https://hwangrolee.github.io/blog/DB-%EB%9D%BD(Database-Lock)-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%EA%B0%9C%EB%85%90/" rel="alternate" type="text/html" title="DB 락(Database Lock) 완벽 이해하기 - 개발자라면 꼭 알아야 할 개념"/><published>2025-08-02T00:00:00+00:00</published><updated>2025-08-02T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/DB-%EB%9D%BD(Database-Lock)-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%EA%B0%9C%EB%85%90</id><content type="html" xml:base="https://hwangrolee.github.io/blog/DB-%EB%9D%BD(Database-Lock)-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%EA%B0%9C%EB%85%90/"><![CDATA[<blockquote> <p>“은행 계좌에서 돈을 빼는데, 둘이 동시에 빼면 어떻게 될까?”</p> </blockquote> <p>개발을 하다 보면 동시에 같은 데이터를 읽고, 수정하고, 삭제하는 상황을 피할 수 없습니다.  예를 들어, A와 B가 같은 은행 계좌에서 돈을 동시에 인출하려 한다고 해봅시다.</p> <ul> <li>A가 5만 원을 빼려는 순간 잔액: 10만 원</li> <li>B도 같은 순간 5만 원을 빼려는 요청을 보냄</li> <li>A와 B 모두 잔액 10만 원을 보고 인출 → 최종 잔액이 0원이 아닌 5만 원이 되어버림!</li> </ul> <p>데이터 무결성(Data Integrity) 이 깨집니다.</p> <p>이 문제를 해결하는 핵심 개념이 바로 DB 락(Database Lock) 입니다.</p> <h2 id="db-락이란">DB 락이란?</h2> <blockquote> <p>“여러 명이 동시에 같은 데이터를 건드릴 때, 꼬이지 않도록 잠시 잠가두는 안전장치”</p> </blockquote> <p>데이터베이스는 다중 사용자가 접근하는 시스템이기 때문에, 한 사용자가 데이터를 읽거나 수정하는 동안 다른 사용자의 작업을 잠시 막는 방법이 필요합니다.</p> <p><strong>그게 바로 락(Lock) 이죠.</strong></p> <p>왜 락이 필요할까? (은행 계좌 예시)</p> <ul> <li>A: “내 계좌에서 5만 원 인출할게”</li> <li>B: “나도 5만 원 인출할래”</li> </ul> <p>DB가 락을 걸지 않으면, A와 B가 동시에 잔액을 조회(10만 원) → 각자 5만 원 빼서 저장 → 최종 잔액이 5만 원이 남아버리는 문제가 생깁니다.</p> <p>하지만 DB가 ‘잠깐! A 먼저 끝낼 때까지 기다려!’ 하고 락을 건다면? ➡ A의 작업이 끝나고 나서야 B가 처리되므로 정확한 결과(잔액 0원) 가 유지됩니다.</p> <hr/> <h2 id="db-락의-두-가지철학">DB 락의 두 가지 철학</h2> <p>DB 락에는 두 가지 방식이 있습니다.</p> <p><strong>1. 낙관적 락 (Optimistic Lock)</strong></p> <p>“동시에 접근해도 괜찮겠지? 근데 마지막에 확인은 해볼게.”</p> <ul> <li>데이터를 읽을 때 락을 걸지 않음</li> <li>대신 버전(version) 필드를 두고, 커밋(저장)할 때 변경 여부 확인</li> <li>누군가 먼저 수정했다면 에러(충돌) 발생 → 다시 시도해야 함</li> </ul> <p><strong>예시</strong></p> <ul> <li>게시글 좋아요 수 같은 기능 → 여러 명이 동시에 눌러도 조금 늦게 업데이트되면 괜찮음</li> </ul> <p><strong>비유</strong></p> <ul> <li>“책을 빌릴 때 자물쇠 안 걸고 그냥 빌려줌. 나중에 반납할 때 ‘책이 다른 사람에 의해 수정됐나?’ 확인 후 충돌 시 다시 처리”</li> </ul> <p><strong>장점</strong>: 락을 거의 안 걸기 때문에 성능이 좋음</p> <p><strong>단점</strong>: 저장할 때 충돌 나면 재시도 로직 필요</p> <p><strong>2. 비관적 락 (Pessimistic Lock)</strong></p> <p>“혹시 모르니 내가 끝날 때까지 아무도 건들지 마!”</p> <ul> <li>데이터를 읽는 순간부터 DB가 잠금 걸기</li> <li>다른 트랜잭션은 읽기/쓰기 모두 대기 상태 (잠금 해제될 때까지 기다림)</li> <li>SQL에서는 <code class="language-plaintext highlighter-rouge">SELECT FOR UPDATE</code> 로 구현</li> </ul> <p><strong>예시</strong></p> <ul> <li>은행 계좌, 항공권 좌석, 콘서트 티켓 → 절대 꼬이면 안 되는 데이터</li> </ul> <p><strong>비유</strong></p> <ul> <li>“내가 책 빌리면 사서가 ‘이 책은 지금 대출 중이니 건들지 마세요’라고 딱지 붙임”</li> </ul> <p>장점: 충돌이 거의 없음 (안전성 최고)</p> <p>단점: 락이 오래 걸리면 다른 사용자가 기다려야 함 → 성능 저하 가능</p> <hr/> <h2 id="db-락의-동작방식">DB 락의 동작 방식</h2> <p>DB 락은 트랜잭션(Transaction) 단위로 동작합니다.</p> <ol> <li>트랜잭션 시작</li> <li>데이터를 읽으면서 락을 걸기 (비관적 락의 경우)</li> <li>수정 후 커밋</li> <li>커밋이 완료되면 락 해제</li> </ol> <p>그래서 락을 쓸 때는 트랜잭션을 짧게 유지하는 게 중요합니다.</p> <hr/> <h2 id="언제-어떤-락을-써야할까">언제 어떤 락을 써야 할까?</h2> <p><strong>낙관적 락 (Optimistic Lock)</strong></p> <ul> <li>동시성이 많지만 충돌 가능성은 적을 때</li> <li>예: 게시글 좋아요 수, 상품 조회수, 포인트 적립</li> </ul> <p><strong>비관적 락 (Pessimistic Lock)</strong></p> <ul> <li>꼬이면 절대 안 되는 핵심 로직</li> <li>예: 은행 계좌 잔액 변경, 티켓 좌석 예매, 창고 재고 처리</li> </ul> <hr/> <h2 id="spring에서-db-락-쓰는법">Spring에서 DB 락 쓰는 법</h2> <p>Spring Data JPA에서는 @Lock 어노테이션으로 쉽게 DB 락을 사용할 수 있습니다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AccountRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Account</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nd">@Lock</span><span class="o">(</span><span class="nc">LockModeType</span><span class="o">.</span><span class="na">PESSIMISTIC_WRITE</span><span class="o">)</span> <span class="c1">// 비관적 락</span>
    <span class="nd">@Query</span><span class="o">(</span><span class="s">"SELECT a FROM Account a WHERE a.id = :id"</span><span class="o">)</span>
    <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Account</span><span class="o">&gt;</span> <span class="nf">findByIdForUpdate</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div> <hr/> <h2 id="마무리">마무리</h2> <p>DB 락은 동시성 문제를 해결하는 가장 기본적인 도구입니다.</p> <ul> <li>낙관적 락(Optimistic) -&gt; “충돌 안 나겠지? 근데 저장할 때 체크는 할게”</li> <li>비관적 락(Pessimistic) -&gt; “내가 끝날 때까지 아무도 건들지 마!”</li> </ul> <p>그리고 락을 쓸 땐 트랜잭션 길이를 최대한 짧게 유지하는 게 핵심!</p> <p>락을 오래 잡아두면 다른 작업이 모두 기다리기 때문에 시스템 전체 성능이 떨어질 수 있습니다.</p>]]></content><author><name></name></author><category term="Database"/><category term="MySQL,"/><category term="SQL,"/><category term="Lock,"/><category term="동시성,"/><category term="트랜잭션"/><summary type="html"><![CDATA[개발자 필수 개념 DB 락(Database Lock) 완벽 가이드. 동시성 문제 해결을 위한 낙관적 락과 비관적 락의 차이, 사용 사례, Spring Data JPA 적용법까지 쉽게 설명합니다. 데이터 무결성을 지키는 핵심 원리를 지금 확인하세요.]]></summary></entry><entry><title type="html">비관적 락(Pessimistic Lock), 진짜 뭔지 아세요? - 개발자가 궁금해할 질문 7가지로 정리</title><link href="https://hwangrolee.github.io/blog/%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BD(Pessimistic-Lock)-%EC%A7%84%EC%A7%9C-%EB%AD%94%EC%A7%80-%EC%95%84%EC%84%B8%EC%9A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EA%B6%81%EA%B8%88%ED%95%B4%ED%95%A0-%EC%A7%88%EB%AC%B8-7%EA%B0%80%EC%A7%80%EB%A1%9C-%EC%A0%95%EB%A6%AC/" rel="alternate" type="text/html" title="비관적 락(Pessimistic Lock), 진짜 뭔지 아세요? - 개발자가 궁금해할 질문 7가지로 정리"/><published>2025-08-02T00:00:00+00:00</published><updated>2025-08-02T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BD(Pessimistic-Lock)-%EC%A7%84%EC%A7%9C-%EB%AD%94%EC%A7%80-%EC%95%84%EC%84%B8%EC%9A%94?%E2%80%8A-%E2%80%8A%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EA%B6%81%EA%B8%88%ED%95%B4%ED%95%A0-%EC%A7%88%EB%AC%B8-7%EA%B0%80%EC%A7%80%EB%A1%9C-%EC%A0%95%EB%A6%AC</id><content type="html" xml:base="https://hwangrolee.github.io/blog/%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BD(Pessimistic-Lock)-%EC%A7%84%EC%A7%9C-%EB%AD%94%EC%A7%80-%EC%95%84%EC%84%B8%EC%9A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EA%B6%81%EA%B8%88%ED%95%B4%ED%95%A0-%EC%A7%88%EB%AC%B8-7%EA%B0%80%EC%A7%80%EB%A1%9C-%EC%A0%95%EB%A6%AC/"><![CDATA[<h3 id="비관적-락에-대한-7가지궁금증">비관적 락에 대한 7가지 궁금증</h3> <p><strong>Q1. 비관적 락은 왜 ‘비관적’이라고 부르나요?</strong></p> <ul> <li>“언젠가 누군가 같은 데이터를 건드릴 거라고 ‘비관적으로’ 생각하기 때문”</li> <li>읽거나 수정하기 전에 바로 락을 걸어버림</li> <li>즉, 동시에 접근하면 안 된다고 미리 가정하는 방식</li> </ul> <p><strong>Q2. 비관적 락을 걸면 DB는 어떻게 동작하나요?</strong></p> <ul> <li>Spring Data JPA → @Lock(LockModeType.PESSIMISTIC_WRITE)</li> <li>DB → SELECT … FOR UPDATE 쿼리 실행</li> <li>DB는 조회된 row(행)에 락을 걸어, 트랜잭션이 끝날 때까지 대기 상태로 만듦</li> <li>MySQL(InnoDB) / Oracle / PostgreSQL 등 대부분 DB에서 동일 개념 적용</li> </ul> <p><strong>Q3. 비관적 락은 “row-level lock”인가요, “table-level lock”인가요?</strong></p> <ul> <li>기본은 row-level lock (행 단위 잠금)</li> <li>WHERE id = ? 처럼 명확히 특정 행을 조회하면 해당 행만 잠김</li> <li>하지만 조건이 모호하거나 인덱스가 없으면 DB는 더 넓은 범위를 잠글 수 있음</li> <li>MySQL → Gap Lock / Next-Key Lock 발생 (범위 락)</li> <li>Oracle → Row-level 락이지만 쿼리에 따라 table-level 락으로 확대 가능성 있음</li> <li>실무에서는 PK(기본키) 조회로 비관적 락을 거는 게 안전하다!</li> </ul> <p><strong>Q4. 비관적 락을 걸면 언제까지 락이 유지되나요?</strong></p> <ul> <li>트랜잭션이 끝날 때까지 유지</li> <li>커밋(COMMIT) 또는 롤백(ROLLBACK) 시 해제됨</li> <li>트랜잭션을 길게 잡으면 락도 오래 유지 → 다른 요청들 대기 → 성능 병목</li> </ul> <p><strong>Q5. 비관적 락을 쓰면 성능은 얼마나 떨어지나요?</strong></p> <ul> <li>DB가 동시에 처리할 수 있는 요청을 줄여버림 → 동시성(Concurrency)↓</li> <li>트랜잭션이 길거나락 걸리는 데이터가 많을수록</li> <li>다른 요청이 줄줄이 대기 (Deadlock 가능성도↑)</li> <li>“락을 꼭 필요한 최소 구간에서만” 사용해야 함</li> </ul> <p><strong>Q6. 그럼 멀티 서버 환경에서는 어떻게 되나요?</strong></p> <ul> <li>비관적 락은 DB 차원에서 락을 거는 것이라 서버가 여러 대여도 안전</li> <li>서버 A에서 SELECT FOR UPDATE로 row 잠그면, 서버 B도 DB에서 대기</li> <li>JVM 단위 synchronized 같은 건 멀티 서버에선 소용없지만, DB 락은 글로벌</li> </ul> <p><strong>Q7. 비관적 락을 꼭 써야 하는 상황은?</strong></p> <ul> <li>꼬이면 절대 안 되는 비즈니스 로직</li> <li>은행 계좌 잔액 차감</li> <li>좌석 예약 / 티켓 예매</li> <li>재고 감소 처리</li> <li>충돌 가능성이 높을 때 (낙관적 락은 충돌 났을 때 재시도가 필요하니까)</li> <li>단, 트래픽이 매우 많고 대기 시간이 길어질 수 있다면 Redis 분산 락이나 메시지 큐로 아키텍처 확장 고려</li> </ul> <h3 id="마무리-conclusion">마무리 (Conclusion)</h3> <p><strong>비관적 락 핵심 요약</strong></p> <ul> <li>“읽기 전에 잠금 → 트랜잭션 끝날 때까지 유지”</li> <li>“조회한 행(row)만 잠그지만, 조건이 모호하면 더 넓게 잠글 수도 있음”</li> <li>“멀티 서버 환경에서도 안전”</li> </ul> <p><strong>실무 팁</strong></p> <ul> <li>PK 기반 조회로 락을 거는 습관</li> <li>트랜잭션 길이는 최소화</li> <li>대규모 트래픽 → Redis 분산 락 or MQ 검토</li> </ul>]]></content><author><name></name></author><category term="Database"/><category term="MySQL,"/><category term="SQL,"/><category term="Lock,"/><category term="동시성,"/><category term="트랜잭션"/><summary type="html"><![CDATA[비관적 락(Pessimistic Lock)이란 무엇일까요? 'SELECT FOR UPDATE'의 동작 원리부터 성능 저하 문제, 멀티 서버 환경에서의 동작 방식, 실무 사용 팁까지 개발자가 꼭 알아야 할 7가지 핵심 질문으로 동시성 제어의 모든 것을 완벽하게 정리합니다.]]></summary></entry><entry><title type="html">MySQL 실시간 쿼리 확인하기</title><link href="https://hwangrolee.github.io/blog/MySQL-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%BF%BC%EB%A6%AC-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="MySQL 실시간 쿼리 확인하기"/><published>2025-03-08T00:00:00+00:00</published><updated>2025-03-08T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/MySQL-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%BF%BC%EB%A6%AC-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/MySQL-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%BF%BC%EB%A6%AC-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/"><![CDATA[<h1 id="mysql에서-락-문제-해결-및-관리-방법">MySQL에서 락 문제 해결 및 관리 방법</h1> <p>많은 서비스에서 MySQL을 메인 데이터베이스로 사용하여 서비스를 개발하고 있습니다. MySQL은 RDBMS로서 <strong>Transaction</strong> 단위로 쿼리를 실행하게 되며, <strong>ACID</strong> 특성에 의해 데이터의 신뢰성을 보장합니다. 하지만, 트랜잭션에 의해 락이 발생하고, 락에 의해 쿼리 지연이 발생하면서 서비스 장애를 초래할 수 있습니다. 이번 글에서는 MySQL에서 발생할 수 있는 락 문제를 어떻게 해결할 수 있는지에 대해 살펴보겠습니다.</p> <h2 id="락-발생-원인">락 발생 원인</h2> <h3 id="1-트랜잭션에-의한-락">1. 트랜잭션에 의한 락</h3> <p>MySQL에서 트랜잭션은 <strong>ACID</strong> 특성(Atomicity, Consistency, Isolation, Durability)을 보장하기 위해 실행됩니다. 하지만, 트랜잭션이 실행되는 동안 <strong>락</strong>이 발생하게 되어 다른 트랜잭션이 대기 상태로 들어갑니다. 이로 인해 쿼리 지연이 발생하고, 서비스 장애를 초래할 수 있습니다.</p> <h3 id="2-ddl-명령어에-의한-락">2. DDL 명령어에 의한 락</h3> <p><strong>DDL(Data Definition Language)</strong> 명령어(예: <code class="language-plaintext highlighter-rouge">ALTER</code>, <code class="language-plaintext highlighter-rouge">DROP</code>, <code class="language-plaintext highlighter-rouge">CREATE</code>)는 테이블이나 데이터베이스 구조를 변경합니다. 이러한 명령어는 해당 테이블에 <strong>테이블 락</strong>을 걸어 다른 트랜잭션이 해당 테이블을 수정하는 것을 차단하게 됩니다. 이로 인해 서비스 지연이 발생할 수 있으므로 DDL 실행 시 특별한 주의가 필요합니다.</p> <h2 id="락-문제-해결-방법">락 문제 해결 방법</h2> <h3 id="1-현재-실행-중인-쿼리-모니터링">1. 현재 실행 중인 쿼리 모니터링</h3> <p>쿼리 락이나 DDL 명령어 실행에 의해 락이 발생하면, 해당 락을 유발하는 쿼리를 찾아서 중단시켜야 합니다. 이를 위해 <code class="language-plaintext highlighter-rouge">information_schema.INNODB_TRX</code>를 사용하여 현재 실행 중인 트랜잭션을 모니터링할 수 있습니다. 다음 쿼리를 통해 현재 실행 중인 트랜잭션과 관련된 정보를 확인할 수 있습니다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_id</span><span class="p">,</span>
       <span class="n">aa</span><span class="p">.</span><span class="n">trx_mysql_thread_id</span><span class="p">,</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_state</span><span class="p">,</span>
       <span class="n">bb</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="k">user</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="k">host</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="n">db</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="n">command</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="nb">time</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="k">state</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="n">info</span><span class="p">,</span>
       <span class="n">aa</span><span class="p">.</span><span class="n">trx_started</span><span class="p">,</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_requested_lock_id</span><span class="p">,</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_wait_started</span><span class="p">,</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_weight</span>
<span class="k">FROM</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">INNODB_TRX</span> <span class="n">aa</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">PROCESSLIST</span> <span class="n">bb</span>
    <span class="k">ON</span> <span class="p">(</span><span class="n">bb</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_mysql_thread_id</span><span class="p">)</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">aa</span><span class="p">.</span><span class="n">trx_state</span><span class="p">,</span> <span class="n">bb</span><span class="p">.</span><span class="nb">time</span> <span class="k">DESC</span><span class="p">;</span>
</code></pre></div></div> <p>위 쿼리를 통해 현재 실행 중인 트랜잭션과 관련된 정보를 확인할 수 있습니다. 만약 락을 유발하는 쿼리를 발견하면, KILL 명령어를 통해 해당 쿼리를 중단시킬 수 있습니다.</p> <h3 id="2-락을-유발하는-쿼리-중단">2. 락을 유발하는 쿼리 중단</h3> <p>락을 유발하는 쿼리를 찾아 중지시켜야 합니다. 위에서 제공된 쿼리로 확인한 후, 락을 발생시키는 트랜잭션을 KILL 명령어로 종료합니다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">KILL</span> <span class="p">[</span><span class="n">trx_mysql_thread_id</span><span class="p">];</span>
</code></pre></div></div> <p>이 명령어를 통해 해당 트랜잭션을 강제로 종료시킬 수 있습니다. 이 과정은 락이 발생하여 서비스에 영향을 미치고 있을 때 빠르게 대응할 수 있도록 도와줍니다.</p> <h2 id="락-예방을-위한-best-practices">락 예방을 위한 Best Practices</h2> <h3 id="1-ddl-및-dml-명령어-실행-전-사이드-이펙트-고려">1. DDL 및 DML 명령어 실행 전 사이드 이펙트 고려</h3> <p>DDL 및 DML 명령어를 실행하기 전에 해당 명령어가 락을 발생시킬 수 있는지 여부를 충분히 고려해야 합니다. 이를 통해 락 발생 가능성을 미리 예측하고, 서비스에 미치는 영향을 최소화할 수 있습니다.</p> <h3 id="2-ddl-및-dml-명령어-실행-후-락-모니터링">2. DDL 및 DML 명령어 실행 후 락 모니터링</h3> <p>DDL 및 DML 명령어 실행 후에는 information_schema.INNODB_TRX를 사용하여 현재 실행 중인 쿼리를 모니터링해야 합니다. 쿼리가 밀리는 현상이 발생하면 즉시 락을 유발한 쿼리를 중단하여 서비스 장애를 예방할 수 있습니다.</p> <h3 id="3-트랜잭션-최적화">3. 트랜잭션 최적화</h3> <p>트랜잭션을 가능한 한 작은 범위로 만들어 락의 지속 시간을 줄여야 합니다. 불필요한 쿼리를 실행하지 않도록 하여 락이 필요한 시간을 최소화하고, 트랜잭션 격리 수준을 적절히 설정해 락 경합을 줄일 수 있습니다.</p> <h3 id="4-락-모니터링-도구-사용">4. 락 모니터링 도구 사용</h3> <p>MySQL의 성능 스키마나 MySQL Enterprise Monitor와 같은 도구를 활용하여 실시간으로 락 문제를 모니터링할 수 있습니다. 문제 발생 시 자동으로 알림을 받아 대응할 수 있습니다.</p> <h2 id="결론">결론</h2> <p>MySQL에서 락을 관리하는 것은 서비스의 성능과 안정성에 중요한 영향을 미칩니다. 트랜잭션을 최적화하고, DDL 명령어 실행 시 주의를 기울이며, 락 모니터링을 통해 실시간으로 문제를 해결할 수 있어야 합니다. 이러한 관리 방법을 통해 서비스 장애를 예방하고, 데이터베이스의 성능을 최적화할 수 있습니다.</p>]]></content><author><name></name></author><category term="MySQL,"/><category term="Database"/><category term="MySQL,"/><category term="데이터베이스,"/><category term="Database,"/><category term="쿼리,"/><category term="SQL"/><summary type="html"><![CDATA[MySQL에서 발생하는 락 문제를 해결하는 방법과 락을 유발하는 쿼리를 찾아 종료하는 절차를 설명합니다. 트랜잭션, DDL, DML 명령어의 락 사이드 이펙트를 고려하여 서비스 장애를 예방하고, 락을 관리하는 방법을 소개합니다.]]></summary></entry><entry><title type="html">백엔드 개발자가 리액트 네이티브로 달력 앱을 배포해보았습니다.</title><link href="https://hwangrolee.github.io/blog/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C%EB%A1%9C-%EB%8B%AC%EB%A0%A5-%EC%95%B1%EC%9D%84-%EB%B0%B0%ED%8F%AC%ED%95%B4%EB%B3%B4%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/" rel="alternate" type="text/html" title="백엔드 개발자가 리액트 네이티브로 달력 앱을 배포해보았습니다."/><published>2025-03-08T00:00:00+00:00</published><updated>2025-03-08T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80%20%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C%EB%A1%9C-%EB%8B%AC%EB%A0%A5-%EC%95%B1%EC%9D%84-%EB%B0%B0%ED%8F%AC%ED%95%B4%EB%B3%B4%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4</id><content type="html" xml:base="https://hwangrolee.github.io/blog/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C%EB%A1%9C-%EB%8B%AC%EB%A0%A5-%EC%95%B1%EC%9D%84-%EB%B0%B0%ED%8F%AC%ED%95%B4%EB%B3%B4%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/"><![CDATA[<p>저는 2016년부터 꾸준히 백엔드 개발을 해왔습니다. 백엔드 개발하면서 백오피스개발도 해왔기에 기본적인 프론트엔드 개발 기술은 알고 있는 상태였습니다. 웹 프론트엔드 기술 중 바닐라, 리액트, Nextjs, Angularjs 를 활용해서 웹 프론트엔드를 개발해왔지만 앱을 만들어 본적은 없었어요.</p> <p>퇴근 회사를 퇴사하면서 이번에 앱을 만들어 보고자 크로스 플랫폼에 대해서 공부했습니다.</p> <h3 id="리액트-네이티브-vs-플러터">리액트 네이티브 vs 플러터</h3> <p>빠르고 간단하게 앱을 만들고 싶었기에 당연하게 크로스 플랫폼 기반으로 앱을 만들기로 정했습니다. 그리고 리액트 네이티브와 플러터를 비교해보았고 저는 <em>리액트 네이티브</em> 를 선택했습니다.</p> <p>제가 리액트 네이티브를 선택한 이유는…</p> <p><strong>1. 자바스크립트(타입스크립트)로 개발이 가능합니다.</strong></p> <p>자바스크립트로 개발을 할 수 있다는 것은 굉장히 큰 메리트였습니다. 웹 프론트엔드 개발 경험이 있어서 자바스크립트에 대해서는 크게 불편함이 없었기에 언어에 대한 허들이 낮았기에 쉽게 접근 할 수 있을 거라 생각 했습니다. 그리고 플러터를 개발하기 위해 Dart(다트) 언어를 공부해도 되지만 제가 다시 앱을 만들지 않는 이상 Dart 언어를 사용할 일은 없을 거라 아마 다시 까먹게 될 언어라고 생각했습니다.</p> <p><strong>2. 프레임워크 생태계가 리액트 네이티브가 더 커요.</strong></p> <p>리액트 네이티브는 리액트 기반이기 때문에 플러터보다 먼저 오픈소스 생태계가 활성화 되어 있었기 때문에 구글링으로 빠르게 이슈를 해결할 수 있을 거라 생각했습니다. 앱 개발에 있어서 이슈 해결을 위한 프레임워크 생태계는 생각보다 많이 중요하기 때문입니다.</p> <p><strong>3. 플러터의 장점이 저에게 있어선 큰 장점이 아니었어요.</strong></p> <p>플러터가 리액트 네이티브보다 성능면에서 좋다고 합니다. 제가 플러터를 경험해보지 않았고 직접 경험해보지 않았지만 확실히 성능 측면에서는 차이가 있다고 해서 조금 고민을 했습니다. 하지만 제가 만들 달력 앱은 간단한 앱이기 때문에 애니메이션, 렌더링, 데이터 처리 등등 성능 측면에서 큰 문제가 되지 않을 거라 생각했습니다. 만약 성능 측면에서 많이 고려해야하는 앱을 만들 예정이었다면 플러터를 고려하지 않았을까 생각됩니다.</p> <p>위 3가지의 이유로 리액트 네이티브를 선택하였고 개발을 시작했죠.</p> <h3 id="라이브러리-선택의-갈림길">라이브러리 선택의 갈림길</h3> <p>개발은 생각보다 순조로웠고 어렵다는 생각이 들지 않았습니다.</p> <p><strong>1. 상태 관리 라이브러리는 무엇을 맞을까? (Redux vs Recoil)</strong></p> <p>과거 리액트 시장에서는 상태 관리 라이브러리는 당연히 Redux 였습니다. 하지만 몇 년전 recoil 이라는 새로운 라이브러리를 리액트에서 만들었고 많이 사용되고 있죠. Redux 는 과거부터 사용해왔기에 당연히 생태계와 안정성은 많은 사람들에게 인정받아왔고 지금이 많이 활용되고 있습니다. 하지만 저는 Recoil 을 사용하기로 했습니다. 이유는 상태 관리가 그렇게 복잡하지 않을 뿐더러 복잡하더라도 Redux 보다는 리액트에서 직접 만든 Recoil 이 저에게 있어서 좀 더 신뢰도가 높기 때문입니다. 사용성도 편한 것 같고..</p> <p><strong>2. 스타일링 라이브러리는 무엇이 좋을까?(Styled Component VS Style Sheet)</strong></p> <p>처음 개발 시작 할 때에는 Style Sheet 를 사용했어요. 테마 기능을 넣으려고 보니 Style Sheet 로는 한계점이 보였고 과감하게 Styled Component 로 옮겼습니다. 테마 관리에 있어서는 Styled Component 가 훨씬 편하기 때문입니다.</p> <p>프레임워크 생태계가 방대하다는 것은 다양한 라이브러리가 존재하고 개발자 취향에 따라 원하는 라이브러리를 선택할 수 있다는 점이지만 때로는 선택을 하는데 너무 많은 시간을 소비해야하는 단점이 있는 것 같네요.</p> <h3 id="피그마로-앱-아이콘-앱-소개-이미지를-만들어-보았어요">피그마로 앱 아이콘, 앱 소개 이미지를 만들어 보았어요.</h3> <p>달력앱을 만드는 것은 어렵지 않았어요. 오히려 기본 기능을 개발 후 배포하는 것이 더 어렵고 힘든 작업이었습니다. 혼자서 하려니 생각할 것이 너무나 많았습니다.</p> <p>디자이너가 만든 피그마를 확인해서 개발한 적은 있지만 직접 피그마로 디자인해보는 건 처음 이었어요. 다행히 피그마에는 앱 아이콘, 앱 소개 이미지를 위한 다양한 템플릿이 있었고 이것 저것 사용해보다가 초보인 제가 사용하기 쉬운 템플릿으로 앱 아이콘과 앱 소개 이미지를 제작했습니다.</p> <ul> <li><a href="https://www.figma.com/design/6VPVTMzVb65jwiyOQhIKLC/App-Icon-Toolkit---iOS%2FmacOS%2FAndroid-(Community)?m=auto&amp;t=8rs8r8NsRwi6oqMx-6">앱 아이콘 템플릿</a></li> <li><a href="https://www.figma.com/design/P9dmo9eVszzV8Ej0HXXsNI/App-Store-Screenshot-Template-(Community)?m=auto&amp;t=MNR6nfA6x2cdmcr5-6">앱 이미지 템플릿</a></li> </ul> <h3 id="앱-노출-극대화를-위한-키워드-리서치-앱-소개글-작성하기">앱 노출 극대화를 위한 키워드 리서치, 앱 소개글 작성하기</h3> <p>흔히 ASO 라고 해서 앱 스토어에서 앱 노출 극대화를 위해 키워드 리서치를 합니다. 키워드 리서치할 때 많이 사용하는 툴은 드래곤 메트릭스와 같은 툴을 많이 사용하지만 저는 ChatGPT 를 사용했어요 귀찮…</p> <h3 id="결론">결론</h3> <p>백엔드 개발자인 제가 앱을 배포해본다는 것은 좋은 경험이었고 저와 같이 일하는 다른 팀원분들의 고충도 이해하게 되었습니다.</p>]]></content><author><name></name></author><category term="React"/><category term="Native"/><category term="리액트네이티브,달력앱"/><summary type="html"><![CDATA[백엔드 개발자가 리액트 네이티브를 활용해 첫 앱을 배포한 경험을 공유합니다. 리액트 네이티브 vs 플러터 비교, 상태 관리, 스타일링, ASO 키워드 리서치까지!]]></summary></entry><entry><title type="html">MySQL 트랜잭션 격리수준 Isolation level 알아보기</title><link href="https://hwangrolee.github.io/blog/MySQL-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80-Isolation-level-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/" rel="alternate" type="text/html" title="MySQL 트랜잭션 격리수준 Isolation level 알아보기"/><published>2024-12-15T00:00:00+00:00</published><updated>2024-12-15T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/MySQL-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80-Isolation-level-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/MySQL-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80-Isolation-level-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/"><![CDATA[<p>트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 다른 트랜잭션에서 변경이 일어났을 때 해당 데이터를 또 다른 트랜잭션에서 조회가 가능하게 할지를 허용할지 말지를 결정하는 것이다. 격리 수준에는 총 4개가 있다.</p> <ul> <li>READ UNCOMMITTED</li> <li>READ COMMITTED</li> <li>REPEATABLE READ</li> <li>SERIALIZABLE 위 4개 중 첫번째인 READ UNCOMMITTED는 격리수준이 가장 낮고 SERIALIZABLE 은 격리 수준이 가장 높다.</li> </ul> <h2 id="1-read-uncommitted">1. READ UNCOMMITTED</h2> <p>트랜잭션 격리수준 중 가장 낮은 단계로 성능이 가장 좋지만 다른 트랜잭션에서 커밋되지 않은 데이터를 읽어 올 수 있기 때문에 잘 못 사용할 경우 데이터 정합성에 큰 이슈가 발생 할 수 있다.</p> <p>Transaction_A 에서 INSERT, UPDATE, DELETE 쿼리를 실행 후 아직 커밋하지 않았지만 Transaction_B 에서 SELECT 쿼리를 실행시키게 되면 INSERT, UPDATE, DELETE 쿼리 결과가 보이게 된다. 이 때 Transaction_A 는 COMMIT 하지 않고 ROLLBACK 을 하게 되면 Transaction_B 는 실제 데이터베이스에 없는 데이터를 읽게 된 것이며 이를 더티리드(Dirty read) 라고 한다.</p> <p>트랜잭션에서 INSERT, UPDATE, DELETE 쿼리를 실행할 경우 커밋하기 전에는 Undo 영역에 변경 전 데이터를 저장하고 레코드의 값을 변경한다. 이 때 Rollback 을 하게 되면 Undo 영역에 있던 데이터를 레코드로 복원하게 된다.</p> <p>READ_UNCOMMITTED 는 레코드에 저장된 값을 가저오기 때문에 롤백이 된 데이터를 읽어 올 수 있다.</p> <p>READ UNCOMMITTED 는 정합성 이슈가 발생하지 않는 SELECT 쿼리에서만 사용할 것을 권장하며 READ UNCOMMITTED로 읽은 데이터로 INSERT, UPDATE, DELETE 에 사용하지 않도록 주의해야 한다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- [SESSION_1]</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">SET</span> <span class="k">SESSION</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">UNCOMMITTED</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- name = 'one' 인 데이터가 출력됨.</span>

<span class="c1">-- [SESSION_2]</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="k">user</span> <span class="k">SET</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'two'</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'one'</span><span class="p">;</span>
<span class="c1">-- name = 'one' 을 'two' 로 업데이트함. 아직 커밋하지 않았음.</span>
<span class="c1">-- [SESSION_1]</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- name = 'two' 인 데이터 출력됨.</span>
<span class="c1">-- [SESSION_2]</span>
<span class="k">ROLLBACK</span><span class="p">;</span>
<span class="c1">-- 트랜잭션을 롤백</span>
<span class="c1">-- [SESSION_1]</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- 롤백전에는 name = 'two' 인 데이터가 출력되었지만 롤백 후에는 이전 데이터인 'one'인 데이터가 출력됨</span>
</code></pre></div></div> <p>위 내용을 직접 테스트해 보았을 때 name = ‘two’ 는 트랜잭션 내부에서 업데이트문만 실행했을 뿐 COMMIT 하지 않았지만 다른 세션에서 실행한 트랜잭션에서 읽을 수 있다. name = ‘two’가 제대로 커밋 된다면 다행이지만 롤백이 된다면 잘못된 데이터를 불러온 것이 된다.</p> <blockquote class="block-tip"> <h5 id="tip">TIP</h5> <p>READ UNCOMMITTED 는 자주 호출되지만 INSERT, UPDATE, DELETE 쿼리에는 영향이 가지 않는 곳에서 사용해야만 한다.</p> </blockquote> <h2 id="2-read-committed">2. READ COMMITTED</h2> <p>MSSQL, Oracle 의 기본 트랜잭션 격리수준으로 커밋 된 데이터를 읽을 수 있는 격리수준이다. 커밋 된 데이터만 읽기 때문에 READ UNCOMMITTED 처럼 더티리드(Dirty read)가 발생하지 않기 때문에 대부분의 데이터를 신뢰할 수 있다.</p> <p>READ COMMITTED 격리수준이라고 해서 모든 상황에서 데이터를 신뢰 할 수 있는 것은 아니다. 바로 Unrepeatable read 로 인해 다른 트랜잭션 간에 커밋 타이밍에 따라 데이터 정합성이 어긋 날 수 있기 때문이다. 그래서 READ COMMITTED 는 대부분의 데이터를 신뢰할 수 있다 라고 표현했다.</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- [SESSION_1]</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">SET</span> <span class="k">SESSION</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">COMMITTED</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- name = 'one' 인 데이터가 출력됨.</span>
<span class="c1">-- [SESSION_2]</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="k">user</span> <span class="k">SET</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'two'</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'one'</span><span class="p">;</span>
<span class="c1">-- name = 'one' 을 'two' 로 업데이트함. 아직 커밋하지 않았음.</span>
<span class="c1">-- [SESSION_1]</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- SESSION_2가 커밋되지 않았기 때문에 name = 'one' 인 데이터 출력됨.</span>
<span class="c1">-- [SESSION_2]</span>
<span class="k">COMMIT</span><span class="p">;</span>
<span class="c1">-- 커밋했기 때문에 디비에 데이터 반영됨.</span>
<span class="c1">-- [SESSION_1]</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span><span class="p">;</span>
<span class="c1">-- SESSION_2가 커밋되면서 name = 'two' 인 데이터가 출력된.</span>
<span class="n">name</span><span class="o">=</span><span class="s1">'one'</span>
</code></pre></div></div> <p>위 상황과 같이 SESSION_1 은 트랜잭션이 시작 했을 때 데이터를 확인해보면 name=’one’ 인 상태인데 SESSION_2 에서 트랜잭션 시작 후 업데이트 후 커밋까지 한 후 SESSION_1 에서 다시 조회를 하면 name = ‘two’ 로 바뀌어 있습니다. 이 처럼 같은 트랜잭션 내에게 같은 데이터를 조회했을 때 다른 데이터가 출력된다면 이 또한 데이터 정합성에 문제가 발생할 수 있다.</p> <p>일반적인 상황에서는 크게 문제되지 않지만 같은 트랜잭션 내에서 같은 SELECT 쿼리 여러번 호출하는 경우에는 이슈가 발생할 수 있다. 되도록이면 같은 트랜잭션 내에서 같은 SELECT 쿼리를 호출하는 케이스를 줄이도록 한다면 위와 같이 Unrepeatable read 현상을 줄일 수 있다.</p> <h2 id="3-repeatable-read">3. REPEATABLE READ</h2> <p>READ COMMITTED 와 같이 커밋 된 데이터를 읽지만 Unrepeatable read 현상이 발생하지 않는 격리 수준이다. MySQL 의 InnoDB 엔진에서 사용하는 기본격리수준이다.</p> <p>REPEATABLE READ는 Unrepeatable read 가 발생하지 않도록 트랜잭션이 시작하는 시점의 스냅샷을 기준으로 데이터를 조회한다. 다른 트랜잭션에 데이터가 업데이트되었더라도 현재 트랜잭션에서는 스냅샷 기준으로 데이터를 가저오기 때문에 Unrepeatable read 현상이 발생하지 않는다.</p> <p>트랜잭션을 시작하게 되면 트랜잭션에는 번호를 가지게 되고 언두 영역의 백업된 모든 레코드에는 백업한 트랜잭션 번호가 포함되어 있다. 그리고 언두 영역의 백업된 데이터는 InnoDB 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제한다.</p> <p>REPEATABLE READ 는 PHANTOM READ(=PHANTOM ROW) 라는 이슈가 발생한다. PHANTOM READ는 첫번째 SELECT 문에서 보이지 않았던 데이터가 두번째 SELECT 쿼리에서는 보이는 현상이다.</p> <p>InnoDB 에서의 독특한 매커니즘으로 인해 PHANTOM READ 현상은 발생하지 않는다. 직접 MySQL 로 테스트를 해보았을 때 발생하지 않았다.</p> <p>INSERT 쿼리 실행 후 커밋하지 않은 상태에서 다른 트랜잭션에서 SELECT ~ FOR UPDATE 를 실행 시 INSERT 를 실행 한 트랜잭션에 의해 SELECT ~ FOR UPDATE 쿼리는 락이 걸리게 되어 PHANTOM READ 가 발생하지 않는다.</p> <h2 id="4-serializable">4. SERIALIZABLE</h2> <p>가장 엄격한 격리수준으로 동시 작업 성능이 가장 떨어지는 격리 수준이다. SELECT 쿼리는 기본적으로 SHARED LOCk 을 기본적으로 획득하게되어 SELECT 중 INSERT, UPDATE, DELETE 가 불가능하다.</p> <h2 id="5-결론">5. 결론</h2> <p>기본적으로 <em>READ COMMITTED 혹은 REPEATABLE READ 를 사용할 것을 권장</em>한다.</p> <p>되도록이면 1개의 트랜잭션에서 같은 SELECT 쿼리를 실행하지 않도록 주의한다. READ COMMITTED의 경우 1개의 트랜잭션에서 같은 SELECT 문을 실행시 Unrepeatable read 현상이 발생할 여지가 있다. REPEATABLE READ 의 경우 PHANTOM READ가 발생할 수 있다. (InnoDB 외 다른 엔진에서 PHANTOM READ 발생)</p> <p>SERIALIZABLE 은 사용하지 않는 것이 정신 건강에 좋다. 실시간성을 보장받지 않고 데이터가 정확하지 않아도 되는 기능의 경우 READ UNCOMMITTED 를 사용하면 성능을 높일 수 있다.</p> <h2 id="6-참고">6. 참고</h2> <ul> <li>https://zzang9ha.tistory.com/381</li> <li>Real Mysql 8.0</li> </ul>]]></content><author><name></name></author><category term="MySQL"/><category term="mysql,"/><category term="트랜잭션,"/><category term="IsolationLevel,"/><category term="격리수준,"/><category term="Transaction"/><summary type="html"><![CDATA[MySQL 트랜잭션 격리수준 Isolation level 알아보기]]></summary></entry><entry><title type="html">레디스에 대한 간단한 설명과 성능향상시키기</title><link href="https://hwangrolee.github.io/blog/%EB%A0%88%EB%94%94%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%84%A4%EB%AA%85%EA%B3%BC-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%8B%9C%ED%82%A4%EA%B8%B0/" rel="alternate" type="text/html" title="레디스에 대한 간단한 설명과 성능향상시키기"/><published>2024-12-08T00:00:00+00:00</published><updated>2024-12-08T00:00:00+00:00</updated><id>https://hwangrolee.github.io/blog/%EB%A0%88%EB%94%94%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%84%A4%EB%AA%85%EA%B3%BC-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%8B%9C%ED%82%A4%EA%B8%B0</id><content type="html" xml:base="https://hwangrolee.github.io/blog/%EB%A0%88%EB%94%94%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%84%A4%EB%AA%85%EA%B3%BC-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%8B%9C%ED%82%A4%EA%B8%B0/"><![CDATA[<h2 id="0-레디스란">0. 레디스란?</h2> <p>memcached와 같은 인메모리 데이터베이스로 데이터를 메모리에 저장하기 때문에 속도가 빨라 서비스의 성능을 개선시키는 목적으로 많이 사용한다.</p> <p>데이터가 메모리에서 관리되기 때문에 레디스를 재가동할경우 저장된 데이터는 사라진다. 이러한 문제는 백업, 클러스터, 센티널등을 활용하여 개선할 수 있다.</p> <p>레디스의 경우 memcached와 많이 비교가 되고 있다. memcached의 경우 key-value로만 데이터를 저장할 수 있지만 레디스는 Lists, Sets, Hashes등 많은 데이터타입을 지원하고 있어서 현업에서 많이 쓰이고 있다.</p> <p>레디스는 기본적으로 싱글쓰레드로 동작한다. 그렇기 때문에 명령어를 사용할때 최대한 실행복잡도가 O(1) 인 명령어를 사용하도록 노력해야 한다. 특히, keys, flushall, flushdb, smembers, hgetall 과 같은 명령어는 사용을 금지하도록 개발자들끼리 소통을 하면 좋다. 혹은 redis 6.0.0 부터 지원하는 ACL기능을 사용하여 강제로 명령어를 막아도 좋다. (ACL기능은 직접사용해 보진 못했다.)</p> <p><code class="language-plaintext highlighter-rouge">keys, smembers, hgetall 과 같은 기능은 scan, sscan, hscan 으로 명령어를 대체할 수 있다.</code></p> <hr/> <h2 id="1-데이터-타입">1. 데이터 타입</h2> <h3 id="11string">1.1.String</h3> <p>Key와 Value 가 일 대 일 관계이다. 알파벳, 숫자, 한글등을 저장할 수 있다. Key 와 Value 모두 최대 길이는 512MB 이다.</p> <h3 id="12-lists">1.2. Lists</h3> <p>데이터를 링크드 리스트 형태로 관리하여 입력된 순서대로 저장되어 큐, 스택으로도 활용이 가능하다. 단 같은 값을 넣었을 때 중복으로 데이터가 들어갈 수 있다.</p> <p>Redis 3.2 이전 버전에서는 데이터수가 512개이하라면 짚리스트를 사용하고 513개부터를 링크드리스트를 사용한다고 한다.</p> <p>Redis 3.2 부터는 퀵리스트로 데이터를 저장하도록 확정되었다. 퀵리스트는 레디스를 메인디비로 사용한다고 알려진 트위터에서 발표했으며 Yao yu가 발표했다고 한다. 짚리스트, 링크드 리스트의 성능을 대폭 향상시켰다고 한다.</p> <blockquote class="block-warning"> <h5 id="주의사항"><strong>주의사항</strong></h5> <p><code class="language-plaintext highlighter-rouge">BRPOP</code>: 데이터가 들어오면 오른쪽에서 데이터를 꺼내온다. 데이터가 있다면 RPOP처럼 오른쪽 데이터를 꺼내오지만 데이터가 없다면 데이터가 들어올때까지 timeout 시간만큼 기다린다</p> <p><code class="language-plaintext highlighter-rouge">BLPOP</code>: 데이터가 들어오면 왼쪽에서 데이터를 꺼내온다. 데이터가 있다면 LPOP처럼 왼쪽 데이터를 꺼내오지만 데이터가 없다면 데이터가 들어올때까지 timeout 시간만큼 기다린다</p> <p><code class="language-plaintext highlighter-rouge">BRPOPLPUSH</code>: 데이터가 들어오면 오른쪽에서 꺼내서 왼쪽으로 넣는다. 데이터가 있다면 RPOPLPUSH처럼 오른쪽에서 꺼내서 왼쪽에 넣지만 데이터가 없다면 데이터가 들어올때까지 timeout 시간만큼 기다린다.</p> <p>레디스는 싱글쓰레드로 동작한다. 위 3개의 명령어는 레디스에 락을 유도할 수 있기 때문에 사용에 특히 유념해야 한다.</p> </blockquote> <h3 id="13-sets">1.3. Sets</h3> <p>데이터의 중복을 허용하지 않은 일대 다 관계입니다. Sets의 데이터는 기본적으로 해시테이블로 저장되지만 숫자의 경우 정수배열데이터 구조를 가진다. 정수배열 데이터 구조는 해시테이블보다 메모리를 적게 사용합니다.메모리 용량을 중요시한다면 데이터를 정수 값으로 관리하면 좋을것 같다.</p> <p><code class="language-plaintext highlighter-rouge">smembers 대신 sscan 명령어를 사용하자.</code></p> <h3 id="14-hashes">1.4. Hashes</h3> <p>데이터를 field, value 구조로 저장가능하며 rdb의 테이블 구조와 비슷하다. 1개의 key에 field, value 쌍으로 약 40억개를 저장할 수 있다. 하지만 퍼포먼스 측면에서 1,000개정도의 데이터씩 관리하는걸 추천한다고 한다. hashes에 한번 너무 많은 데이터를 넣은 후 삭제할 경우 이슈가 생길 수 있다.</p> <p><code class="language-plaintext highlighter-rouge">hgetall 대신 hscan 명령어를 사용하자.</code></p> <h3 id="15-sorted-set">1.5. Sorted Set</h3> <p>1개의 key에 여러개의 score, value 형태로 저장할 수 있으며 value는 중복된 데이터를 넣을 수 없고 score로 정렬된다. 정렬을 필요로 하는 데이터 관리하면 좋다.</p> <hr/> <h2 id="2-레디스를-운영할때-기억하면-좋은-것들">2. 레디스를 운영할때 기억하면 좋은 것들</h2> <h3 id="21-만료일을-항상-넣는다">2.1. 만료일을 항상 넣는다.</h3> <p>메모리라는 한정된 데이터를 사용하기 때문에 만료일을 지정하여 데이터가 만료일에 지워질 수 있게 관리하자.</p> <h3 id="22-지워지면-안되는-데이터라면-백업을-하자">2.2. 지워지면 안되는 데이터라면 백업을 하자.</h3> <p>지워지면 안되는 데이터라면 RDB + AOF 기능을 사용하여 항상 백업을 하자. RDB 를사용하여 디스크에 바이너리파일로 백업하자.RDB로 백업을 안하는 시간동안에는 AOF로 백업을 하자.</p> <h3 id="23-slowlog로-성능을-확인하자">2.3. Slowlog로 성능을 확인하자</h3> <p>redis는 상당히 빠른 속도를 자랑하는 데이터베이스이기 때문에 조금만 느려지더라도 사용량에 따라 서비스에 큰 영향을 줄 수 있다. 그래서 레디스에 이슈가 있을때 가장 먼저 보는 것 중 하나는 Slowlog이다.</p> <p>slowlog를 통해 command, timestamp, duration, ip 등의 정보를 알 수 있어 오래걸리는 명령어를 찾기 편리합니다. 하지만 slowlog는 기본적으로 메모리에 저장된다. enterprise 버전에서는 파일로 기록도 가능하다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 설정한 시간(microseconds) 이상인 명령을 기록한다.</span>
<span class="c"># 기본값은 10000(10ms) 이다.</span>
<span class="c"># 0으로 입력하면 모든 명령어를 기록한다.</span>
<span class="c"># 비활성화 하려면 음수로 설정.</span>
slowlog-log-slower-than 10000

<span class="c"># 설정한 수 만큼 보관한다.</span>
<span class="c"># 기본값은 128이다.</span>
<span class="c"># 제한은 없으며 꽉차면 오래된 것부터 지우고 새로운 명령어가 기록된다.</span>
slowlog-max-len 128
</code></pre></div></div> <h3 id="24-aof로-명령어-백업하기">2.4. AOF로 명령어 백업하기</h3> <p>명령어들을 파일에 저장 후 레디스가 리부트되면 파일에 저장된 명령어를 실행시켜서 데이터를 복구한다. 기본적으로 appendonly.aof 에 기록되며 입력/수정/삭제명령어 실행될때 마다 버퍼에 기록 후 파일에 기록된다.</p> <p>파일이 너무 커질 것을 대비하여 일정 시간마다 파일을 다시 쓰게 되며 rewrite 시 최종값이 파일에 기록된다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># AOF 기능 사용 유무</span>
appendonly <span class="nb">yes</span>|no

<span class="c"># 파일 이름을 지정한다.</span>
appendfilename <span class="o">[</span>filename]

<span class="c"># 파일에 명령어를 기록하는 시점.</span>
<span class="c"># always: 명령 실행시마다 AOF 파일에 기록.</span>
<span class="c"># everysec: 1초마다 파일에 기록. 1초 사이의 데이터가 유실될 수 있다.</span>
<span class="c"># no: 파일에 기록하는 시점을 os가 지정. 리눅스는 30초 간격으로 기록.</span>
appendfsync <span class="o">[</span>always | everysec | no]

<span class="c"># 이 값을 100으로 했다면 이전 다시 쓰기한 다음 AOF 파일 크기가 100% 증가했으면 다시 쓰기한다.</span>
<span class="c"># 즉 값이 100이고, 이전 rewrite 했을때 1GB 였는데 파일이 2GB 되었다면 (100% 증가) rewrite 한다.</span>

auto-aof-rewrite-percentage <span class="o">[</span> 0-100 <span class="o">]</span>

<span class="c"># 64mb 이하면 rewrite를 하지 않는다.</span>
auto-aof-rewrite-min-size <span class="o">[</span> 64mb <span class="o">]</span>

<span class="c"># AOF 파일을 rewrite 할 때 disk에 쓰는 fsync를 32mb씩 나누어서 한다.</span>
<span class="c"># 이것은 대량 디스크 쓰기로 발생할 수 있는 문제를 피할 수 있다.</span>
aof-rewrite-incremental-fsync <span class="o">[</span> <span class="nb">yes</span> | no <span class="o">]</span>

<span class="c"># AOF 파일을 재작성할 때, Redis는 RDB preamble을 이용하여 더 빠르게 쓰고 복구할 수 있다.</span>
<span class="c"># 이 옵션이 활성화되어 있다면, AOF파일을 재작성하는 작업은 다음 두 가지 스탠자(구)로 구성된다.</span>
<span class="c"># 로딩 중, Redis는 AOF 파일이 "REDIS"라는 문자열로 시작한다면 알아차리고, 고정된 앞 부분은 RDB 파일로 로드하고, 계속해서 뒷 부분은 AOF파일로 로드한다.</span>
<span class="c"># Redis 5.0 부터 기본값 yes. 5.0 이전은 no</span>
aof-use-rdb-preamble <span class="o">[</span> <span class="nb">yes</span> | no <span class="o">]</span>
</code></pre></div></div> <h3 id="25-rdb로-백업하기">2.5. RDB로 백업하기</h3> <p>레디스 데이터를 특정 시점에 바이너리 파일로 저장하는 방식으로 명령어를 저장하는 AOF 파일보다 파일 사이즈가 작기때문에 레디스 시작시 빠르게 데이터를 로드한다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># rdb 저장 시점을 지정한다.</span>
<span class="c"># time동안 count 만큼의 key변경이 발생하면 파일로 저장</span>
save <span class="o">[</span><span class="nb">time</span><span class="o">]</span>, <span class="o">[</span>count]

<span class="c"># 저장된 파일명을 지정</span>
dbfilename <span class="o">[</span> filename <span class="o">]</span>

<span class="c"># yes 일때 파일로 쓰다 실패하면 이 후 모든 쓰기 요청을 막는다.</span>
<span class="c"># no 일때 파일ㄹ을 쓰다 실패하면 이 후 모든 동작으로 정상적으로 처리한다.</span>
<span class="c"># save 명령어일때에만 적용되며 bgsave에서는 적용되지 않는다.</span>
stop-writes-on-bgsave-error <span class="o">[</span> <span class="nb">yes</span> | no <span class="o">]</span>

<span class="c"># 파일을 쓸때 LZF 방식으로 압축할지 정한다.</span>
<span class="c"># 기본값은 yes 이고 저장공간활용 측면에서 유리하다</span>
<span class="c"># 압축할때 CPU를 사용하는데 부담된다면 no.</span>
rdbcompression <span class="o">[</span> <span class="nb">yes</span> | no <span class="o">]</span>

<span class="c"># 파일이 정확히 저장되었는지 확인하는 방법으로 checksum을 파일 끝에 추가할 수 있다.</span>
<span class="c"># 이 기능을 사용하면 파일의 정확성을 높일 수 있지만 파일을 저장할때, 로딩할때 10%정도 성능저하를 일으킬 수 있다.</span>
<span class="c"># 기본값 yes</span>
rdbchecksum <span class="o">[</span> <span class="nb">yes</span> | no <span class="o">]</span>

<span class="c"># RDB 파일을 쓸 때 disk에 쓰는 fsync를 32mb씩 나누어서 한다.</span>
<span class="c"># 이점은 appendfsync가 everysec일 때, 디스크를 나누어서 사용하므로써,</span>
<span class="c"># 1초마다 발생하는 AOF file 디스크 쓰기에 문제가 없도록하기 위함이다.</span>
<span class="c"># 기본값 yes</span>
rdb-save-incremental-fsync <span class="o">[</span> <span class="nb">yes</span> | no <span class="o">]</span>
</code></pre></div></div> <h3 id="26-클러스터-센티널환경이라면-백업은-선택사항이다">2.6. 클러스터, 센티널환경이라면 백업은 선택사항이다.</h3> <p>클러스터와 센티널환경이라면 마스터가 다운되면 자동으로 슬레이브가 마스터로 승격되고 죽었던 이전 마스터노드는 슬레이브로 바뀌기 때문에 데이터 손실이 없다고 봐도 무방하기 때문에 백업을 하지 않아도 된다고 한다.</p> <h3 id="27-데이터-삭제는-lazyfree-기능을-활용하자">2.7. 데이터 삭제는 Lazyfree 기능을 활용하자</h3> <p>데이터를 삭제하는 작업은 레디스에게 있어 큰 부담을 주는 작업이다. 하나의 키에 있는 데이터를 모두 지워야 하게 때문에 키에 담긴 데이터에 따라 수행시간이 얼마나 걸릴지 알 수 없다. 그래서 Redis 4.0 부터는 lazyfree 파라미터가 추가되었다.</p> <ul> <li><code class="language-plaintext highlighter-rouge">lazyfree-lazy-eviction</code>: eviction policy 에 의해 데이터가 지워질때 Del 명령어가 아닌 Unlink 명령으로 삭제한다.</li> <li><code class="language-plaintext highlighter-rouge">lazyfree-lazy-expire</code>: 만료된 키를 제거할때 Unlink 명령어를 사용합니다. 기본적으로 Del 명령어를 사용한다.</li> <li><code class="language-plaintext highlighter-rouge">lazyfree-lazy-server-del</code>: 존재하는 키에 SET 으로 다른 값을 넣을때, 키 이름을 바꿀때, SUNIONSTORE 명령에서 destination key와 source key를 같은 key로 지정했을 때 Unlink 명령어를 사용한다.</li> <li><code class="language-plaintext highlighter-rouge">lazyfree-lazy-user-del</code>: Del 명령이 내부적으로 Unlink로 동작한다.</li> <li><code class="language-plaintext highlighter-rouge">slate-lazy-flush</code>: slave 가 master로부터 전체 데이터를 받을 때 기존 데이터를 삭제하는데 이 때 Flushall async 로 데이터를 삭제하기 때문에 보다 빠르게 동기화 할 수 있다. 단, 비동기여도 삭제중에 데이터를 저장하는 것이기 때문에 메모리가 더 필요하다.</li> </ul> <h3 id="28-maxmemory-를-활용하자">2.8. Maxmemory 를 활용하자</h3> <p>레디스를 캐시로 사용한다면 maxmemory와 eviction policy를 설정하게 활용하자. maxmemory는 32비트 환경에서는 3GB가 기본으로 세팅되어 있고 64비트에서는 무제한으로 설정되어 있다.</p> <p>머신의 메모리를 넘게 되면 레디스는 죽게되고 서비스에도 큰 장애를 줄 수 있다. maxmemory과 eviction policy를 지정하면 메모리가 maxmemory만큼 찻을때 eviction policy 에 따라 자동으로 기존 키가 제거되고 새로운 키를 저장한다.</p> <p>Eviction policy의 종류는 아래와 같이 있다.</p> <ul> <li><code class="language-plaintext highlighter-rouge">noeviction</code>: maxmemory에 도달하면 쓰기/삭제 작업시 오류를 반환한다.</li> <li><code class="language-plaintext highlighter-rouge">allkeys-lru</code>: 새로 추가된 데이터의 용량을 확보하기 위해 최근에 사용하지 않은 키를 제거한다.</li> <li><code class="language-plaintext highlighter-rouge">volatile-lru</code>: 새로 추가된 데이터의 용량을 확보하기 위해 TTL이 설정된 키들 중 최근에 사용하지 않은 키를 제거한다.</li> <li><code class="language-plaintext highlighter-rouge">allkeys-lfu</code>: 새로 추가된 데이터의 용량을 확보하기 위해 사용빈도수가 가장 적은 키를 제거한다. (최근 저장된 키라도 사용 빈도수가 적다면 대상이 될 수 있다.)</li> <li><code class="language-plaintext highlighter-rouge">volatile-lfu</code>: 새로 추가된 데이터의 용량을 확보하기 위해 TTL이 설정된 키들 중 사용빈도 수가 적은 키를 제거한다 (최근 저장된 키라도 사용 빈도수가 적다면 대상이 될 수 있다.)</li> <li><code class="language-plaintext highlighter-rouge">allkeys-random</code>: 새로 추가된 데이터의 용량을 확보하기 위해 무작위로 키를 제거한다.</li> <li><code class="language-plaintext highlighter-rouge">volatile-random</code>: 새로 추가된 데이터의 용량을 확보하기 위해 TTL이 설정된 키들 중 무작위로 키를 제거한다.</li> <li><code class="language-plaintext highlighter-rouge">volatile-ttl</code>: 새로 추가된 데이터의 용량을 확보하기 위해 TTL이 짧은 키를 제거한다.</li> </ul> <p>운영중인 레디스에 적용할 경우 config set 명령어를 사용하고 redis.conf 에도 업데이트한다.</p> <h3 id="29-tcp-keepalive를-조정하자">2.9. tcp-keepalive를 조정하자.</h3> <p>TCP 통신시 3-way handshake 가 필요하다. TCP 통신을 위해 반드시 지켜야하는 표준 규약이면 회피할 수 없는 방법이다. TCP 통신할때마다 3-way handshake를 진행한다면 상당한 리소스가 소모되기때이다. 통신이 지속적으로 이루어진다면 한번 열어둔 세션을 없애지 않고 사용하면 효율적이라고 판단이 되었고 이를 위해 TCP keepalive 개념이 생겨나게 되었다.</p> <p>tcp keepalive 기능은 커넥션을 유지하기 때문에 새로운 요청이 왔을때 기존 커넥션을 사용하여 통신을 할 수 있다. 하지만 반대로 요청을 받아들이지 않는 좀비 커넥션이 생길 수 있다는 단점도 가지고 있다.</p> <p>좀비 커넥션 생성을 막기 위해 tcp-keepalive에 초를 설정하면 설정한 시간마다 연결이 유지되었는지를 확인하고 응답을 받았다면 연결을 유지하고 응답을 받지 못한다면 소켓을 닫는다.</p> <blockquote class="block-tip"> <h5 id="tip">Tip</h5> <p>Redis 버전 3.2.1 부터 기본값 300이며 값이 0 이면 계속 열어둔다.</p> </blockquote> <h3 id="210-한번에-여러-명령어를-쓸-경우-pipeline-활용하자">2.10. 한번에 여러 명령어를 쓸 경우 pipeline 활용하자.</h3> <p>여러 명령어를 한번에 실행할 경우 매번 명령어를 실행하기 보다 pipeline 을 사용하여 명령어를 실행하면 매번 커넥션을 맺어야하는 리소스를 줄 일 수 있다.</p> <h3 id="211-tcp-backlog-사이즈-조절">2.11. Tcp backlog 사이즈 조절</h3> <p>backlog 는 응답을 클라이언트에게 보내고 잘받았는지 체크 후 backlog 에서 제거한다. 동시에 많은 명령어가 몰려올때 backlog에 쌓이는데 backlog 사이즈보다 backlog에 쌓이는 수가 많으면 이슈가 발생할 수 있다.</p> <h3 id="212-info-all-로-서버상태-확인하기">2.12. Info all 로 서버상태 확인하기</h3> <p>Info all로 레디스의 상태를 확인 할 수 있다. commandstats 영역에서는 지금까지 사용된 명령어의 통계를 볼 수 있기때문에 어떤 명령어에서 많은 시간이 걸렸는지 확인이 가능하다.info all 에 보이는 통계는 config resetstat 으로 초기화가 가능하다.</p> <h2 id="3-참고">3. 참고</h2> <ul> <li><a href="http://redisgate.kr/redis/configuration/internal_quicklist.php">http://redisgate.kr/redis/configuration/internal_quicklist.php</a></li> <li><a href="https://www.linkedin.com/pulse/performance-tuning-redis-lalit-kumar-jain/">https://www.linkedin.com/pulse/performance-tuning-redis-lalit-kumar-jain/</a></li> <li><a href="https://redis.com/blog/redis-running-slowly-heres-what-you-can-do-about-it/">https://redis.com/blog/redis-running-slowly-heres-what-you-can-do-about-it/</a></li> <li><a href="http://redisgate.kr/redis/configuration/param_save.php">http://redisgate.kr/redis/configuration/param_save.php</a></li> <li><a href="https://redis.io/topics/clients">https://redis.io/topics/clients</a></li> <li><a href="https://mozi.tistory.com/369">https://mozi.tistory.com/369</a></li> </ul>]]></content><author><name></name></author><category term="Redis"/><category term="redis,"/><category term="레디스"/><summary type="html"><![CDATA[레디스에 대한 간단한 설명과 성능향상시키기]]></summary></entry></feed>