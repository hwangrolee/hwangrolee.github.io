---
layout: post
title: Java 8 이후 바뀐 자바 문법 총정리 — Java 17까지 꼭 알아야 할 핵심 변화
date: 2025-08-06 00:00:00
description: Java 8에서 Java 17로 업그레이드해야 하는 이유와 핵심 신기능들을 실무 예제와 함께 알아보세요
tags: 자바
keywords: Java 17, 자바 17, Java 8 마이그레이션, Java 8 vs 17, Java 17 신기능, Java migration, Java 업그레이드, var 키워드, record 클래스, Text Block, switch 표현식, Pattern Matching, sealed class, Spring Boot 3, LTS, 자바 최신 기능, 자바 개발, 자바 프로그래밍, 자바 8 개발자, Java 11 vs 17
categories: 자바
giscus_comments: true
toc:
  sidebar: left
featured: false
---

Java 8은 오랜 기간 동안 자바 개발의 중심이었습니다.

람다, 스트림, Optional 등 지금도 널리 쓰이는 기능들이 도입되면서 자바 개발자들에게 새로운 방식의 프로그래밍을 소개했던 버전입니다.

하지만 그로부터 벌써 10년이 흘렀고, 자바는 지금도 꾸준히 진화하고 있습니다.
많은 개발자들이 Java 8에 머물러 있는 동안, 자바는 코드 작성 방식, API 설계 방식, 클래스 설계 방식에서 많은 변화를 겪었습니다.

### Java 17이 중요한 이유

가장 큰 이유는 Spring Boot 3.x부터 Java 17 이상을 필수로 요구하기 때문입니다.

이제 새로운 프로젝트나 주요 프레임워크를 최신으로 사용하려면 Java 17은 선택이 아니라 기본 전제가 되었습니다.

또한 Java 17은 장기 지원(LTS) 버전입니다.

Java 11 이후 6년 만에 등장한 LTS 버전으로, 기업 환경에서도 안정적으로 채택되고 있으며 다양한 프레임워크들이 Java 17을 기준으로 개발되고 있습니다.

### 바뀐 건 단순히 버전 숫자만이 아닙니다

**_Java 9부터 17까지는 단순한 기능 추가나 마이너 개선이 아니라, 자바라는 언어의 방향성과 스타일 자체에 변화가 있었습니다._** 기존의 장황한 코딩 방식은 더 이상 필수가 아니며, 이제는 간결하고 읽기 쉬운 코드, 명확한 타입 추론, 안전한 클래스 설계 방식이 주류가 되었습니다.

또한 자바는 최근 몇 년간의 변화 속도도 매우 빨라졌습니다. 예전에는 몇 년마다 새 버전이 나왔지만, 이제는 매년 새로운 기능과 개선 사항이 정기적으로 포함되며, 이러한 변화는 자바를 과거의 언어가 아닌 현대적인 언어로 다시 만들어가고 있습니다.

**_Java 17을 기준으로 개발 환경이 재편되고 있습니다._** 현재 대부분의 주요 프레임워크와 라이브러리는 Java 17을 기준으로 작동하거나, 그 이상을 요구하고 있습니다. 예를 들어 Spring Boot 3, Hibernate 6 등의 프레임워크는 Java 17 이상에서 개발 및 테스트되고 있으며, 이전 버전의 자바에서는 호환되지 않거나 일부 기능을 쓸 수 없는 경우도 많습니다.

또한 클라우드 네이티브 개발 환경, 빌드 시스템, 테스트 프레임워크 등도 Java 17에 맞춰 업데이트되고 있습니다. 자바 개발자로서의 경쟁력을 유지하고 싶다면 Java 17은 더 이상 선택이 아닌 필수입니다.

### Java 8 개발자라면 지금이 적기입니다.

Java 17로의 전환은 생각보다 어렵지 않습니다. 특히 Java 8까지 익숙한 개발자라면, 지금부터 주요 문법과 특징 몇 가지만 익히면 금방 적응할 수 있습니다.

- 새로운 프로젝트를 Java 17 기반으로 시작하려는 분들,
- Spring Boot 3로 마이그레이션을 고민 중인 분들,
- Lombok 없이 깔끔한 코드를 작성하고 싶은 분들이라면,

이제는 Java 17을 학습할 시점입니다.

### var 키워드 – 지역 변수 타입 추론 (Java 10 도입)

**Java 8 방식**

```java
Map<String, List<Integer>> scores = new HashMap<>();
```

**Java 17 방식**

```javaa
var scores = new HashMap<String, List<Integer>>();
```

**어떤 점이 좋아졌나?**

코드가 훨씬 간결해집니다. 특히 제네릭 타입이 길어질수록 우측 타입만으로 충분히 추론 가능할 때, 가독성이 올라갑니다.

타입은 컴파일 타임에 고정되므로 동적 타입처럼 오해할 필요가 없습니다.

**주의할 점**

타입을 명확히 드러내는 것이 중요한 경우, var 대신 명시적 타입 사용이 오히려 낫습니다.

### record – 불변 데이터 클래스를 한 줄로 (Java 16 도입)

**Java 8 방식**

```java
public class User {
private final String name;
private final int age;

        public User(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() { return name; }
        public int getAge() { return age; }

        @Override
        public boolean equals(Object o) { ... }
        @Override
        public int hashCode() { ... }
        @Override
        public String toString() { ... }

    }
```

**Java 17 방식**

```java
public record User(String name, int age) {}
```

**어떤 점이 좋아졌나?**

- 불변 객체 패턴을 아주 간결하게 작성할 수 있습니다.
- 생성자, getter, equals, hashCode, toString을 자동 생성합니다.
- Lombok 없이도 DTO를 쉽게 만들 수 있습니다.
- 데이터 중심 클래스를 명확히 표현할 수 있습니다.

### Text Block – 멀티라인 문자열 (Java 15 도입)

**Java 8 방식**

```java
String json = "{\n" +
    " \"name\": \"John\",\n" +
    " \"age\": 30\n" +
    "}";
```

**Java 17 방식**

```java
String json = """
    {
    "name": "John",
    "age": 30
    }
    """;
```

**어떤 점이 좋아졌나?**

- 멀티라인 문자열을 이스케이프 없이 그대로 표현할 수 있습니다.
- SQL, JSON, XML, HTML 같은 문자열을 쓸 때 가독성이 대폭 향상됩니다.
- 들여쓰기나 줄바꿈 처리도 유연하게 지원됩니다.

### switch 표현식 – 조건문을 더 간결하고 안전하게 (Java 14 도입)

**Java 8 방식**

```java
String result;
switch (day) {
    case MONDAY:
    case TUESDAY:
        result = "Weekday";
        break;
    case SATURDAY:
    case SUNDAY:
        result = "Weekend";
        break;
    default:
        result = "Unknown";
}
```

**Java 17 방식**

```java
String result = switch (day) {
    case MONDAY, TUESDAY -> "Weekday";
    case SATURDAY, SUNDAY -> "Weekend";
    default -> "Unknown";
};
```

**어떤 점이 좋아졌나?**

- 값을 반환할 수 있는 switch 표현식이 도입되어, 변수를 미리 선언할 필요가 없습니다.
  - 문법으로 break 누락으로 인한 실수 방지.
- yield를 활용하면 복잡한 로직도 표현 가능.
- 함수형 스타일에 더 가까워졌습니다.

### Pattern Matching for instanceof – 타입 검사와 캐스팅을 동시에 (Java 16 도입)

**Java 8 방식**

```java
if (obj instanceof User) {
    User user = (User) obj;
    System.out.println(user.getName());
}
```

**Java 17 방식**

```java
if (obj instanceof User user) {
    System.out.println(user.getName());
}
```

**어떤 점이 좋아졌나?**

- 중복 코드 제거: 타입 체크 후 명시적 캐스팅을 반복할 필요가 없습니다.
- 가독성 향상: 조건문에서 타입 이름을 한 번만 쓰면 됩니다.
- 향후 도입될 switch 패턴 매칭과도 연계됩니다.

## sealed class – 상속을 명시적으로 제한 (Java 17 정식 도입)

**Java 8 방식**

- 상속 제한을 하려면 final로 막거나, 문서로 설명해야 했습니다.

**Java 17 방식**

```java
public sealed class Animal permits Dog, Cat {}
public final class Dog extends Animal {}
public final class Cat extends Animal {}
```

**어떤 점이 좋아졌나?**

- 허용된 하위 클래스만 상속할 수 있도록 제한합니다.
- 클래스 계층 구조가 예측 가능하고 안전해집니다.
- 도메인 모델링 시, 허용된 상태나 유형만 정의 가능.
- 자바 컴파일러가 하위 클래스를 정확히 알기 때문에 패턴 매칭에도 최적화됩니다.

### 기타 유용한 변화들

- String에 새로운 메서드들 추가
- isBlank(): 공백 문자열 여부 확인
- repeat(int): 문자열 반복
- lines(): 줄 단위로 스트림 처리
- HttpClient: java.net.http.HttpClient가 정식 API로 도입됨 (Java 11)
- jshell: 자바 REPL 지원 (Java 9) – 빠른 테스트 가능

### 마무리 요약

Java 17로 넘어오면서 자바는 더 이상 "장황한 코드"를 쓰는 언어가 아닙니다.
코드는 짧아졌고, 타입은 안전해졌으며, 불변성을 쉽게 유지할 수 있고, 조건문도 더 선언적으로 바뀌었습니다.

기존 Java 8 방식에 익숙한 개발자라면, 다음과 같은 점에서 만족하실 수 있습니다:

- DTO 작성이 1줄로 끝난다 (record)
- 조건문이 훨씬 직관적이다 (switch, pattern matching)
- JSON이나 SQL 문자열을 쓸 때 코드가 지저분하지 않다 (text block)
- 상속과 타입 검사도 명확해졌다 (sealed, instanceof 개선)

지금 Java 17을 익혀두신다면 앞으로 자바 개발에서 훨씬 높은 생산성과 안정성을 얻을 수 있습니다.
